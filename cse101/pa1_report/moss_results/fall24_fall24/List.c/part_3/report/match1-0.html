<html>
<head>
<title>/fall24/nlanz/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/nlanz/pa1/List.c<p></p><pre>
/***
* Niko Lanz
* nlanz
* 2024 Fall CSE101 PA1
* List.c
* List ADT implementation
***/

#include "List.h"
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

<a name="2"></a><font color="#0000FF"><a href="match1-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

typedef int ListElement;

typedef struct NodeObj* Node;

typedef struct NodeObj {
    Node previous;
    Node next;
    ListElement data;
} NodeObj;

typedef struct ListObj {
   Node front;
   Node back;
   int cursorIndex;
   Node cursorPtr;
   int length;
} ListObj;

List newList() {
    List thing = malloc(sizeof(ListObj));
    if (thing == NULL) {
        fprintf(stderr, "List Error: newList() malloc failed\n");
        exit(EXIT_FAILURE);
    }
    thing-&gt;front = NULL;
    thing-&gt;back = NULL;
    thing-&gt;cursorIndex = -1;
    thing-&gt;cursorPtr = NULL;
    thing-&gt;length = 0;
    return thing;
}

void freeList(List* pL) {
    if (pL == NULL || *pL == NULL) return;
    List L = *pL;
    Node currentNode = L-&gt;front;
    while (currentNode) {
        Node nextNode = currentNode-&gt;next;
        free(currentNode);
        currentNode = nextNode;
    }
    free(L);
    *pL = NULL;
}

int length(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called length() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;length;
}

int index(List L) {
</font>    if (L == NULL) {
        fprintf(stderr, "List Error: called index() on null list reference\n");
        exit(EXIT_FAILURE);
    }
<a name="4"></a><font color="#FF00FF"><a href="match1-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    return L-&gt;cursorIndex;
}

int front(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called front() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called front() on empty list\n");
</font>        exit(EXIT_FAILURE);
    }
    return L-&gt;front-&gt;data;
}

int back(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called back() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called back() on empty list\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;back-&gt;data;
}

int get(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called get() on null list reference\n");
        exit(EXIT_FAILURE);
    }
<a name="0"></a><font color="#FF0000"><a href="match1-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_39.gif"/></a>

    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called get() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex == -1) {
        fprintf(stderr, "List Error: called get() on list with no cursor index\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;cursorPtr-&gt;data;
}

bool equals(List A, List B) {
    if (A == NULL) {
        fprintf(stderr, "List Error: called equals() on null list reference (argument 1)\n");
        exit(EXIT_FAILURE);
    }
    if (B == NULL) {
        fprintf(stderr, "List Error: called equals() on null list reference (argument 2)\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;length != B-&gt;length) return false;
    Node currentNodeA = A-&gt;front;
    Node currentNodeB = B-&gt;front;
    while (currentNodeA) {
        if (currentNodeA-&gt;data != currentNodeB-&gt;data) return false;
        currentNodeA = currentNodeA-&gt;next;
        currentNodeB = currentNodeB-&gt;next;
    }
    return true;
}

void clear(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called clear() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    Node currentNode = L-&gt;front;
    while (currentNode) {
        Node nextNode = currentNode-&gt;next;
        free(currentNode);
        currentNode = nextNode;
    }
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursorIndex = -1;
    L-&gt;cursorPtr = NULL;
    L-&gt;length = 0;
}

void set(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called set() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called set() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex == -1) {
        fprintf(stderr, "List Error: called set() on list with no cursor index\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursorPtr-&gt;data = x;
}

void moveFront(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called moveFront() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length) {
        L-&gt;cursorIndex = 0;
        L-&gt;cursorPtr = L-&gt;front;
    }
}

void moveBack(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called moveBack() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length) {
        L-&gt;cursorIndex = L-&gt;length - 1;
        L-&gt;cursorPtr = L-&gt;back;
    }
}

void movePrev(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called movePrev() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex &gt; 0) {
        L-&gt;cursorIndex--;
        L-&gt;cursorPtr = L-&gt;cursorPtr-&gt;previous;
    } else if (L-&gt;cursorIndex == 0) {
        L-&gt;cursorIndex = -1;
        L-&gt;cursorPtr = NULL;
    }
}

void moveNext(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called moveNext() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex == -1) return;
    if (L-&gt;cursorIndex &lt; L-&gt;length - 1) {
        L-&gt;cursorIndex++;
        L-&gt;cursorPtr = L-&gt;cursorPtr-&gt;next;
    } else if (L-&gt;cursorIndex == L-&gt;length - 1) {
        L-&gt;cursorIndex = -1;
        L-&gt;cursorPtr = NULL;
    }
}

void prepend(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called prepend() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    Node newElement = malloc(sizeof(NodeObj));
    newElement-&gt;data = x;
    newElement-&gt;previous = NULL;
    newElement-&gt;next = L-&gt;front;

    if (L-&gt;length == 0) {
        L-&gt;back = newElement;
    } else {
        L-&gt;front-&gt;previous = newElement;
    }
    L-&gt;front = newElement;
    L-&gt;length++;
    if (L-&gt;cursorIndex != -1) L-&gt;cursorIndex++;
}

void append(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called append() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    Node newElement = malloc(sizeof(NodeObj));
    newElement-&gt;data = x;
    newElement-&gt;previous = L-&gt;back;
    newElement-&gt;next = NULL;

    if (L-&gt;length == 0) {
        L-&gt;front = newElement;
    } else {
        L-&gt;back-&gt;next = newElement;
    }
    L-&gt;back = newElement;
    L-&gt;length++;
}

void insertBefore(List L, int x) {
    if (L == NULL) {
</font>        fprintf(stderr, "List Error: called insertBefore() on null list reference\n");
        exit(EXIT_FAILURE);
    }
<a name="3"></a><font color="#00FFFF"><a href="match1-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called insertBefore() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex == -1) {
        fprintf(stderr, "List Error: called insertBefore() on list with no cursor index\n");
        exit(EXIT_FAILURE);
    }
    Node newElement = malloc(sizeof(NodeObj));
    newElement-&gt;data = x;
    newElement-&gt;previous = L-&gt;cursorPtr-&gt;previous;
    newElement-&gt;next = L-&gt;cursorPtr;

    if (L-&gt;cursorIndex == 0) {
        L-&gt;front = newElement;
    } else {
        L-&gt;cursorPtr-&gt;previous-&gt;next = newElement;
    }
    L-&gt;cursorPtr-&gt;previous = newElement;
    L-&gt;length++;
    L-&gt;cursorIndex++;
</font>}

void insertAfter(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called insertAfter() on null list reference\n");
        exit(EXIT_FAILURE);
    }
<a name="1"></a><font color="#00FF00"><a href="match1-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_32.gif"/></a>

    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called insertAfter() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex == -1) {
        fprintf(stderr, "List Error: called insertAfter() on list with no cursor index\n");
        exit(EXIT_FAILURE);
    }
    Node newElement = malloc(sizeof(NodeObj));
    newElement-&gt;data = x;
    newElement-&gt;previous = L-&gt;cursorPtr;
    newElement-&gt;next = L-&gt;cursorPtr-&gt;next;
    
    if (L-&gt;cursorIndex == L-&gt;length - 1) {
        L-&gt;back = newElement;
    } else {
        L-&gt;cursorPtr-&gt;next-&gt;previous = newElement;
    }
    L-&gt;cursorPtr-&gt;next = newElement;
    L-&gt;length++;
}

void deleteFront(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called deleteFront() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called deleteFront() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorPtr == L-&gt;front) {
        L-&gt;cursorPtr = NULL;
        L-&gt;cursorIndex = -1;
    } else if (L-&gt;cursorIndex != -1) {
        L-&gt;cursorIndex--;
    }
    Node afterFront = L-&gt;front-&gt;next;
    free(L-&gt;front);
    L-&gt;front = afterFront;
    if (L-&gt;front) L-&gt;front-&gt;previous = NULL;
    L-&gt;length--;
}

void deleteBack(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called deleteBack() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called deleteBack() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorPtr == L-&gt;back) {
        L-&gt;cursorPtr = NULL;
        L-&gt;cursorIndex = -1;
    }
    Node beforeBack = L-&gt;back-&gt;previous;
    free(L-&gt;back);
    L-&gt;back = beforeBack;
    if (L-&gt;back) L-&gt;back-&gt;next = NULL;
    L-&gt;length--;
}

void delete(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called delete() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: called delete() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursorIndex == -1) {
        fprintf(stderr, "List Error: called delete() on list with no cursor index\n");
        exit(EXIT_FAILURE);
    }
    Node afterCursor = L-&gt;cursorPtr-&gt;next;
    Node beforeCursor = L-&gt;cursorPtr-&gt;previous;
    if (L-&gt;cursorPtr == L-&gt;front) {
        L-&gt;front = afterCursor;
    } else if (L-&gt;cursorPtr == L-&gt;back) {
        L-&gt;back = beforeCursor;
    }
    free(L-&gt;cursorPtr);
    L-&gt;cursorPtr = NULL;
    L-&gt;cursorIndex  = -1;
    if (afterCursor) {
        afterCursor-&gt;previous = beforeCursor;
    }
    if (beforeCursor) {
        beforeCursor-&gt;next = afterCursor;
    }
    L-&gt;length--;
}

void printList(FILE* out, List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: called printList() on null list reference\n");
        exit(EXIT_FAILURE);
    }
    if (L == NULL) {
        fprintf(stderr, "List Error: called printList() on null FILE reference\n");
        exit(EXIT_FAILURE);
    }
    for (Node n = L-&gt;front; n != NULL; n = n-&gt;next) {
        if (n != L-&gt;front) fprintf(out, " ");
        fprintf(out, "%d", n-&gt;data);
    }
}

List copyList(List L) {
    List copy = newList();
    for (Node n = L-&gt;front; n != NULL; n = n-&gt;next) {
        append(copy, n-&gt;data);
</font>    }
    return copy;
}</pre>
</body>
</html>
