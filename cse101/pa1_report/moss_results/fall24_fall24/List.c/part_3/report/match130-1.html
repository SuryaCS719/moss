<html>
<head>
<title>/fall24/scaquino/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/advilche/pa1/List.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

typedef struct NodeObj* Node;

typedef struct NodeObj{
   int data;
   Node next;
   Node prev;
} NodeObj;

typedef struct ListObj{
   int length;          // number of items in this Queue
   Node front;           // index of front element
   Node back;            // index of back element
   Node cursor;          // cursor Node
   int index;		 // Index value of cursor
} ListObj;

// Constructors-Destructors ---------------------------------------------------

Node newNode(int data) {
        Node N = malloc(sizeof(NodeObj));
        assert( N != NULL);
        N-&gt;data = data;
        N-&gt;next = NULL;
        N-&gt;prev = NULL;
        return N;
}

//free Node

void freeNode(Node* pN){
        if ( (pN != NULL) &amp;&amp; (*pN != NULL)){
		free(*pN);
		*pN = NULL;
        }
}

// New List

List newList(void){
	List L;
	L = malloc(sizeof(ListObj));
	assert(L != NULL);
	L-&gt;front = NULL;
	L-&gt;back = NULL;
	L-&gt;cursor = NULL;
	L-&gt;length = 0;
	L-&gt;index = -1;
	return L;

}

void freeList(List* pL){
   if(pL!=NULL &amp;&amp; *pL!=NULL) {
      while(length(*pL) &gt; 0){
	      deleteFront(*pL);
      }
      free(*pL);
      *pL = NULL;
   }
}

// Access functions -----------------------------------------------------------

int length(List L){
	if(L == NULL){
		fprintf(stderr, "List error: calling length() on NULL List element\n");
		exit(EXIT_FAILURE);
	}
	return L-&gt;length;
}

int index(List L){
	if(L == NULL){
                fprintf(stderr, "List error: calling index() on NULL List element\n");
        	exit(EXIT_FAILURE);
	}
	return L-&gt;index;
}

int front(List L){
	if(length(L) &gt; 0){
		return L-&gt;front-&gt;data; // look at dis later
	}
	else{
		fprintf(stderr, "List error: calling front() on undefined length (length &lt; 0)\n");
		exit(EXIT_FAILURE);;
	}
}

int back(List L){
	if(length(L) &gt; 0){
                return L-&gt;back-&gt;data; // look at dis later
        }
        else{
                fprintf(stderr, "List error: calling back() on undefined length (length &lt; 0)\n");
		exit(EXIT_FAILURE);;
        }
}

int get(List L){
	if (L-&gt;length &lt;= 0) {
        	printf("List Error: calling get() on an empty List\n");
        	exit(EXIT_FAILURE);
	}
    	if (L-&gt;index &lt; 0) {
        	printf("List Error: calling get() on undefined cursor\n");
        	exit(EXIT_FAILURE);
        
        }

	return L-&gt;cursor-&gt;data; // look at dis later
}

bool equals(List A, List B){
	if (A == NULL || B == NULL) {
        	printf("List Error: calling equals() on NULL List reference\n");
        	exit(EXIT_FAILURE);
	}

    	if (A-&gt;length != B-&gt;length){
		return false;
	}

    	Node NodeA = A-&gt;front;
    	Node NodeB = B-&gt;front;
    	while (NodeA != NULL) {
        	if (NodeA-&gt;data != NodeB-&gt;data){
			return false;
		}
        	NodeA = NodeA-&gt;next;
        	NodeB = NodeB-&gt;next;
    	}
	return true;

}

// Manipulation procedures ----------------------------------------------------

void clear(List L){
	while (L-&gt;length &gt; 0){
		deleteFront(L);
	}
	L-&gt;cursor = NULL;
	L-&gt;index = -1;
}

void set(List L, int x){
	if(L-&gt;cursor != NULL){
		L-&gt;cursor-&gt;data = x;
	}
	else{
		fprintf(stderr, "List error: calling set() on undefined cursor\n");
        	exit(EXIT_FAILURE);
	}
}

void moveFront(List L){
	if(L-&gt;length &gt; 0){
		L-&gt;cursor = L-&gt;front;
		L-&gt;index = 0;
	}
}

void moveBack(List L){
	if(L-&gt;length &gt; 0){
                L-&gt;cursor = L-&gt;back;
                L-&gt;index = L-&gt;length - 1;
        }
}

void movePrev(List L){
	if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;front) {
        	L-&gt;cursor = L-&gt;cursor-&gt;prev;
        	L-&gt;index -= 1;
	}
	else{
		L-&gt;cursor = NULL;
	        L-&gt;index = -1;
	}
}


void moveNext(List L){
	if(L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;back){
		L-&gt;cursor = L-&gt;cursor-&gt;next;
		L-&gt;index += 1;
	}
	else{
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	}
}

void prepend(List L, int x){
	Node N = newNode(x);
	if(L-&gt;length &gt; 0){
		N-&gt;next = L-&gt;front;
		L-&gt;front-&gt;prev = N;
		L-&gt;front = N;
	}
	else if (L-&gt;length == 0){
		L-&gt;front = N;
		L-&gt;back = N;
	}
	L-&gt;length += 1;
	
	if(L-&gt;index != -1){
		L-&gt;index += 1;
	}
}

void append(List L, int x){
	if (L == NULL) {
        	printf("List Error: calling append() on NULL List reference\n");
        	exit(EXIT_FAILURE);
    	}
	Node newNode1 = newNode(x);
	if(L-&gt;length == 0){
		L-&gt;front = newNode1;
                L-&gt;back = newNode1;
	}
	else{
		newNode1-&gt;prev = L-&gt;back;
                L-&gt;back-&gt;next = newNode1;
                L-&gt;back = newNode1;
        }
	L-&gt;length += 1;
}

<a name="2"></a><font color="#0000FF"><a href="match130-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

void insertBefore(List L, int x){
	if(L == NULL){
                fprintf(stderr, "List error: calling insertBefore() on NULL list reference\n");
                exit(EXIT_FAILURE);
        }
	
	if ((L-&gt;length &lt;= 0) || (L-&gt;index &lt; 0)) {
		fprintf(stderr, "List error: calling insertBefore() on empty list or undefined cursor\n");
		exit(EXIT_FAILURE);
	}
	
	
	if (L-&gt;cursor == L-&gt;front){
		prepend(L,x);
</font>	}

	else{
		Node n = newNode(x);
		n-&gt;next = L-&gt;cursor;
		n-&gt;prev = L-&gt;cursor-&gt;prev;
		L-&gt;cursor-&gt;prev-&gt;next = n;
		L-&gt;cursor-&gt;prev = n;
		L-&gt;length += 1;
		L-&gt;index += 1;
	}
}

<a name="3"></a><font color="#00FFFF"><a href="match130-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

void insertAfter(List L, int x){
        if(L == NULL){
		fprintf(stderr, "List error: calling insertAfter() on NULL list reference\n");
                exit(EXIT_FAILURE);
	}
	
	if (L-&gt;length &lt;= 0 || L-&gt;index &lt; 0) {
                fprintf(stderr, "List error: calling insertAfter() on empty list or undefined cursor\n");
                exit(EXIT_FAILURE);
        }

	if(L-&gt;cursor == L-&gt;back){
		append(L, x);
</font>	}
        else{
                Node n = newNode(x);
		n-&gt;prev = L-&gt;cursor;
		n-&gt;next = L-&gt;cursor-&gt;next;
		L-&gt;cursor-&gt;next-&gt;prev = n;
		L-&gt;cursor-&gt;next = n;
		L-&gt;length += 1;
        }
}


void deleteFront(List L){
	if (L == NULL) {
        	printf("List Error: calling deleteFront() on NULL List reference\n");
        	exit(EXIT_FAILURE);
   	}
    	if (L-&gt;length &lt;= 0) {
        	printf("List Error: calling deleteFront() on an empty List\n");
        	exit(EXIT_FAILURE);
    	}
    	
	Node N = L-&gt;front;
    	if (L-&gt;length &gt; 1) {
        	L-&gt;front = L-&gt;front-&gt;next;
        	L-&gt;front-&gt;prev = NULL;
    	}

    	else{
<a name="4"></a><font color="#FF00FF"><a href="match130-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        	L-&gt;front = L-&gt;back = NULL;
    	}

    	if (L-&gt;cursor == N) {
        	L-&gt;cursor = NULL;
        	L-&gt;index = -1;
    	}
    	
	freeNode(&amp;N);
</font>    	L-&gt;length -= 1;
    	if (L-&gt;index != -1){
		L-&gt;index--;
    	}
}


<a name="0"></a><font color="#FF0000"><a href="match130-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

void deleteBack(List L){
        if(L-&gt;length &lt;= 0){
                fprintf(stderr, "List error: calling deleteBack() on empty list\n");
        	exit(EXIT_FAILURE);
	}

	Node temp = L-&gt;back;
	if(L-&gt;length &gt; 1){
		L-&gt;back = L-&gt;back-&gt;prev;
		L-&gt;back-&gt;next = NULL;
	}

	else{
		L-&gt;back = NULL;
		L-&gt;front = NULL;
	}

	if(L-&gt;cursor == temp){
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	}


	freeNode(&amp;temp);
</font>	L-&gt;length -= 1;
}

void delete(List L){
<a name="1"></a><font color="#00FF00"><a href="match130-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

	if((length(L) &lt;= 0 || L-&gt;cursor-&gt;data &lt; 0)){
                fprintf(stderr, "List error: calling delete() on empty list\n");
        	exit(EXIT_FAILURE);
	}
	
	Node N = L-&gt;cursor;
    	if (N == L-&gt;front) {
        	deleteFront(L);
    	} 
	else if (N == L-&gt;back) {
        	deleteBack(L);
    	}
       	else{
        	N-&gt;prev-&gt;next = N-&gt;next;
        	N-&gt;next-&gt;prev = N-&gt;prev;
        	freeNode(&amp;N);
</font>        	L-&gt;length -= 1;
    	}
    	L-&gt;cursor = NULL;
    	L-&gt;index = -1;
}


void printList(FILE* out, List L){
	Node current = L-&gt;front;
    	while (current != NULL) {
        	fprintf(out, "%d ", current-&gt;data);
        	current = current-&gt;next;
    	}
    	fprintf(out, "\n");
}

List copyList(List L){
	List newList1 = newList();
    	Node current = L-&gt;front;
    	while (current != NULL) {
        	append(newList1, current-&gt;data);
        	current = current-&gt;next;
    	}
	return newList1;
}
</pre>
</body>
</html>
