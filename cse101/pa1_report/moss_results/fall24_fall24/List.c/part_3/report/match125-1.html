<html>
<head>
<title>/fall24/migquinn/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/nnakamot/pa1/List.c<p></p><pre>
/***
* Nathan Nakamoto
* nnakamot 
* 2024 Fall CSE101 PA1
* List.c
* Implementation file for the List ADT. Provides function definitions for creating, modifying, and freeing List structures. Make sure all memory management functions (freeNode, delete, etc.) are used correctly to avoid memory leaks.
***/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "List.h"
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;

typedef struct NodeObj {
    int data;
    struct NodeObj* next;
    struct NodeObj* prev;
} NodeObj;

typedef NodeObj* Node;

typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int length;
    int Index;
} ListObj;


Node newNode(int data) {
    Node N = malloc(sizeof(NodeObj));
    assert(N);
    N-&gt;data = data;
    N-&gt;next = NULL;
    N-&gt;prev = NULL;
    return N;
}

void freeNode(Node* pN) {
    if (pN != NULL &amp;&amp; *pN != NULL) {
        free(*pN);
        *pN = NULL;
    }
}

List newList(void) {
    List L = malloc(sizeof(ListObj));
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;Index = -1;
    return L;
}

void freeList(List* pL) {
    if (pL != NULL &amp;&amp; *pL != NULL) {
        while (length(*pL) &gt; 0) {
            deleteFront(*pL);
        }
        free(*pL);
        *pL = NULL;

    }
}



int length(List L) {
    return L-&gt;length;
}

int index(List L) {
    return L-&gt;Index;
}

int front(List L) {
<a name="0"></a><font color="#FF0000"><a href="match125-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    if (L-&gt;length &gt; 0) {
        return L-&gt;front-&gt;data;
    }
    return -1; // Undefined if the list is empty
}

int back(List L) {
    if (L-&gt;length &gt; 0) {
        return L-&gt;back-&gt;data;
    }
    return -1; // Undefined if the list is empty
}

int get(List L) {
    if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;Index &gt;= 0) {
        return L-&gt;cursor-&gt;data;
    }
    return -1; // Undefined if cursor is undefined
}

bool equals(List A, List B) {
    if (A-&gt;length != B-&gt;length) {
</font>        return 0;
    }
    Node N = A-&gt;front;
    Node M = B-&gt;front;
    while (N != NULL) {
        if (N-&gt;data != M-&gt;data) {
            return 0;
        }
        N = N-&gt;next;
        M = M-&gt;next;
    }
    return 1;
}

void clear(List L) {
    while (length(L) &gt; 0) {
        deleteFront(L);
    }
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;length = 0;
    L-&gt;Index = -1;
    L-&gt;cursor = NULL;
}

void set(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "List Error: calling set() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &lt;= 0 || L-&gt;Index &lt; 0) {
        fprintf(stderr, "List Error: calling set() on an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursor-&gt;data = x;
}

void moveFront(List L) {
    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;front;
        L-&gt;Index = 0;
    }
}

void moveBack(List L) {
    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;back;
        L-&gt;Index = L-&gt;length - 1;
    }
}

void movePrev(List L) {
    if (L-&gt;cursor != NULL &amp;&amp; L-&gt;Index != -1) {
        if (L-&gt;cursor == L-&gt;front) {
            L-&gt;cursor = NULL;
            L-&gt;Index = -1;
        } else {
            L-&gt;cursor = L-&gt;cursor-&gt;prev;
            L-&gt;Index--;
        }
    }
}

void moveNext(List L) {
    if (L-&gt;cursor != NULL &amp;&amp; L-&gt;Index != -1) {
        if (L-&gt;cursor == L-&gt;back) {
            L-&gt;cursor = NULL;
            L-&gt;Index = -1;
        } else {
            L-&gt;cursor = L-&gt;cursor-&gt;next;
            L-&gt;Index++;
        }
    }
}

void prepend(List L, int data) {
    Node N = newNode(data);
    if (L-&gt;length == 0) {
        L-&gt;front = L-&gt;back = N;
    } else {
        N-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = N;
        L-&gt;front = N;
    }
<a name="3"></a><font color="#00FFFF"><a href="match125-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    L-&gt;length++;
    if (L-&gt;Index != -1) {
        L-&gt;Index++;
    }
}

void append(List L, int data) {
    Node N = newNode(data);
    if (L-&gt;length == 0) {
        L-&gt;front = L-&gt;back = N;
</font>    } else {
        N-&gt;prev = L-&gt;back;
        L-&gt;back-&gt;next = N;
        L-&gt;back = N;
    }
    L-&gt;length++;
}

void insertBefore(List L, int data) {
    if (L-&gt;cursor != NULL &amp;&amp; L-&gt;Index &gt;= 0) {
        if (L-&gt;cursor == L-&gt;front) {
            prepend(L, data);
        } else {
	    Node N = newNode(data);	
            N-&gt;prev = L-&gt;cursor-&gt;prev;
            N-&gt;next = L-&gt;cursor;
            L-&gt;cursor-&gt;prev-&gt;next = N;
            L-&gt;cursor-&gt;prev = N;
            L-&gt;length++;
            L-&gt;Index++;
        }
    }
}

void insertAfter(List L, int data) {
    if (L-&gt;cursor != NULL &amp;&amp; L-&gt;Index &gt;= 0) {
   //     Node N = newNode(data);
        if (L-&gt;cursor == L-&gt;back) {
            append(L, data);
        } else {
	    Node N = newNode(data);
            N-&gt;prev = L-&gt;cursor;
            N-&gt;next = L-&gt;cursor-&gt;next;
            L-&gt;cursor-&gt;next-&gt;prev = N;
            L-&gt;cursor-&gt;next = N;
            L-&gt;length++;
<a name="1"></a><font color="#00FF00"><a href="match125-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

	    L-&gt;Index++;
        }
    }
}

void deleteFront(List L) {
    if (L-&gt;length &gt; 0) {
        Node N = L-&gt;front;
        if (L-&gt;length == 1) {
            L-&gt;front = L-&gt;back = NULL;
        } else {
            L-&gt;front = L-&gt;front-&gt;next;
            L-&gt;front-&gt;prev = NULL;
        }
        freeNode(&amp;N);
        L-&gt;length--;
        if (L-&gt;Index != -1) {
            L-&gt;Index--;
</font>        }
    }
}

void deleteBack(List L) {
<a name="2"></a><font color="#0000FF"><a href="match125-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    if (L-&gt;length &gt; 0) {
        Node N = L-&gt;back;
        if (L-&gt;length == 1) {
            L-&gt;front = L-&gt;back = NULL;
        } else {
            L-&gt;back = L-&gt;back-&gt;prev;
            L-&gt;back-&gt;next = NULL;
        }
        freeNode(&amp;N);
</font>	if(L-&gt;Index == L-&gt;length - 1) {
		L-&gt;Index = -1;
		L-&gt;cursor = NULL;
	}
	L-&gt;length--;
    }
}

void delete(List L) {
<a name="4"></a><font color="#FF00FF"><a href="match125-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

    if (L-&gt;cursor != NULL &amp;&amp; L-&gt;Index &gt;= 0) {
        Node N = L-&gt;cursor;
        if (L-&gt;cursor == L-&gt;front) {
            deleteFront(L);
        } else if (L-&gt;cursor == L-&gt;back) {
</font>            deleteBack(L);
        } else {
            N-&gt;prev-&gt;next = N-&gt;next;
            N-&gt;next-&gt;prev = N-&gt;prev;
            freeNode(&amp;N);
            L-&gt;length--;
        }
        L-&gt;cursor = NULL;
        L-&gt;Index = -1;
    }
}


void printList(FILE* out, List L) {
    if (L == NULL) return; 
    Node current = L-&gt;front; 
    while (current != NULL) {
        fprintf(out, "%d ", current-&gt;data);
	current = current-&gt;next; 
    }
}

List copyList(List L) {
    if (L == NULL) {
        fprintf(stderr, "List Error: calling copyList() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    List newL = newList();
    for (Node N = L-&gt;front; N != NULL; N = N-&gt;next) {
        append(newL, N-&gt;data);
    }
    return newL;
}
</pre>
</body>
</html>
