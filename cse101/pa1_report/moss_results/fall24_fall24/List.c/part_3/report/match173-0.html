<html>
<head>
<title>/fall24/mlau16/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/mlau16/pa1/List.c<p></p><pre>
//Mandy Lau
//mlau16
//pa1

#include "List.h"
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

// private Node type
typedef struct NodeObj* Node;

// private NodeObj type
typedef struct NodeObj{
   ListElement data;
   Node next;
   Node prev;
} NodeObj;

typedef struct ListObj{
    Node front;
    Node back;
    int length;
    Node cursor;
    int index;
} ListObj;

Node newNode(ListElement data){
   Node N = malloc(sizeof(NodeObj));
   assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   return(N);
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      free(*pN);
      *pN = NULL;
   }
}

<a name="2"></a><font color="#0000FF"><a href="match173-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

List newList(void){
    List L;
    L = malloc(sizeof(ListObj));
    assert( L!=NULL );
    L-&gt;front = L-&gt;back = NULL;
    L-&gt;length = 0;
    L-&gt;cursor = NULL;
</font>    L-&gt;index = -1;
    return(L);
} 

void freeList(List* pL){
    if(pL!=NULL &amp;&amp; *pL!=NULL){
        clear(*pL);
        free(*pL);
        *pL = NULL;
    }
}
int length(List L){
    if( L==NULL) {
        printf("List Error: calling length() on NULL list\n");
        exit(EXIT_FAILURE);
    }
    return(L-&gt;length);
}
int index(List L){
    return(L-&gt;index);
}
int front(List L){
    if (L-&gt;length &lt;=0){
        printf("Error: there is no front\n");
        exit(EXIT_FAILURE);
    }
    return(L-&gt;front-&gt;data);
}
int back(List L){
    if (L-&gt;length &lt;=0){
        printf("Error: there is no back\n");
        exit(EXIT_FAILURE);
    }
    return(L-&gt;back-&gt;data);
}
int get(List L){
    if (L-&gt;length &lt;=0){
        printf("Error: List is empty while calling get()\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;index &lt;0 ){
        printf("Error: Index is not greater than 0 while calling get()\n");
        exit(EXIT_FAILURE);
    }
    return(L-&gt;cursor-&gt;data);
    
}
bool equals(List A, List B){
    if( A==NULL || B==NULL ){
        printf("Queue Error: calling equals() on NULL Queue\n");
        exit(EXIT_FAILURE);
    }

    bool eq;
    Node N, M;

    eq = ( A-&gt;length == B-&gt;length );
    N = A-&gt;front;
    M = B-&gt;front;
    while( eq &amp;&amp; N!=NULL){
        eq = ( N-&gt;data==M-&gt;data );
        N = N-&gt;next;
        M = M-&gt;next;
    }
    return eq;
} 
void clear(List L){

    while( L-&gt;front!=NULL ){

        Node x = L-&gt;front-&gt;next;
        freeNode(&amp;L-&gt;front);
        L-&gt;front = x;
    }
<a name="4"></a><font color="#FF00FF"><a href="match173-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
}

void set(List L, int x){
    if (L-&gt;length &lt;0){
        printf("Error: List is empty while calling set()\n");
</font>        exit(EXIT_FAILURE);
    }
    if (L-&gt;index &lt;=0 ){
        printf("Error: Index is not greater than 0 while calling set())\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursor-&gt;data = x;

} 
void moveFront(List L){
    if( L-&gt;length != 0 ){
        L-&gt;cursor = L-&gt;front;
        L-&gt;index = 0;
    }
} 
void moveBack(List L){
    if( L-&gt;length !=0 ){
        L-&gt;cursor = L-&gt;back;
        L-&gt;index = L-&gt;length - 1;
    }
} 
void movePrev(List L){
    if(L-&gt;cursor != NULL){
        if(L-&gt;cursor != L-&gt;front){
            L-&gt;cursor = L-&gt;cursor-&gt;prev;
            L-&gt;index -= 1;
        } else if (L-&gt;cursor == L-&gt;front){
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
    }
} 
void moveNext(List L){
    if(L-&gt;cursor != NULL){
        if(L-&gt;cursor != L-&gt;back){
            L-&gt;cursor = L-&gt;cursor-&gt;next;
            L-&gt;index += 1;
        } else if (L-&gt;cursor == L-&gt;back){
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
    }
} 
<a name="0"></a><font color="#FF0000"><a href="match173-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

void prepend(List L, int x){
    Node X = newNode(x);
    if ( L-&gt;length&gt;0 ){
        X-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = X;
        L-&gt;front = X;
        L-&gt;index += 1;
</font>    } else {
        L-&gt;front = L-&gt;back = X;
    } L-&gt;length += 1;

} 
<a name="3"></a><font color="#00FFFF"><a href="match173-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

void append(List L, int x){
    Node X= newNode(x);
    if ( L-&gt;length &gt;0 ){
        L-&gt;back-&gt;next = X;
        X-&gt;prev = L-&gt;back;
        L-&gt;back = X;
</font>
    } else {
        L-&gt;front = L-&gt;back = X;
    } 
    L-&gt;length += 1;
} 
void insertBefore(List L, int x){
    if ( L-&gt;length &lt; 0 ){
        printf("Error: length &lt;= 0 when calling insertBefore()\n");
        exit(EXIT_FAILURE);
    }
    if( L-&gt;index &lt; 0 ){
        printf("Error: index is less than 0 when calling insertBefore()\n");
        exit(EXIT_FAILURE);
    } 
    Node M = newNode(x);
    if(L-&gt;cursor == L-&gt;front){
        Node X = L-&gt;front;
        M-&gt;next = X;
        X-&gt;prev = M;
        L-&gt;front = M;
    } else{
        Node N = L-&gt;cursor-&gt;prev;
        N-&gt;next = M;
        M-&gt;prev = N;
<a name="1"></a><font color="#00FF00"><a href="match173-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        L-&gt;cursor-&gt;prev = M;
        M-&gt;next = L-&gt;cursor;
    }

    L-&gt;length += 1;
    L-&gt;index += 1;

} 
void insertAfter(List L, int x){
    if ( L-&gt;length &lt; 0 ){
</font>        printf("Error: length &lt;= 0 when calling insertBefore()\n");
        exit(EXIT_FAILURE);
    }
    if( L-&gt;index &lt; 0 ){
        printf("Error: index is less than 0 when calling insertBefore()\n");
        exit(EXIT_FAILURE);
    } 

    Node M = newNode(x);
    if(L-&gt;cursor == L-&gt;back){
        Node X = L-&gt;back;
        M-&gt;prev = X;
        X-&gt;next = M;
        L-&gt;back = M;
    }else {
        Node N = L-&gt;cursor-&gt;next;
        N-&gt;prev = M;
        M-&gt;next = N;
        L-&gt;cursor-&gt;next = M;
        M-&gt;prev = L-&gt;cursor;

    }
    L-&gt;length += 1;
} 

void deleteFront(List L){
    if ( L-&gt;length &lt;0 ){
        printf("Error: length of list is less than 0 when calling deleteFront()\n");
        exit(EXIT_FAILURE);
    }
    if(L-&gt;length == 1){
        freeNode(&amp;L-&gt;front);
        L-&gt;length = 0;
        L-&gt;cursor = NULL;
        L-&gt;front = NULL;
        L-&gt;back = NULL;
        L-&gt;index = -1;
    } else {
<a name="5"></a><font color="#FF0000"><a href="match173-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        if(L-&gt;cursor == L-&gt;front){
            L-&gt;index = -1;
        }else{
            L-&gt;index -= 1;
        }
        Node M = L-&gt;front-&gt;next;
</font>        freeNode(&amp;L-&gt;front);
        L-&gt;front = M;
        L-&gt;front-&gt;prev = NULL;
        L-&gt;length -= 1;
    }
} 
void deleteBack(List L){
    if ( L-&gt;length &lt;0 ){
        printf("Error: length of list is less than 0 when calling deleteFront()\n");
        exit(EXIT_FAILURE);
    }
    if(L-&gt;length == 1){
        freeNode(&amp;L-&gt;front);
        L-&gt;length = 0;
        L-&gt;cursor = NULL;
        L-&gt;front = NULL;
        L-&gt;back = NULL;
        L-&gt;index = -1;
    } else {
        if (L-&gt;cursor == L-&gt;back){
            L-&gt;index = -1;
        } 
        Node M = L-&gt;back-&gt;prev;
        freeNode(&amp;L-&gt;back);
        L-&gt;back = M;
        L-&gt;back-&gt;next = NULL;
        L-&gt;length -= 1;
    }
    

} // Delete the back element. Pre: length()&gt;0


void delete(List L){
    if ( L-&gt;length &lt;=0 ){
        printf("Error: length of list is less than 0 when calling delete()\n");
        exit(EXIT_FAILURE);
    }
    if( L-&gt;index&lt;0 ){
        printf("Error: index less than 0 when calling delete()\n");
        exit(EXIT_FAILURE);
    }
    if(L-&gt;cursor == L-&gt;front){
        deleteFront(L);
    } else if (L-&gt;cursor == L-&gt;back){
        deleteBack(L);
    } else {
        Node C = L-&gt;cursor;
        C-&gt;prev-&gt;next = C-&gt;next;
        C-&gt;next-&gt;prev = C-&gt;prev;
        freeNode(&amp;C);
        L-&gt;length -= 1;
    }

  

} 
void printList(FILE* out, List L){

    Node M = L-&gt;front;
    while ( M!=NULL ){
        fprintf(out,"%d ", M-&gt;data);
        M = M-&gt;next;
    }
} 

List copyList(List L){

    List M = newList();
    Node curr = L-&gt;front;
    while( curr!=NULL){
        append(M, curr-&gt;data);
        curr = curr-&gt;next;
    }
    return(M);
} 
List concatList(List A, List B){

<a name="6"></a><font color="#00FF00"><a href="match173-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

    List M = newList();
    moveFront(A);
    while( A-&gt;index &gt;=0 ){
        int x = A-&gt;cursor-&gt;data;
        append(M, x);
        moveNext(A);
</font>    }
    while( B-&gt;index &gt;=0 ){
        int y = B-&gt;cursor-&gt;data;
        append(M, y);
        moveNext(B);
    }
    return M;
} </pre>
</body>
</html>
