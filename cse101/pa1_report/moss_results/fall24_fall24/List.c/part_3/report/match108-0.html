<html>
<head>
<title>/fall24/sikaatwa/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/sikaatwa/pa1/List.c<p></p><pre>
//------------------------------------------------------------------------------
// Name Simar Atwal
// CruzID sikaatwa
// pa1
//------------------------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

// private structs, functions and constants -----------------------------------

typedef struct NodeObj* Node;

typedef struct NodeObj{
   int data;            // number in object
   Node previous;        // index of previous node
   Node next;            // index of next node
} NodeObj;

typedef struct ListObj{
   Node cursor;          // number in object
   Node front;           // index of front element
   Node back;            // index of back element
   int cursor_index;
   int list_length;
} ListObj;

typedef struct ListObj* List;

// Constructors-Destructors ---------------------------------------------------
Node newNode(void){
    Node N;
    N = malloc(sizeof(NodeObj));
    N-&gt;next = NULL;
    N-&gt;previous = NULL;
    return N;
}

void freeNode(Node* pN){
    (*pN)-&gt;next = NULL;
    (*pN)-&gt;previous = NULL;
    free(*pN);
    *pN = NULL;
}

List newList(void){ // Creates and returns a new empty List.
   //printf("starts making list \n"); //DEBUGGING
   List L;
   L = malloc(sizeof(ListObj));
   L-&gt;back = NULL;
   L-&gt;front = NULL;
   L-&gt;cursor = NULL;
   L-&gt; cursor_index = -1;
   L-&gt; list_length = 0;
   //printf("finishes making list \n"); //DEBUGGING
   return(L);
}

void freeList(List* pL){ // Frees all heap memory associated with *pL, and sets
 // *pL to NULL.
    clear(*pL);
    free(*pL);
    *pL = NULL;
}

// Access functions -----------------------------------------------------------
int length(List L){
   if(L == NULL){
      printf("List Error: calling insertBefore() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return L-&gt;list_length;
} // Returns the number of elements in L.

int index(List L){
   if(L-&gt;cursor_index &lt; 0 &amp;&amp; L-&gt; cursor_index &lt; L-&gt;list_length){
      return -1;
   }else{
      return L-&gt;cursor_index;
   }
} // Returns index of cursor element if defined, -1 otherwise.

int front(List L){
   if(length(L) &gt; 0){
      return L-&gt;front-&gt;data;
   }else{
      printf("List Error: Nothing is in the list.\n");
      exit(EXIT_FAILURE);
   }
} // Returns front element of L. Pre: length()&gt;0

int back(List L){
   if(length(L) &gt; 0){
      return L-&gt;back-&gt;data;
   }else{
      printf("List Error: Nothing is in the list.\n");
      exit(EXIT_FAILURE);
   }
} // Returns back element of L. Pre: length()&gt;0

int get(List L){
   if(length(L) &lt;= 0){
      printf("List Error: Nothing is in the list.\n");
      exit(EXIT_FAILURE);
   }
   if(index(L) == -1){
      printf("List Error: Cursor is undefined.\n");
      exit(EXIT_FAILURE);
   }
<a name="1"></a><font color="#00FF00"><a href="match108-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

   return L-&gt;cursor-&gt;data;
} // Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0

bool equals(List A, List B){
   if( A==NULL || B==NULL ){
      printf("List Error: calling equals() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   if (length(A) != length(B)){
      return false;
   }

   Node currentA = A-&gt;front;
   Node currentB = B-&gt;front;
</font>
   while(currentA != NULL &amp;&amp; currentB != NULL){
      if (currentA-&gt;data != currentB-&gt;data){
         return false;
      }
      currentA = currentA-&gt;next;
      currentB = currentB-&gt; next;
   }
   return true;
} // Returns true iff Lists A and B contain the same
 // sequence of elements, returns false otherwise.

// Manipulation procedures ----------------------------------------------------
void clear(List L){
    Node current = L-&gt;front;
    
    Node next;

    while (current != NULL) {
        next = current-&gt;next;
        freeNode(&amp;current);
        current = next;
    }

    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;cursor_index = -1;
    L-&gt;list_length = 0; 
} // Resets L to its original empty state.

void set(List L, int x){
<a name="3"></a><font color="#00FFFF"><a href="match108-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

   if (index(L) &lt; 0){
      printf("List Error: calling set() on undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) &lt;=0 ){
      printf("List Error: calling set() on empty list\n");
      exit(EXIT_FAILURE);
   }
   L-&gt;cursor-&gt;data = x;
} // Overwrites the cursor elementâ€™s data with x.
 // Pre: length()&gt;0, index()&gt;=0

void moveFront(List L){
   if(L == NULL){
</font>      printf("List Error: calling moveFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &gt; 0 ){
      L-&gt;cursor = L-&gt;front;
      L-&gt;cursor_index = 0;
   }
} // If L is non-empty, sets cursor under the front element,
 // otherwise does nothing.

void moveBack(List L){
<a name="0"></a><font color="#FF0000"><a href="match108-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

   if(L == NULL){
      printf("List Error: calling moveBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &gt; 0){
      L-&gt;cursor = L-&gt; back;
      L-&gt;cursor_index = length(L) - 1;
   }
} // If L is non-empty, sets cursor under the back element,
 // otherwise does nothing.

void movePrev(List L){
   if(L == NULL){
      printf("List Error: calling movePrev() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if (L-&gt;cursor_index != -1){ // CURSOR DEFINED
</font>      if (L-&gt;cursor_index == 0){  //CURSOR AT FRONT
         L-&gt;cursor_index = -1;
         L-&gt;cursor = NULL;
      }else { //CURSOR NOT AT FRONT
         L-&gt;cursor_index = L-&gt;cursor_index - 1;
         L-&gt;cursor = L-&gt;cursor-&gt;previous;
      }
   }
   
} // If cursor is defined and not at front, move cursor one
 // step toward the front of L; if cursor is defined and at
 // front, cursor becomes undefined; if cursor is undefined
 // do nothing

void moveNext(List L){
    if(L == NULL){
      printf("List Error: calling moveNext() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if (L-&gt;cursor_index != -1){ // CURSOR DEFINED
      if (L-&gt;cursor_index == length(L) - 1){  //CURSOR AT BACK
         L-&gt;cursor_index = -1;
         L-&gt;cursor = NULL;
      }else { //CURSOR NOT AT BACK
         L-&gt;cursor_index = L-&gt;cursor_index + 1;
         L-&gt;cursor = L-&gt;cursor-&gt;next;
      }
   }
} // If cursor is defined and not at back, move cursor one
 // step toward the back of L; if cursor is defined and at
 // back, cursor becomes undefined; if cursor is undefined
 // do nothing

void prepend(List L, int x){
   if(L == NULL){
      printf("List Error: calling prepend() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   Node newN = newNode();
   newN-&gt;data = x;

   if (length(L) &gt; 0){ // NON-EMPTY LIST
      newN-&gt;next = L-&gt;front;
      L-&gt;front-&gt;previous = newN;
      L-&gt;front = newN;
      L-&gt;cursor_index = L-&gt;cursor_index +1;
   }else{ //EMPTY LIST
      L-&gt;front = newN;
      L-&gt;back = newN;
   }  
   L-&gt;list_length = L-&gt;list_length +1;
   
} // Insert new element into L. If L is non-empty,
 // insertion takes place before front element.

void append(List L, int x){
   if(L == NULL){
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   //printf("Error check 1 \n");
   Node newN = newNode();
   //printf("Error check 2 \n");
   newN-&gt;data = x;
   //printf("Error check 3 \n");
   
   //printf("Error check 4 \n");
   if (length(L) &gt; 0){ // NON-EMPTY LIST
      //printf("Error check 5 \n");
      newN-&gt;previous = L-&gt;back;
      //printf("Error check 6 \n");

      L-&gt;back-&gt;next = newN;
      //printf("Error check 7 \n");
      L-&gt;back = newN;
   }else{ //EMPTY LIST
      //printf("Error check 8 \n");
      L-&gt;front = newN;
      L-&gt;back = newN;
   }  
   L-&gt;list_length = L-&gt;list_length +1;
} // Insert new element into L. If L is non-empty,
 // insertion takes place after back element.

void insertBefore(List L, int x){
   if(L == NULL){
<a name="5"></a><font color="#FF0000"><a href="match108-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

      printf("List Error: calling insertBefore() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &lt;= 0){
      printf("List Error: calling insertBefore() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if(index(L) &lt; 0){
      printf("List Error: calling insertBefore() on undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   
   Node newN = newNode();
   newN -&gt; data = x;
</font>   

   Node oldPrev = L-&gt;cursor-&gt;previous; //SAVE PREVIOUS NODE
   if(oldPrev != NULL){
      oldPrev-&gt; next = newN; 
   }
   L-&gt;cursor-&gt;previous = newN; // SET CURSOR PREVIOUS TO NEW NODE
   newN -&gt; next = L-&gt;cursor; //SET NEW NODE's NEXT TO CURSOR
   newN -&gt; previous = oldPrev; // SET NEW NODE's PREV TO OLD PREV
   L-&gt;list_length = L-&gt;list_length +1;

   if(L-&gt;cursor == L-&gt;front){ //IF CURSOR IS AT FRONT
      L-&gt;front = newN;
   }

   L-&gt;cursor_index = L-&gt;cursor_index + 1; //CURSOR MOVES DOWN 1
   
} // Insert new element before cursor.
 // Pre: length()&gt;0, index()&gt;=0

void insertAfter(List L, int x){
   if(L == NULL){
<a name="6"></a><font color="#00FF00"><a href="match108-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

      printf("List Error: calling insertAfter() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &lt;= 0){
      printf("List Error: calling insertAfter() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if(index(L) &lt; 0){
      printf("List Error: calling insertAfter() on undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   
   Node newN = newNode();
   newN -&gt; data = x;
</font>   
   if(L-&gt;cursor_index == length(L) -1){ //IF CURSOR IS AT BACK
      L-&gt;back = newN;
   }
   
   Node oldNext = L-&gt;cursor-&gt;next; //SAVE PREVIOUS NODE
   if(oldNext != NULL){
      oldNext-&gt;previous = newN;
   }
   L-&gt;cursor-&gt;next = newN; // SET CURSOR PREVIOUS TO NEW NODE
   newN -&gt; next = oldNext; //SET NEW NODE's NEXT TO CURSOR
   newN -&gt; previous = L-&gt;cursor; // SET NEW NODE's PREV TO OLD PREV
   L-&gt;list_length = L-&gt;list_length +1;

} // Insert new element after cursor.
 // Pre: length()&gt;0, index()&gt;=0

void deleteFront(List L){
   if(L == NULL){
      printf("List Error: calling deleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &lt;= 0){
      printf("List Error: calling deleteFront() on empty List reference\n");
      exit(EXIT_FAILURE);
   }

<a name="4"></a><font color="#FF00FF"><a href="match108-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

   Node toFree = L-&gt;front;

   if(L-&gt;front-&gt; next != NULL){  // multiple elements
      L-&gt;front-&gt;next-&gt;previous = NULL;
      L-&gt;front = L-&gt;front-&gt;next;
      L-&gt;cursor_index = L-&gt;cursor_index -1;
</font>   }

   if(L-&gt;cursor == toFree){
      L-&gt;cursor = NULL;
      L-&gt;cursor_index = -1;
   }

   L-&gt;list_length = L-&gt;list_length - 1; 

   if(length(L) &lt;= 0){ // if list was only one element
      L-&gt;front = NULL;
      L-&gt;back = NULL;
      L-&gt;cursor = NULL;
<a name="7"></a><font color="#0000FF"><a href="match108-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

      L-&gt;cursor_index = -1;
   }

   freeNode(&amp;(toFree));
} // Delete the front element. Pre: length()&gt;0

void deleteBack(List L){
   if(L == NULL){
      printf("List Error: calling deleteBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &lt;= 0){
      printf("List Error: calling deleteBack() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   Node toFree = L-&gt;back;
</font>
   if(toFree-&gt;previous != NULL){ //MULTIPLE ELEMENTS
      L-&gt;back-&gt;previous-&gt;next = NULL;
      L-&gt;back = toFree-&gt;previous;
   }

    if(L-&gt;cursor == toFree){ //IF CURSOR IS ON DELETED
      L-&gt;cursor = NULL;
      L-&gt;cursor_index = -1;
   }

   L-&gt;list_length = L-&gt;list_length -1;

   if(length(L) &lt;= 0){
      L-&gt;front = NULL;
      L-&gt;back = NULL;
      L-&gt;cursor = NULL;
<a name="2"></a><font color="#0000FF"><a href="match108-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

      L-&gt;cursor_index = -1;
   }

   freeNode(&amp;(toFree));
} // Delete the back element. Pre: length()&gt;0

void delete(List L){
   if(L == NULL){
      printf("List Error: calling delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if(length(L) &lt;= 0){
      printf("List Error: calling delete() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if(index(L) &lt; 0){
      printf("List Error: calling delete() on undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   //printf("location 1\n");
   Node toFree = L-&gt;cursor;
</font>   if(L-&gt;cursor_index == 0){
      L-&gt;front = L-&gt;cursor-&gt;next;
   }
   //printf("location 2\n");
   if(L-&gt;cursor_index == length(L) - 1){
      L-&gt;back = L-&gt;cursor-&gt;previous;
   }
   //printf("location 3\n");

   if(toFree-&gt;next != NULL){
      toFree-&gt;next-&gt;previous = toFree-&gt;previous;
   }
   //printf("location 4\n");
   if(toFree-&gt;previous != NULL){
      toFree-&gt;previous-&gt;next = toFree-&gt;next;
   }
   //printf("location 5\n");
   toFree-&gt;next = NULL;
   toFree-&gt;previous = NULL;
   freeNode(&amp;(toFree));
   L-&gt;cursor_index = -1;
   L-&gt;cursor = NULL;
   L-&gt;list_length = L-&gt;list_length -1;
   //printf("location 6\n");
   
   if(length(L) &lt;= 0){
      L-&gt;front = NULL;
      L-&gt;back = NULL;
   }
   
} // Delete cursor element, making cursor undefined.
 // Pre: length()&gt;0, index()&gt;=0


// Other operations -----------------------------------------------------------
void printList(FILE* out, List L){
   if(L == NULL){
      printf("List Error: calling delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node printN = L -&gt;front;

   while(printN != NULL){
      fprintf(out, "%d", printN-&gt;data);
      printN = printN-&gt;next;
      if(printN != NULL){
         fprintf(out, " ");
      }
   }
} // Prints to the file pointed to by out, a
 // string representation of L consisting
// of a space separated sequence of integers,
// with front on left.

List copyList(List L){
   List copy = newList();
   Node currNode = L-&gt;front;
   for (int i = 0; i &lt; length(L); i++){
      append(copy, currNode-&gt;data);
      currNode = currNode -&gt;next;
   }
   return copy;
} // Returns a new List representing the same integer
 // sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.</pre>
</body>
</html>
