<html>
<head>
<title>/fall24/nkambo/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/anguy354/pa1/List.c<p></p><pre>
/***
* Andy Nguyen
* anguy354
* 2024 Fall CSE101 PA{1} 
* List.c
* List ADT Implementation file 
***/ 

 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

// structs---------------------------------------

// private Node type
typedef struct NodeObj* Node;

// private Node type
typedef struct NodeObj {
	int data;
	struct NodeObj* next;
	struct NodeObj* prev;
}NodeObj;

// private ListObj type 
typedef struct ListObj {
	Node front;
	Node back;
	Node cursor;
	int length;
	int Index;
}ListObj;

// Constructors-Destructors --------------------

// returns reference to new Node Object. Initializes next and data fields
Node newNode(int data) {
	Node N = malloc(sizeof(NodeObj));
	assert(N!=NULL);
	N-&gt;data = data;
	N-&gt;prev = NULL;
	N-&gt;next = NULL;
	return(N);
}

// freenode()
// Frees heap memory pointed to by *pN, sets *pN to NUll
void freeNode(Node* pN){
	if(pN!=NULL &amp;&amp; *pN!=NULL) {
		free(*pN);
		*pN = NULL;
	}
}

// newList()
// Returns reference to new empty List Object
List newList(void) {
	List L = malloc(sizeof(ListObj));
	L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
	L-&gt;length = 0;
	L-&gt;Index = -1;
	return(L);
}
// frees all the heap memory associated with *pL, and sets *pL to NULL
void freeList(List* pL) {
	if(pL!=NULL &amp;&amp; pL!=NULL) {
<a name="3"></a><font color="#00FFFF"><a href="match239-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

        while(!isEmpty(*pL)){
            deleteFront(*pL);

        }
        free(*pL);
        *pL = NULL;
    }
		
}

// Access functions------------------------------
// returns the length of L.
int length(List L) {
	if(L == NULL){
		printf(" List error: calling length() on NULL list reference\n");
		exit(1);
</font>	}
	return(L-&gt;length);

}

// returns the cursor index 
int index(List L) {
	if(L == NULL) {
		printf("List error: calling index() on NULL List reference\n");
		exit(1);
	}
	else{
		return(L-&gt;Index);
	}
}
// return front element 
int front(List L) {
	if(L == NULL) {
		printf("List error: calling front() on NULL List reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling front() on empty List\n");
		exit(1);
	}
	return(L-&gt;front-&gt;data);
}

int back(List L) {
	if(L == NULL) {
		printf("List error: calling back() on NULL List reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling back() on a empty List\n");
		exit(1);
	}
	return L-&gt;back-&gt;data;
}

bool isEmpty(List L) {
	if(L == NULL) {
		printf("List error: calling isEmpty() on NULL List reference\n");
		exit(1);
	}
	return(L-&gt;length==0);
	
}


int get(List L) {
	if(L == NULL) {
		printf("List error: calling get() on NULL list reference\n");
		exit(1);
	}
	if( isEmpty(L)) {
		printf("List error: calling get() on empty List\n");
		exit(1);
	}
	if(index(L) &lt; 0) {
		printf("List error: calling get() on a index less than 0\n");
		exit(1);
	}
	return(L-&gt;cursor-&gt;data);
}

bool equals(List A, List B) {
	if(A == NULL || B == NULL) {
		printf("List error: calling equals() on NULL list reference\n");
		exit(1);
	}
	bool eq;
	Node N,M;

	eq = (A-&gt;length == B-&gt;length);
	N = A-&gt;front;
	M = B-&gt;front;
	while(eq &amp;&amp; N != NULL) {
		eq = (N-&gt;data == M-&gt;data);
		N = N-&gt;next;
		M = M-&gt;next;
	}
	return eq;
		
}


void clear(List L) {
	if(L == NULL) {
		printf("List errors: calling clear() on NULL List reference");
		exit(1);
	}	
	while(!isEmpty(L)) {
		deleteFront(L);

	}
	L-&gt;front = NULL;
	L-&gt;back = NULL;
	L-&gt;cursor = NULL;
	L-&gt;length = 0;
	L-&gt;Index = -1;
} 

void set(List L, int x) {
	if(L == NULL) {
		printf("List errors: calling set() on NULL list reference");
		exit(1);
	}
	if(isEmpty(L)) { 
		printf("List error: calling set() on empty List reference");
		exit(1);
	}
	if(index(L) &lt; 0) {
		printf("List error: calling set() on index less than 0");
		exit(1);
	}
	L-&gt;cursor-&gt;data = x;
}

void moveFront(List L) {
	if (L == NULL) { 
		printf("List Error: calling moveFront() on NULL List reference\n");
		exit(1);
	}
	if(!isEmpty(L)) {
		L-&gt;cursor = L-&gt;front;
		L-&gt;Index = 0;
		
	}
} 

void moveBack(List L) {
	if (L == NULL) {
		printf("List Error: calling moveBack() on NULL List reference\n");
		exit(1);
	}
<a name="2"></a><font color="#0000FF"><a href="match239-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

	 if(!isEmpty(L)) {
		L-&gt;cursor = L-&gt;back;
		L-&gt;Index = length(L) - 1;
	}

}

void movePrev(List L) {
	if (L == NULL) {
		printf("List Error: calling movePrev() on NULL List reference\n");
</font>		exit(1);
	}

    if(index(L) &gt; 0){
        L-&gt;cursor = L-&gt;cursor-&gt;prev;
        L-&gt;Index -= 1;
    }
    else if (index(L) == 0){
        L-&gt;cursor = NULL;
        L-&gt;Index = -1;
    }
}


void moveNext(List L) {
	if (L == NULL) {
		printf("List Error: calling moveNext() on NULL List reference\n");
		exit(1);
	}
	if(index(L) &gt;= 0 &amp;&amp; index(L) &lt; (length(L) -1)) {
        L-&gt;cursor = L-&gt;cursor-&gt;next;
		L-&gt;Index++;

	}
<a name="4"></a><font color="#FF00FF"><a href="match239-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

	else if (index(L) == (length(L) - 1)){
        L-&gt;cursor = NULL;
		L-&gt;Index = -1;
	}
}

void prepend( List L, int x) {
	if (L == NULL) {
		printf("List error: calling prepend() on NULL list reference\n");
</font>		exit(1);
	}
	if (isEmpty(L)) {
		Node new = newNode(x);
		L-&gt;front = L-&gt;back = new;
	}
	else { 
		Node old = L-&gt;front;
 		Node N = newNode(x);
        N-&gt;next = old;
        L-&gt;front = N;
        old-&gt;prev = N;
		if( index(L) &gt;= 0){
			L-&gt;Index++;
		}
	}
	L-&gt;length++;
}

void append( List L , int x) {
	if(L == NULL) { 
		printf("List error: calling append() on NULL list reference\n");
		exit(1);
	}
<a name="0"></a><font color="#FF0000"><a href="match239-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

	if(isEmpty(L)) {
		L-&gt;front = L-&gt;back = newNode(x);
	}
	else {
        Node old = L-&gt;back;
		Node N = newNode(x);
		L-&gt;back = N;
		old-&gt;next = N;
		N-&gt;prev = old;
			
	}
	L-&gt;length++;			
</font>}
void insertBefore(List L, int x) {
	//Node new = newNode(x);
	if(L == NULL) { 
		printf("List error: calling insertBefore() on NULL list reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling insertBefore() on empty list reference\n");
		exit(1);
	}
	if(index(L) &lt; 0) {
		printf("List error: calling insertBefore() on index less than 0\n");
		exit(1);
	}
	if(L-&gt;cursor-&gt;prev == NULL) {
		prepend(L, x);
	}
	else {
		Node new = newNode(x);
		new-&gt;prev = L-&gt;cursor-&gt;prev;
		L-&gt;cursor-&gt;prev-&gt;next = new;
		new-&gt;next = L-&gt;cursor;
		L-&gt;cursor-&gt;prev = new;
		L-&gt;Index++;
		L-&gt;length++;			
	}
}		
void insertAfter(List L, int x) {
	
	if(L==NULL) {
		printf("List error: calling insertAfter() on NULL list reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling insertAfter() on empty list reference\n");
		exit(1);
	}
	if(index(L) &lt; 0) {
		printf("List error: calling insertAfter() on index less than 0\n");
		exit(1);
	}
	if(L-&gt;cursor-&gt;next == NULL) {
		append(L, x);
	}
	else {

		Node new = newNode(x);
		new-&gt;next = L-&gt;cursor-&gt;next;
		L-&gt;cursor-&gt;next-&gt;prev = new;
		new-&gt;prev = L-&gt;cursor;
		L-&gt;cursor-&gt;next = new;
		L-&gt;length++;
	}			
			
}

void deleteFront(List L) {
	if (L == NULL) {
		printf("List error: calling deleteFront() on NULL list reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling deleteFront() on empty list reference\n");
		exit(1);
	} 
	Node new = L-&gt;front;
	if (length(L) == 1) {
        L-&gt;front = L-&gt;back = NULL;
    } else {
        L-&gt;front = L-&gt;front-&gt;next; // Move the front pointer to the second node
        L-&gt;front-&gt;prev = NULL;     // Set the new front's previous pointer to NULL
    }

    if (L-&gt;cursor == new) { // If the cursor points to the element being deleted
        L-&gt;cursor = NULL;
        L-&gt;Index = -1;
	}
	else if (L-&gt;cursor != NULL) {
		L-&gt;Index--;
	}
    
    // Free the memory allocated to the node
    free(new);
    L-&gt;length--; // Decrease the length of the list by one

}


void deleteBack(List L) {
	if(L==NULL) {
		printf("List error: calling deleteBack() on NULL list reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling deleteBack() on empty list reference\n");
		exit(1);
	}
    Node backNode = L-&gt;back;
    if (L-&gt;length == 1) { // Case where there is only one node in the list
        L-&gt;front = L-&gt;back = NULL;
    } else {
        L-&gt;back = L-&gt;back-&gt;prev;
        L-&gt;back-&gt;next = NULL;
    }

    if (L-&gt;cursor == backNode) { // If the cursor points to the element being deleted
        L-&gt;cursor = NULL;
        L-&gt;Index = -1;
    }

    // Free the memory allocated to the node
    free(backNode);

    L-&gt;length--; // Decrease the length of the list by one
}
			

void delete(List L) {
	if(L == NULL) {
		printf("List error: calling delete() on NULL list reference\n");
		exit(1);
	}
	if(isEmpty(L)) {
		printf("List error: calling delete() on empty list reference\n");
		exit(1);
	}
	if (index(L) &lt; 0) {
		printf("List error: calling delete() on index less than 0\n");
		exit(1);
	}
	Node c = L-&gt;cursor;
    if (c-&gt;prev == NULL &amp;&amp; c-&gt;next != NULL){
        deleteFront(L);
    }		
<a name="1"></a><font color="#00FF00"><a href="match239-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    else if(c-&gt;prev != NULL &amp;&amp; c-&gt;next == NULL){
        deleteBack(L);
    }
    else {
        c-&gt;prev-&gt;next = c-&gt;next;
        c-&gt;next-&gt;prev = c-&gt;prev;
        L-&gt;Index = -1;
        L-&gt;length--;
</font><a name="5"></a><font color="#FF0000"><a href="match239-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        freeNode(&amp;c);
    }
    L-&gt;cursor = NULL;
}








void printList(FILE* out, List L) {
	Node new = NULL;
	if (L == NULL) {
		printf("List error: calling printList() on NULL list reference\n");
</font>		exit(1);
	}
	for(new = L-&gt;front; new != NULL; new = new-&gt;next) {
		fprintf(out,"%d ",new-&gt;data);
	}	
	
}

List copyList(List L) {
	List same = newList();
	Node N = NULL;
	if(L==NULL) {
		printf("List error: calling copyList() on NULL reference\n");
		exit(1);
	}
	for (N = L-&gt;front;N != NULL; N = N-&gt;next) {
		append(same, N-&gt;data);
	}
    freeNode(&amp;N);
    N = NULL;
    return same;
	
}
					
</pre>
</body>
</html>
