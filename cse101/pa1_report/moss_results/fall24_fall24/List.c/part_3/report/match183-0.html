<html>
<head>
<title>/fall24/jchoi142/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/jchoi142/pa1/List.c<p></p><pre>
/***
* Johnathan Choi
* jchoi142
* 2024 Fall CSE101 PA1
* List.c
* .c file for List, defines lists,functions and constructors
***/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"




typedef struct NodeObj{
    ListElement data;
    Node next;
    Node prev;
}NodeObj;

typedef struct ListObj{
    Node front;
    Node back;
    Node cursor;
    int length;
    int index;
} ListObj;


List newList(){//constructor
    List newL = (List)malloc(sizeof(ListObj));//allocate mem 
    newL -&gt; front = NULL;
    newL -&gt; back = NULL;
    newL -&gt; cursor = NULL;
    newL -&gt; length = 0;
    newL -&gt; index = -1;
    return newL;
}


void freeList(List *pL){//destructor
    if(pL != NULL &amp;&amp; *pL != NULL){
        Node current = (*pL) -&gt; front;
        Node temp;
        while(current != NULL){//for each node delete
            temp = current;
            current = current -&gt; next;
            free(temp);
        }
        free(*pL);//free the whole thang
        *pL = NULL;
    }
}




// Access functions -----------------------------------------------------------
int length(List L){                 /* Returns the number of elements in L.*/
    if (L == NULL){
        printf("Queue Error: calling getLength() on NULL Queue reference\n");
        exit(EXIT_FAILURE);
    }
    return (L -&gt; length);
}
int index(List L){                  // Returns index of cursor element if defined, -1 otherwise.
<a name="3"></a><font color="#00FFFF"><a href="match183-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    if (L == NULL) return -1;
    return (L -&gt; index);
}
int front(List L){                  // Returns front element of L. Pre: length()&gt;0
    if(L == NULL || L -&gt; length &lt;= 0){
        exit(EXIT_FAILURE);
</font>    }
    return (L -&gt; front -&gt; data);          //not sure if i should return whole node or just the data/////////////////////////////
}
int back(List L){                   // Returns back element of L. Pre: length()&gt;0
    if(L == NULL || L-&gt; length &lt;= 0){
        exit(EXIT_FAILURE);
    }
    return (L -&gt; back -&gt; data);
}
int get(List L){                    // Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
if(L == NULL || L -&gt; length &lt;= 0 || index &lt; 0 ){
    exit(EXIT_FAILURE);
}
    return (L -&gt; cursor -&gt; data);
}
bool equals(List A, List B){        // Returns true iff Lists A and B contain the same sequence of elements, returns false otherwise.
<a name="4"></a><font color="#FF00FF"><a href="match183-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    if(A == NULL &amp;&amp; B == NULL)return true;
    if(A -&gt; length != B-&gt; length)return false;
    Node currA = A -&gt; front;
    Node currB = B -&gt; front;
</font>    while (currA != NULL){
        if(currA-&gt;data != currB-&gt;data)return false;
        currA = currA -&gt; next;
        currB = currB -&gt; next;
    }
    return true;
}




// Manipulation procedures ----------------------------------------------------
void clear(List L){                   // Resets L to its original empty state.
    if(L != NULL &amp;&amp; L != NULL){
        Node current = L -&gt; front;
        Node temp;
        while(current != NULL){//for each node delete
            temp = current;
            current = current -&gt; next;
            free(temp);
        }
        L -&gt;front = NULL;
        L-&gt;back=NULL;
        L-&gt;cursor=NULL;
        L-&gt;length=0;
        L-&gt;index=-1;
    }
}
void set(List L, int x){              // Overwrites the cursor elementâ€™s data with x. /////Pre: length()&gt;0, index()&gt;=0
    if(L -&gt; length &gt; 0 &amp;&amp; index &gt;= 0){
<a name="0"></a><font color="#FF0000"><a href="match183-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_5.gif"/></a>

        L-&gt;cursor -&gt; data = x;
    }
}
void moveFront(List L){               // If L is non-empty, sets cursor under the front element, otherwise does nothing.
    if(L != NULL &amp;&amp; L -&gt; length &gt; 0){
        L -&gt; cursor = L -&gt; front;
        L -&gt; index = 0;              ///can i just decriment and or increment the index or this?
    }
}
void moveBack(List L){               // If L is non-empty, sets cursor under the back element, otherwise does nothing.
    if(L != NULL &amp;&amp; L -&gt; length &gt; 0){
        L -&gt; cursor = L -&gt; back;
        L -&gt; index = L -&gt; length - 1;
    }
}
void movePrev(List L){               // If cursor is defined and not at front, move cursor one step toward the front of L; if cursor is defined and at front, cursor becomes undefined; if cursor is undefined do nothing
    if(L != NULL){
</font>        if(L -&gt; cursor != L -&gt; front){            //not at front
            L -&gt; cursor= L -&gt; cursor-&gt;prev;
            L -&gt; index--;
        }else{
            L -&gt; cursor = NULL;
            L -&gt; index--;                     
        }
    }
}
void moveNext(List L){               // If cursor is defined and not at back, move cursor one step toward the back of L; if cursor is defined and at back, cursor becomes undefined; if cursor is undefined do nothing
    if(L != NULL){
        if(L -&gt; cursor != NULL&amp;&amp; L-&gt;back == L-&gt;cursor){            
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
            return;
        }
        if (index(L) == -1) {
            return;
        }
        if (L-&gt;cursor != NULL) {
            L-&gt;cursor = L-&gt;cursor-&gt;next;
            L-&gt;index++;
        }
    }
}

void prepend(List L, int x){         // Insert new element into L. If L is non-empty, insertion takes place before front element.
    //if ( L== NULL){
    //    exit(EXIT_FAILURE);
    //}
    Node newNode =(Node)malloc(sizeof(NodeObj));
    newNode -&gt; data = x;
    newNode -&gt; next = NULL;
    newNode -&gt; prev = NULL;

    if(L-&gt;length == 0){
        L -&gt; back = newNode;
        L-&gt;front = newNode;
    }
    else{
        L -&gt; front -&gt; prev = newNode;
        newNode-&gt;next = L-&gt;front;
        L -&gt; front = newNode;

    }
    if (index(L)!= -1){
        L-&gt;index++;
    }
    L -&gt; length++;
}
void append(List L, int x){          // Insert new element into L. If L is non-empty, insertion takes place after back element.
    if (L == NULL){
        exit(EXIT_FAILURE);
    }
    Node newNode =(Node)malloc(sizeof(NodeObj));
    newNode -&gt; data = x;
    newNode -&gt; next = NULL;
    newNode -&gt; prev = L -&gt; back;

    if (L -&gt; length == 0){
        L -&gt; front = newNode;
        L -&gt; back = newNode;
    }
    else{
<a name="1"></a><font color="#00FF00"><a href="match183-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        L -&gt; back -&gt; next = newNode;
        L -&gt; back = newNode;
    }
    
    L -&gt; length++;
}
void insertBefore(List L, int x){          // Insert new element before cursor. Pre: length()&gt;0, index()&gt;=0
    if (L == NULL || L -&gt; length &lt; 0 || L -&gt; index &lt; 0){
        exit(EXIT_FAILURE);
</font>    }     
    Node newNode =(Node)malloc(sizeof(NodeObj));
    
    newNode -&gt; data = x;
    newNode -&gt; next = L -&gt; cursor;
    newNode -&gt; prev = L -&gt; cursor-&gt;prev;

    if( L -&gt; cursor -&gt; prev == NULL){      //if at front
        L -&gt; front = newNode;
    }else{
        L -&gt; cursor -&gt; prev -&gt; next = newNode; //else
    }
<a name="2"></a><font color="#0000FF"><a href="match183-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    L -&gt; cursor -&gt; prev = newNode;
    L -&gt; length++;
    L -&gt; index++;
}
void insertAfter(List L, int x){           // Insert new element after cursor. Pre: length()&gt;0, index()&gt;=0
    if (L == NULL || L -&gt; length &lt; 0 || L -&gt; index &lt; 0){
</font>        exit(EXIT_FAILURE);
    }                
    Node newNode =(Node)malloc(sizeof(NodeObj));
    
    newNode -&gt; data = x;
    newNode -&gt; next = L -&gt; cursor -&gt; next;
    newNode -&gt; prev = L -&gt; cursor;

    if(L -&gt; cursor -&gt; next == NULL){
        L -&gt; back = newNode;
    }else{
        L -&gt; cursor -&gt; next -&gt; prev = newNode;
    }
    L -&gt; cursor -&gt; next = newNode;
    L -&gt; length++;
    L -&gt; index++;
}
void deleteFront(List L){                  // Delete the front element. Pre: length()&gt;0
    if (L == NULL || L -&gt; length &lt; 0){
        exit(EXIT_FAILURE);
    }

    if( L -&gt; length == 1){
        L -&gt; back = NULL;
        L -&gt; front = NULL;
        L -&gt; cursor = NULL;
    }else{
        L -&gt; front -&gt; next -&gt; prev = NULL;
        free(L -&gt; front);                    //am i using this correctly?//////////////////////////////
    }
    L -&gt; length--;
    L -&gt; index--;
    if(L -&gt; cursor == L -&gt; front){
        L -&gt; cursor = NULL;
    }
        


}
void deleteBack(List L){                   // Delete the back element. Pre: length()&gt;0
    if (L == NULL || L -&gt; length &lt; 0){
        exit(EXIT_FAILURE);
    }
    if( L -&gt; length == 1){
        L -&gt; back = NULL;
        L -&gt; front = NULL;
        L -&gt; cursor = NULL;
    }else{
        L -&gt; back -&gt; prev -&gt; next = NULL;
        free(L-&gt;back);
    }
    L -&gt; length--;
    L -&gt; index--;
    if(L -&gt; cursor == L -&gt; back){
        L -&gt; cursor = NULL;
    }

}
void delete(List L){                       // Delete cursor element, making cursor undefined. Pre: length()&gt;0, index()&gt;=0
    if (L == NULL || L -&gt; length &lt;= 0||L -&gt; index &lt; 0){
        exit(EXIT_FAILURE);
    }
    if(L -&gt; cursor == NULL){
        exit(EXIT_FAILURE);
    }

    Node temp= L-&gt;cursor;
    if( L -&gt; cursor == L -&gt; front){
        L-&gt;front = L-&gt;cursor-&gt;next;
        if(L-&gt;front != NULL){
            L-&gt;front-&gt;prev=NULL;
        }                          //potential error do i need temp var to hold then delete that?
    }
    else if (L -&gt; cursor == L -&gt; back){
        L-&gt;back = L-&gt;cursor-&gt;prev;
        if(L-&gt;back!=NULL){
            L-&gt;back-&gt;next = NULL;
        }
    }else{
        L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
<a name="5"></a><font color="#FF0000"><a href="match183-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

        L-&gt;cursor-&gt;next-&gt;prev=L-&gt;cursor-&gt;prev;
    }
    free(temp);
    L -&gt; length--;
    L -&gt; index=-1;                                //set to -1 or --?////////////////////////////////
    L -&gt; cursor = NULL;

}


void printList(FILE* out, List L){             // Prints to the file pointed to by out, a string representation of L consisting
</font>    Node N = NULL;
    for (N = L-&gt;front; N != NULL; N = N-&gt;next) {
        fprintf(out, "%d ", N-&gt;data);
    }
    fprintf(out, "\n");
}                                               
 
List copyList(List L){
    if (L == NULL){
      exit(EXIT_FAILURE);
    }
    List newL = newList();
    Node current = L-&gt;front;
    while ( current != NULL){
        append(newL, current-&gt;data);
        current= current-&gt;next;
    }
    newL-&gt;cursor=NULL;
    newL-&gt;index=-1;
    return newL;
}                         </pre>
</body>
</html>
