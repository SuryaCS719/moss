<html>
<head>
<title>/fall24/pbuddhi/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/pbuddhi/pa1/List.c<p></p><pre>
//Preetham Buddhi
//pbuddhi
//pa1

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include "List.h"

typedef struct NodeObj* Node;

typedef struct NodeObj{
  ListElement data;
  Node next;
  Node prev;
} NodeObj;


typedef struct ListObj{
  Node front;
  Node back;
  Node cursor;
  int cursorIndex;
  int length;
} ListObj;

List newList(){
  List L;
  L = malloc(sizeof(ListObj));
  assert( L!=NULL );
  L-&gt;front = NULL;
  L-&gt;back = NULL;
  L-&gt;length = 0;
  L-&gt;cursor = NULL;
  L-&gt;cursorIndex = -1;
  return L;
}

Node newNode(ListElement data){
  Node N = malloc(sizeof(NodeObj));
  assert( N != NULL);
  N-&gt;data = data;
  N-&gt;next = NULL;
  N-&gt;prev = NULL;
  return N;
}

void freeNode(Node *pN){
  if( pN!=NULL &amp;&amp; *pN!=NULL){
    free(*pN);
    *pN = NULL;
  }
}

void freeList(List *pL){
  if(pL != NULL &amp;&amp; *pL != NULL){
    while(length(*pL) &gt; 0){
      deleteFront(*pL);
    }
    free(*pL);
    *pL = NULL;
  }
}

int length(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling length() on a NULL List reference\n");
    exit(EXIT_FAILURE); 
  }
<a name="4"></a><font color="#FF00FF"><a href="match185-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

  return L-&gt;length;
}

//returns index 
int index(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling length() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursor == NULL){
    return -1;
</font>  } else {
    return L-&gt;cursorIndex;
  }
}

int front(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling front() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling front() on an empty List\n");
    exit(EXIT_FAILURE);
  }
  return L-&gt;front-&gt;data;
}

int back(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling back() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling back() on an empty List\n");
    exit(EXIT_FAILURE);
  }
  return L-&gt;back-&gt;data;
}

int get(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling get() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
<a name="0"></a><font color="#FF0000"><a href="match185-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling get() on an empty List\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursorIndex &lt; 0){
    fprintf(stderr,"List Error: calling get() on an undefined cursor\n");
    exit(EXIT_FAILURE);
  }

  return L-&gt;cursor-&gt;data;
}

bool equals(List A, List B){
  if ( A == NULL || B == NULL){
    fprintf(stderr,"List Error: calling equals() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  bool eq;
  Node N, M;
</font>
  eq = ( A-&gt;length == B-&gt;length);
  N = A-&gt;front;
  M = B-&gt;front;
  while( eq &amp;&amp; N!=NULL){
    eq = (N-&gt;data == M-&gt;data);
    N = N-&gt;next;
    M = M-&gt;next;
  }
  return eq;
}

void clear(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling clear() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  while(L-&gt;length != 0){
    deleteFront(L);
  }

  L-&gt;cursor = NULL;
  L-&gt;cursorIndex = -1;
}

<a name="1"></a><font color="#00FF00"><a href="match185-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

void set(List L, int x){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling set() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling set() on an empty List\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursorIndex &lt; 0){
    fprintf(stderr,"List Error: calling set() on an undefined cursor\n");
    exit(EXIT_FAILURE);
  }
  L-&gt;cursor-&gt;data = x;
}

void moveFront(List L){
</font>  if ( L == NULL){
    fprintf(stderr,"List Error: calling moveFront() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling moveFront() on an empty List\n");
    exit(EXIT_FAILURE);
  }
  L-&gt;cursor = L-&gt;front;
  L-&gt;cursorIndex = 0;
}

void moveBack(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling moveBack() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling moveBack() on an empty List\n");
    exit(EXIT_FAILURE);
  }
  L-&gt;cursor = L-&gt;back;
  L-&gt;cursorIndex = L-&gt;length-1;
}

void movePrev(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling movePrev() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex == 0){
    L-&gt;cursor = NULL;
    L-&gt;cursorIndex = -1;
  }  
  if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex != 0){
    L-&gt;cursor = L-&gt;cursor-&gt;prev;
    L-&gt;cursorIndex = L-&gt;cursorIndex - 1;
  }
}

void moveNext(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling moveNext() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex == (L-&gt;length-1)){
    L-&gt;cursor = NULL;
    L-&gt;cursorIndex = -1;
  }
  if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex != (L-&gt;length-1)){
    L-&gt;cursor = L-&gt;cursor-&gt;next;
    L-&gt;cursorIndex = L-&gt;cursorIndex+1;
  }
}

<a name="2"></a><font color="#0000FF"><a href="match185-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

void prepend(List L, int x){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling prepend() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  Node N = newNode(x);
  N-&gt;prev = NULL;
  if (L-&gt;length &lt;= 0){
</font>    L-&gt;front = L-&gt;back = N;
    N-&gt;next = NULL;
  } else {
    N-&gt;next = L-&gt;front;
    L-&gt;front-&gt;prev = N;
    L-&gt;front = N;
  }
  if(L-&gt;cursor != NULL){
    L-&gt;cursorIndex = L-&gt;cursorIndex+1;
  }
  L-&gt;length++;
}

void append(List L, int x){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling append() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  Node N = newNode(x);
  N-&gt;next = NULL;
  if (L-&gt;length &lt;= 0){
    L-&gt;front = L-&gt;back = N;
    N-&gt;prev = NULL;
  } else {
    N-&gt;prev = L-&gt;back;
    L-&gt;back-&gt;next = N;
    L-&gt;back = N;
  }
  L-&gt;length++;
}

void insertBefore(List L, int x){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling insertBefore() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursorIndex &lt; 0){
    fprintf(stderr,"List Error: calling insertBefore() on a undefined cursor reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;=0){
    fprintf(stderr,"List Error: calling insertBefore() on a empty List\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursorIndex == 0){
    prepend(L, x);
  } else {
    Node N = newNode(x);
    Node temp = L-&gt;cursor-&gt;prev;
    N-&gt;next = L-&gt;cursor;
    N-&gt;prev = temp;
    temp-&gt;next = N;
    L-&gt;cursor-&gt;prev = N;
    L-&gt;cursorIndex = L-&gt;cursorIndex+1;
    L-&gt;length = L-&gt;length+1;
  }
}

void insertAfter(List L, int x){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling insertAfter() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
<a name="3"></a><font color="#00FFFF"><a href="match185-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

  if (L-&gt;cursorIndex &lt; 0){
    fprintf(stderr,"List Error: calling insertAfter() on a undefined cursor reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;=0){
    fprintf(stderr,"List Error: calling insertAfter() on a empty List\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursorIndex == (L-&gt;length - 1)){
</font>    append(L, x);
  } else {
    Node N = newNode(x);
    Node temp = L-&gt;cursor-&gt;next;
    N-&gt;next = temp;
    N-&gt;prev = L-&gt;cursor;
    temp-&gt;prev = N;
    L-&gt;cursor-&gt;next = N;
    L-&gt;length = L-&gt;length + 1;
  }
}

void deleteFront(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling deleteFront() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling deleteFront() on a empty List\n");
    exit(EXIT_FAILURE);
  }
  Node temp = L-&gt;front-&gt;next;
  Node N = L-&gt;front;
  if (L-&gt;length&gt;1){
    temp-&gt;prev = NULL;
    L-&gt;front = temp;
  } else {
    L-&gt;front = NULL;
    L-&gt;back = NULL;
  }
  if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex != 0){
    L-&gt;cursorIndex--;  
  } else if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex == 0){
    L-&gt;cursorIndex = -1;
    L-&gt;cursor = NULL;
  }
  L-&gt;length = L-&gt;length-1;
  freeNode(&amp;N);
}

void deleteBack(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling deleteBack() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;= 0){
    fprintf(stderr,"List Error: calling deleteBack() on a empty List\n");
    exit(EXIT_FAILURE);
  }
  Node temp = L-&gt;back-&gt;prev;
  Node N = L-&gt;back;
  if (L-&gt;length &gt; 1){
    temp-&gt;next = NULL;
    L-&gt;back = temp;  
  } else {
    L-&gt;front = NULL;
    L-&gt;back = NULL;
  }
  if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursorIndex == (L-&gt;length - 1)){
    L-&gt;cursorIndex = -1;
    L-&gt;cursor = NULL;
  }
  L-&gt;length = L-&gt;length-1;
  freeNode(&amp;N);
}

void delete(List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling delete() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if (L-&gt;cursorIndex &lt; 0){
    fprintf(stderr,"List Error: calling delete() on a undefined cursor reference\n");
<a name="5"></a><font color="#FF0000"><a href="match185-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    exit(EXIT_FAILURE);
  }
  if (L-&gt;length &lt;=0){
    fprintf(stderr,"List Error: calling delete() on a empty List\n");
    exit(EXIT_FAILURE);
  }
  Node N = L-&gt;cursor;
  if (L-&gt;cursorIndex == 0){
</font>    deleteFront(L);
  } else if (L-&gt;cursorIndex == (L-&gt;length-1)){
    deleteBack(L);
  } else {
    N-&gt;prev-&gt;next = N-&gt;next;
    N-&gt;next-&gt;prev = N-&gt;prev;
    L-&gt;length = L-&gt;length - 1;
    freeNode(&amp;N);
  }
  L-&gt;cursor = NULL;
  L-&gt;cursorIndex = -1;
}

void printList(FILE* out, List L){
  if ( L == NULL){
    fprintf(stderr,"List Error: calling printList() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  if ( out == NULL){
    fprintf(stderr,"List Error: calling printList() on a NULL file reference\n");
    exit(EXIT_FAILURE);
  }

  Node N = L-&gt;front;
  while (N != NULL){
    fprintf(out, "%d ", N-&gt;data);
    N = N-&gt;next;
  }
}

List copyList(List L){
  if ( L == NULL){
    fprintf(stderr, "List Error: calling copyList() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  List nL = newList();
  Node N = L-&gt;front;
  while (N != NULL){
    append(nL, N-&gt;data);
    N = N-&gt;next;
  }
  return nL;
}

List concatList(List A, List B){
  if ( A == NULL || B == NULL){
    fprintf(stderr, "List Error: calling concatList() on a NULL List reference\n");
    exit(EXIT_FAILURE);
  }
  List nL = copyList(A);
  
  Node N = B-&gt;front;
   while(N != NULL){
    append(nL, N-&gt;data);
    N = N-&gt;next;
  }
  return nL;
}

</pre>
</body>
</html>
