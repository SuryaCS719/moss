<html>
<head>
<title>/fall24/saqadiri/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/saqadiri/pa1/List.c<p></p><pre>
//-----------------------------------------------------------------------------
// Name: Salma Qadiri
// CruzID: Saqadiri
// Assignment: pa2
// List.c
// Implementation file for List ADT
// Salma Qadiri
// Saqadiri@ucsc.edu
//pa1
//-----------------------------------------------------------------------------
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include "List.h"


// structs --------------------------------------------------------------------

// private Node type
typedef struct NodeObj* Node;

// private NodeObj type
typedef struct NodeObj{
   ListElement data;
   Node next;
   Node prev;
} NodeObj;

// private ListObj type
typedef struct ListObj{
   Node cursor; // points to cursor node
   Node front;  // points to front node
   Node back;   // points to back node
   int index;   // index of the cursor
   int length;  // # of elements 
} ListObj;


// Constructors-Destructors ---------------------------------------------------

// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(ListElement data){
   Node N = malloc(sizeof(NodeObj));
   assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;prev = NULL;
   return(N);
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      free(*pN);
      *pN = NULL;
   }
}

// newList()
// Returns reference to new empty List object.
List newList(){
   List L;
   L = malloc(sizeof(ListObj));
   assert( L!=NULL );
   L-&gt;front = NULL;
   L-&gt;back = NULL;
   L-&gt;cursor = NULL;
   L-&gt;index = -1;      //undefined
   L-&gt;length = 0;
   return(L);
}

// freeList()
// Frees all heap memory associated with List *pL, and sets *pL to NULL.
void freeList(List* pL){
   if(pL!=NULL &amp;&amp; *pL!=NULL) { 
      while( length(*pL) &gt; 0 ) { 
         deleteFront(*pL); 
      }
      free(*pL);
      *pL = NULL;
   }
}


// Access functions -----------------------------------------------------------

// front(List L);
// Returns the value at the front of Q.
// Pre: length()&gt;0
int front(List L){
   if( L==NULL ){ 
      printf("List Error: calling front() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( L-&gt;length == 0 ){
      printf("List Error: calling front() on empty List\n");
      exit(EXIT_FAILURE);
   }
   int front_Data = L-&gt;front-&gt;data;
   return front_Data;

}

//int back(List L); 
// Returns back element of L. 
//Pre: length()&gt;0
int back(List L){
   if (L == NULL) { 
      printf("List Error: calling back() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0) {
      printf("List Error: calling back() on empty List\n");
      exit(EXIT_FAILURE);
   }
   int back_Data = L-&gt;back-&gt;data;
   return back_Data;
}



// int length(List L); 
// Returns the number of elements in L.
int length(List L){
   if( L==NULL ){ 
      printf("List Error: calling length() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return(L-&gt;length);
}

// index(List L); 
// Returns index of cursor element if defined, -1 otherwise.
int index(List L){
<a name="2"></a><font color="#0000FF"><a href="match184-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

   if (L == NULL){ 
      printf("List Error: calling index() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return (L-&gt;index);
}

//int get(List L); 
// Returns cursor element of L. 
//Pre: length()&gt;0, index()&gt;=0
int get(List L){
   if (L==NULL){ 
      printf("List Error: calling get() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0){
      printf("List Error: calling get() on empty List\n");
      exit(EXIT_FAILURE);
</font>   }
   if (L-&gt;index&lt;0){
      printf("List Error: calling get() on undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   int cursor_Data = L-&gt;cursor-&gt;data;
   return cursor_Data;
}

//bool equals(List A, List B); 
// Returns true iff Lists A and B contain the same sequence of elements
//returns false otherwise.
bool equals(List A, List B){
   if (A==NULL){ 
      printf("List Error: calling equals() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (B ==NULL){ 
      printf("List Error: calling equals() on NULL List reference\n");
      exit(EXIT_FAILURE);
   
   }
   if (B-&gt;length != A-&gt;length){ //checks if the lengths are different
      return false;
   }
   //setting pointers to the fronts
   Node currA = A-&gt;front;
   Node currB = B-&gt;front;

   while(currB !=NULL &amp;&amp; currA !=NULL){ //traversing through the lists until null is reached
      if(currB-&gt;data != currA-&gt;data){ //checking if data is the same at each node
         return false;
      }
      
      //moving the pointers up
<a name="1"></a><font color="#00FF00"><a href="match184-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

      currA = currA-&gt;next; 
      currB = currB-&gt;next;
   }
   return true; //is equal!
}

// Manipulation procedures ----------------------------------------------------

//clear(List L); 
// Resets L to its original empty state.
void clear(List L){
   if (L == NULL) { 
      printf("List Error: calling clear() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   while (length(L) &gt; 0) { //iterating through until its 0
      deleteFront(L);
   }
   //back to og state
   L-&gt;index = -1; 
</font>   L-&gt;cursor = NULL; 
}

//set(List L, int x); 
// Overwrites the cursor elementâ€™s data with x. 
//Pre: length()&gt;0, index()&gt;=0
void set(List L, int x){
   if (L == NULL) { 
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0) {
      printf("List Error: calling set() with undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0) {
      printf("List Error: calling set() on empty List\n");
      exit(EXIT_FAILURE);
   }
   L-&gt;cursor-&gt;data = x; //overwriting w/ x
}

// moveFront(List L); 
// If L is non-empty, sets cursor under the front element, otherwise does nothing.
void moveFront(List L){
   if (L == NULL) {
      printf("List Error: calling moveFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &gt; 0) { //setting cursor to front element
      L-&gt;index = 0;
      L-&gt;cursor = L-&gt;front;
   }
}

// moveBack(List L); 
// If L is non-empty, sets cursor under the back element, otherwise does nothing.
void moveBack(List L){
   if (L == NULL) { 
      printf("List Error: calling moveBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &gt; 0) { //setting cursor to back element
      L-&gt;cursor = L-&gt;back;
      L-&gt;index = L -&gt;length - 1;  
   }
}

// movePrev(List L); 
// If cursor is defined and not at front, move cursor one step toward the front of L; 
// if cursor is defined and at front, cursor becomes undefined; 
//if cursor is undefined do nothing
void movePrev(List L){
   if(L == NULL) { 
      printf("List Error: calling movePrev() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor == NULL) { 
      return; // do nothing if undefined
   }
   if(L-&gt;cursor == L-&gt;front) { //cursor becomes undefined
      L-&gt;index = -1;
      L-&gt;cursor = NULL; 
   }
   else{ //cursor moves forward by 1
     L-&gt;index--;
     L-&gt;cursor = L-&gt;cursor-&gt;prev;
   } 
}

// moveNext(List L); 
// If cursor is defined and not at back, move cursor one step toward the back of L;
// if cursor is defined and at back, cursor becomes undefined; 
//if cursor is undefined do nothing
void moveNext(List L){
   if (L == NULL) { 
      printf("List Error: calling moveNext() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor == NULL) { 
      return;
   }
   if (L-&gt;cursor != L-&gt;back) { //if not at back move it back by 1
      L-&gt;index++;
      L-&gt;cursor = L-&gt;cursor-&gt;next;   
   }
   else if (L-&gt;cursor == L-&gt;back) { // cursor becomes undefined since its at back
      L-&gt;index = -1;
      L-&gt;cursor = NULL;  
   }
}

// prepend(List L, int x); 
// Insert new element into L. 
//If L is non-empty,insertion takes place before front element.
void prepend(List L, int x){
   if (L == NULL) { 
      printf("List Error: calling prepend() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   Node new_node = newNode(x); 
   if (L-&gt;length == 0) { //if list is empty
      L-&gt;front = new_node; 
      L-&gt;back = new_node; 
   } 
   else { //new node is now linked to the front
   new_node-&gt;next = L-&gt;front; 
   L-&gt;front-&gt;prev = new_node;
   L-&gt;front = new_node; // front pointer is now the new node 
   } 
   L-&gt;length++; // making the list bigger for the new node
   if (L-&gt;index != -1){
      L-&gt;index++;
   } 
}

// append(List L, int x); 
// Insert new element into L. 
//If L is non-empty, insertion takes place after back element.
void append(List L, int x){
   if (L == NULL) { 
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   Node new_node = newNode(x); //making a new node with the x int
   if (L-&gt;length == 0) { // if list is empty
      L-&gt;front = new_node; 
      L-&gt;back = new_node; 
   } 
   else { //new node is now linked to back 
      new_node-&gt;prev = L-&gt;back; 
      L-&gt;back-&gt;next = new_node;
      L-&gt;back = new_node; //back pointer is the new node
   }
   L-&gt;length++;
}
// insertBefore(List L, int x); 
// Insert new element before cursor. 
//Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x){
   if (L == NULL) { 
      printf("List Error: calling insertBefore() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0 || L-&gt;cursor == NULL) { 
      printf("List Error: calling insertBefore() with undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor == L-&gt;front) { //if cursor is at front
      prepend(L, x); // add it to front
   } 
    else { //if cursor not at front
      Node new_node = newNode(x); 
      new_node-&gt;next = L-&gt;cursor; //make new nodes next pointer to the cursor
      new_node-&gt;prev = L-&gt;cursor-&gt;prev; //make the new nodes previous pointer to the node behind the cursor
      L-&gt;cursor-&gt;prev-&gt;next = new_node; // make the next pointer of the node before the cursor set to point to the new node
      L-&gt;cursor-&gt;prev = new_node; //make the cursor previous  pointer to point to the new node
<a name="3"></a><font color="#00FFFF"><a href="match184-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

      L-&gt;length++; // add length 
      L-&gt;index++; // move the index forward one
   }

}

// insertAfter(List L, int x); 
// Insert new element after cursor. 
//Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x){
   if (L == NULL) { 
      printf("List Error: calling insertAfter() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0 || L-&gt;cursor == NULL) { 
</font>      printf("List Error: calling insertAfter() with undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   
   if (L-&gt;cursor == L-&gt;back) { //if cursor is at back
      append(L, x); // add x to back
   } 
   else {
      Node new_node = newNode(x);
      new_node-&gt;prev = L-&gt;cursor; // sets the new node previous pointer to the cursor
      new_node-&gt;next = L-&gt;cursor-&gt;next; // setting the new node nect pointer to the node after the cursor
      L-&gt;cursor-&gt;next-&gt;prev = new_node; // seting the next nodes previous pointer to the new node
<a name="0"></a><font color="#FF0000"><a href="match184-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

      L-&gt;cursor-&gt;next = new_node; // sets the cursor next pointer to new node
      L-&gt;length++;  
   }
}
// deleteFront(List L); 
// Delete the front element. 
//Pre: length()&gt;0
void deleteFront(List L){
   if (L == NULL) { 
      printf("List Error: calling deleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0) { 
      printf("List Error: calling deleteFront() on empty List\n");
      exit(EXIT_FAILURE);
   }
   Node new_node = L-&gt;front; 
   if (L-&gt;length &gt; 1) { //if the length is greater than 1
      L-&gt;front = L-&gt;front-&gt;next; // moves the pointer to the node after
</font>      L-&gt;front-&gt;prev = NULL; // prev pointer is now null
   } 
   else { //one element in list
      L-&gt;front = NULL; 
      L-&gt;back = NULL; 
   }
   if (L-&gt;cursor == new_node) { // if cursor points to front node
      L-&gt;index = -1; 
      L-&gt;cursor = NULL; 
      
   } 
   else if (L-&gt;index != -1) { // if cursor doesnt point to the first node
      L-&gt;index--; //move the index back to remove the front
   }
   L-&gt;length--; // decrement  length
   freeNode(&amp;new_node); 
}

// deleteBack(List L); 
// Delete the back element. 
//Pre: length()&gt;0
void deleteBack(List L){
   if (L == NULL) { 
      printf("List Error: calling deleteBack() on NULL List reference\n");
<a name="4"></a><font color="#FF00FF"><a href="match184-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0) { 
      printf("List Error: calling deleteBack() on empty List\n");
      exit(EXIT_FAILURE);
   }
   
   Node new_node = L-&gt;back; //temp pointer to back node
   if (L-&gt;length &gt; 1) { 
      L-&gt;back = L-&gt;back-&gt;prev; //moves back pointer to previous mode
</font>      L-&gt;back-&gt;next = NULL; // sests the back node to null
   } 
   else { //if theres one element
      L-&gt;front = NULL; 
      L-&gt;back = NULL; 
   }
   if (L-&gt;cursor == new_node) { //if cursor is pointing to the back node
      L-&gt;index = -1; //set index to undefined
      L-&gt;cursor = NULL; 
      
   }
   L-&gt;length--; //length of list is minused
   freeNode(&amp;new_node); 
}


// delete(List L); 
// Delete cursor element, making cursor undefined. 
//Pre: length()&gt;0, index()&gt;=0
void delete(List L){
   if (L == NULL) { 
      printf("List Error: calling delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0 || L-&gt;cursor == NULL ) { 
      printf("List Error: calling delete() with undefined cursor\n");
      exit(EXIT_FAILURE);
   }
   Node c_node = L-&gt;cursor; 
   if (c_node == L-&gt;front) { //if c node is front
      deleteFront(L); 
   } 
   else if (c_node == L-&gt;back) { //if c node is pointing to back
      deleteBack(L);
   } else {
      c_node-&gt;prev-&gt;next = c_node-&gt;next; //links the previous node to next node
      c_node-&gt;next-&gt;prev = c_node-&gt;prev; // links the next node to previous node
      L-&gt;cursor = NULL; 
      L-&gt;length--; 
      L-&gt;index = -1; // cursor index  is undefined
      
<a name="5"></a><font color="#FF0000"><a href="match184-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

      freeNode(&amp;c_node); 
   }
}

// Other Functions ------------------------------------------------------------

// printList(FILE* out, List L); 
// Prints to the file pointed to by out, a string representation of L
// consisting of a space separated sequence of integers, with front on left.
void printList(FILE* out, List L){
   if (L == NULL) { 
      printf("List Error: calling printList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   Node temp_node = L-&gt;front; //temp node to represent the front pointer
   while (temp_node != NULL) { 
</font>      fprintf(out, FORMAT" ", temp_node-&gt;data); //prints the current nodes data
<a name="6"></a><font color="#00FF00"><a href="match184-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

      temp_node = temp_node-&gt;next; //moving to the next node
   }
   fprintf(out, "\n");
}

// copyList(List L); 
// Returns a new List representing the same integer sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state of L is unchanged.
List copyList(List L){
   if (L == NULL) { 
      printf("List Error: calling copyList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   List new_list = newList(); 
   Node curr_node = L-&gt;front; 
</font>
   while (curr_node != NULL) { 
      append(new_list, curr_node-&gt;data); //appened the element from og list to the new one
      curr_node = curr_node-&gt;next; //moving to the next node
   }
   return new_list;
}
</pre>
</body>
</html>
