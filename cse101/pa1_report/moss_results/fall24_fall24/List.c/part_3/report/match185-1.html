<html>
<head>
<title>/fall24/pbuddhi/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/aprabou/pa1/List.c<p></p><pre>
/***
Ashwin Prabou
aprabou
2024 Fall CSE101
List.c
PA1
List ADT
***/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"
#include &lt;assert.h&gt;

// structs --------------------------------------------------------------------

// private Node type
typedef int ListElement;
typedef struct NodeObj *Node;

// private NodeObj type
typedef struct NodeObj
{
   ListElement data;
   Node next;
   Node prev;
} NodeObj;

// private ListObj type
typedef struct ListObj
{
   Node front;
   Node back;
   Node cursor;
   int index;
   int length;
} ListObj;

// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(ListElement data)
{
   Node N = malloc(sizeof(NodeObj));
   assert(N != NULL);
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;prev = NULL;
   return (N);
}

void freeNode(Node *pn)
{
   if (pn != NULL &amp;&amp; *pn != NULL)
   {
      free(*pn);
      *pn = NULL;
   }
}

// Constructors-Destructors ---------------------------------------------------
// Creates and returns a new empty List.
List newList(void)
{
   List L;
   L = malloc(sizeof(ListObj));
   assert(L != NULL);
   L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
   L-&gt;length = 0;
   L-&gt;index = -1;

   return (L);
}

// Frees all heap memory associated with *pL, and sets *pL to NULL
void freeList(List *pL)
{
   if (pL != NULL &amp;&amp; *pL != NULL)
   {
      while (length(*pL) &gt; 0)
      {
         deleteFront(*pL);
      }
      free(*pL);
      *pL = NULL;
   }
}

// Access functions -----------------------------------------------------------
// Returns the number of elements in L.
int length(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling length() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
<a name="4"></a><font color="#FF00FF"><a href="match185-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

   return (L-&gt;length);
}

// Returns index of cursor element if defined, -1 otherwise.
int index(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling index() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor == NULL)
   {
      return -1;
</font>   }
   return (L-&gt;index);
}

// Returns front element of L. Pre: length()&gt;0
int front(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling front() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling set() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   return L-&gt;front-&gt;data;
}

// Returns back element of L. Pre: length()&gt;0
int back(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling back() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling set() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   return L-&gt;back-&gt;data;
}

// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling get() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
<a name="0"></a><font color="#FF0000"><a href="match185-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling get() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0)
   {
      fprintf(stderr, "List Error: calling get() on undefined cursor reference\n");
      exit(EXIT_FAILURE);
   }
   return L-&gt;cursor-&gt;data;
}

// Returns true iff Lists A and B contain the same
// sequence of elements, returns false otherwise.
bool equals(List A, List B)
{
   if (A == NULL || B == NULL)
   {
      fprintf(stderr, "List Error: calling equals() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   bool eq;
   Node N, M;
</font>
   eq = (A-&gt;length == B-&gt;length);
   N = A-&gt;front;
   M = B-&gt;front;

   while (eq &amp;&amp; N != NULL)
   {
      eq = (N-&gt;data == M-&gt;data);
      N = N-&gt;next;
      M = M-&gt;next;
   }
   return eq;
}

// Resets L to its original empty state.
void clear(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling clear() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   while (L-&gt;front != NULL)
   {
      deleteFront(L);
   }
}

// Overwrites the cursor elementâ€™s data with x.
// Pre: length()&gt;0, index()&gt;=0
<a name="1"></a><font color="#00FF00"><a href="match185-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

void set(List L, int x)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling set() on empty List reference\n");
      exit(EXIT_FAILURE);
   }

   if (L-&gt;index &lt; 0)
   {
      fprintf(stderr, "List Error: calling set() on undefined cursor reference\n");
      exit(EXIT_FAILURE);
   }

   L-&gt;cursor-&gt;data = x;
}

// If L is non-empty, sets cursor under the front element,s
// otherwise does nothing.
void moveFront(List L)
</font>{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling moveFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &gt; 0)
   {
      L-&gt;index = 0;
      L-&gt;cursor = L-&gt;front;
   }
}

// If L is non-empty, sets cursor under the back element,
// otherwise does nothing.
void moveBack(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling moveBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   else
   {
      L-&gt;index = L-&gt;length - 1;
      L-&gt;cursor = L-&gt;back;
   }
}

// If cursor is defined and not at front, move cursor one
// step toward the front of L; if cursor is defined and at
// front, cursor becomes undefined; if cursor is undefined
// do nothing
void movePrev(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling movePrev() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if ((L-&gt;cursor != L-&gt;front))
   {
      L-&gt;cursor = L-&gt;cursor-&gt;prev;
      L-&gt;index--;
   }
   else if ((L-&gt;cursor != NULL) &amp;&amp; (L-&gt;cursor == L-&gt;front))
   {
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }
}

// If cursor is defined and not at back, move cursor one
// step toward the back of L; if cursor is defined and at
// back, cursor becomes undefined; if cursor is undefined
// do nothing
void moveNext(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling moveNext() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor == NULL)
   {
      return;
   }
   if (L-&gt;cursor != L-&gt;back)
   {
      L-&gt;cursor = L-&gt;cursor-&gt;next;
      L-&gt;index++;
   }
   else
   {
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }
}

// Insert new element into L. If L is non-empty,
// insertion takes place before front element.
<a name="2"></a><font color="#0000FF"><a href="match185-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

void prepend(List L, int x)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling prepend() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node n = newNode(x);
   n-&gt;prev = NULL;

   if (L-&gt;length == 0)
</font>   {
      L-&gt;front = n;
      L-&gt;back = n;
   }
   else
   {
      n-&gt;next = L-&gt;front;
      L-&gt;front-&gt;prev = n;
      L-&gt;front = n;
      if (L-&gt;index != -1)
      {
         L-&gt;index++;
      }
   }
   // freeNode(&amp;n);

   L-&gt;length++;
}

// Insert new element into L. If L is non-empty,
// insertion takes place after back element.
void append(List L, int x)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node n = newNode(x);

   if (L-&gt;length == 0)
   {
      L-&gt;front = n;
      L-&gt;back = n;
   }
   else
   {
      n-&gt;prev = L-&gt;back;
      L-&gt;back-&gt;next = n;
      L-&gt;back = n;
   }
   // freeNode(&amp;n);

   L-&gt;length++;
}

// Insert new element before cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling insertBefore() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling insertBefore() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0)
   {
      fprintf(stderr, "List Error: calling insertBefore() on undefined cursor reference\n");
      exit(EXIT_FAILURE);
   }

   Node n = newNode(x);

   if (L-&gt;cursor == L-&gt;front)
   {
      n-&gt;next = L-&gt;front;
      L-&gt;front-&gt;prev = n;
      L-&gt;front = n;
   }
   else
   {
      n-&gt;next = L-&gt;cursor;
      n-&gt;prev = L-&gt;cursor-&gt;prev;
      L-&gt;cursor-&gt;prev-&gt;next = n;
      L-&gt;cursor-&gt;prev = n;
   }
   L-&gt;length++;
   L-&gt;index++;
   // freeNode(&amp;n);
}

// Insert new element after cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling insertAfter() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling insertAfter() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index == -1)
   {
      fprintf(stderr, "List Error: calling insertAfter() on undefined cursor reference\n");
      exit(EXIT_FAILURE);
   }

   Node n = newNode(x);

   if (L-&gt;cursor == L-&gt;back)
   {
      n-&gt;prev = L-&gt;back;
      L-&gt;back-&gt;next = n;
      L-&gt;back = n;
   }
   else
   {
      n-&gt;prev = L-&gt;cursor;
      n-&gt;next = L-&gt;cursor-&gt;next;
      L-&gt;cursor-&gt;next-&gt;prev = n;
      L-&gt;cursor-&gt;next = n;
   }
   L-&gt;length++;
   // freeNode(&amp;n);
}

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling deleteFront() on NULL List reference\n");
<a name="5"></a><font color="#FF0000"><a href="match185-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

      exit(EXIT_FAILURE);
   }
   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling deleteFront() on empty List reference\n");
      exit(EXIT_FAILURE);
   }

   Node temp = L-&gt;front;
   if (L-&gt;length == 1)
</font>   {
      L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }
   else
   {
      L-&gt;front = L-&gt;front-&gt;next;
      L-&gt;front-&gt;prev = NULL;
      if (L-&gt;index == 0)
      {
         L-&gt;cursor = NULL;
         L-&gt;index = -1;
      }
      else
      {
         L-&gt;index--;
      }
   }
   freeNode(&amp;temp);
   L-&gt;length--;
}

// Delete the back element. Pre: length()&gt;0
void deleteBack(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling deleteBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   if (L-&gt;length &gt; 0)
   {
      Node temp = L-&gt;back;
      if (L-&gt;length &gt; 1)
      {
         L-&gt;back = L-&gt;back-&gt;prev;
         L-&gt;back-&gt;next = NULL;
      }
      else
      {
         L-&gt;front = NULL;
         L-&gt;back = NULL;
      }
      if (L-&gt;cursor == temp)
      {
         L-&gt;cursor = NULL;
         L-&gt;index = -1;
      }
      freeNode(&amp;temp);
      L-&gt;length--;
   }
}

// Delete cursor element, making cursor undefined.
// Pre: length()&gt;0, index()&gt;=0
void delete(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
<a name="3"></a><font color="#00FFFF"><a href="match185-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

   if (L-&gt;length &lt;= 0)
   {
      fprintf(stderr, "List Error: calling delete() on empty List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;index &lt; 0)
   {
      fprintf(stderr, "List Error: calling delete() on undefined cursor reference\n");
      exit(EXIT_FAILURE);
   }

   if (L-&gt;cursor == L-&gt;front)
</font>   {
      deleteFront(L);
   }
   else if (L-&gt;cursor == L-&gt;back)
   {
      deleteBack(L);
   }
   else
   {
      Node temp = L-&gt;cursor;
      L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
      L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
      freeNode(&amp;temp);
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
      L-&gt;length--;
   }
}

// Other operations -----------------------------------------------------------
// Prints to the file pointed to by out, a
// string representation of L consisting
// of a space separated sequence of integers,
// with front on left.
void printList(FILE *out, List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling printList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node temp = L-&gt;front;
   while (temp != NULL)
   {
      fprintf(out, "%d ", temp-&gt;data);
      temp = temp-&gt;next;
   }
   // freeNode(&amp;temp);
}

// Returns a new List representing the same integer
// sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.
List copyList(List L)
{
   if (L == NULL)
   {
      fprintf(stderr, "List Error: calling copyList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   List copy = newList();

   Node temp = L-&gt;front;

   while (temp != NULL)
   {
      append(copy, temp-&gt;data);
      temp = temp-&gt;next;
   }
   // freeNode(&amp;temp);

   return copy;
}
</pre>
</body>
</html>
