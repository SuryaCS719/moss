<html>
<head>
<title>/fall24/esbajwa/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/esbajwa/pa1/List.c<p></p><pre>
/****************************************************************************************
*  Name: Eshan Bajwa
*  ID: 2069964
*  Assignment: pa1
*****************************************************************************************
*  List.c
*  List ADT implementation
*****************************************************************************************/
#include "List.h"

#include &lt;stdlib.h&gt;

// PRIVATE Node Stuff ---------------------------------------------------------
<a name="0"></a><font color="#FF0000"><a href="match32-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_89.gif"/></a>

typedef struct NodeObj *Node;

struct NodeObj {
	int val;
	Node prev;
	Node next;
};

Node newNode(int val) {
	Node new = malloc(sizeof(struct NodeObj));
	new-&gt;val = val;
	new-&gt;prev = NULL;
	new-&gt;next = NULL;
	return new;
}

void freeNodes(Node start) {
	while(start != NULL) {
		Node next = start-&gt;next;
		free(start);
		start = next;
	}
}

// UTIL -----------------------------------------------------------------------
void my_assert(bool cond, const char* msg) {
	if (!cond) {
		fprintf(stderr, "ERROR: %s", msg);
		exit(EXIT_FAILURE);
	}
}

// PUBLIC List Stuff ----------------------------------------------------------
struct ListObj {
	Node front;
	Node back;
	Node cursor_node;
	int cursor_idx;
	int len;
};

List newList(void) {
	List new = malloc(sizeof(struct ListObj));
	new-&gt;front = NULL;
	new-&gt;back = NULL;
	new-&gt;cursor_node = NULL;
	new-&gt;cursor_idx = -1;
	new-&gt;len = 0;
	return new;
}

void freeList(List *pL) {
	if (pL != NULL &amp;&amp; *pL != NULL) {
		List L = *pL;
		freeNodes(L-&gt;front);
		free(L);
		*pL = NULL;
	}
}

int length(List L) {
	return L-&gt;len;
}

int index(List L) {
	return L-&gt;cursor_idx;
}

int front(List L) {
	my_assert(L-&gt;len &gt; 0, "calling 'front' on an empty list");
	return L-&gt;front-&gt;val;
}

int back(List L) {
	my_assert(L-&gt;len &gt; 0, "calling 'back' on an empty list");
	return L-&gt;back-&gt;val;
}

int get(List L) {
	my_assert(L-&gt;len &gt; 0, "calling 'get' on an empty list");
	my_assert(L-&gt;cursor_idx &gt;= 0, "calling 'get' on a list with an undefined cursor");
	return L-&gt;cursor_node-&gt;val;
}

bool equals(List A, List B) {
	if (A == NULL &amp;&amp; B == NULL) return true;
	if ((A == NULL) ^ (B == NULL)) return false;

	Node a = A-&gt;front;
	Node b = B-&gt;front;
	while(a != NULL &amp;&amp; b != NULL &amp;&amp; a-&gt;val == b-&gt;val) {
		a = a-&gt;next;
		b = b-&gt;next;
	}
	if (a == NULL &amp;&amp; b == NULL) return true;
	return false;
}

void clear(List L) {
	freeNodes(L-&gt;front);
	L-&gt;front = NULL;
	L-&gt;back = NULL;
	L-&gt;cursor_node = NULL;
	L-&gt;cursor_idx = -1;
	L-&gt;len = 0;
}

void set(List L, int x) {
	my_assert(L-&gt;len &gt; 0, "calling 'set' on an empty list");
	my_assert(L-&gt;cursor_idx &gt;= 0, "calling 'set' on a list with an undefined cursor");
	L-&gt;cursor_node-&gt;val = x;
}

void moveFront(List L) {
	if (L-&gt;len == 0) return;
	L-&gt;cursor_node = L-&gt;front;
	L-&gt;cursor_idx = 0;
}

void moveBack(List L) {
	if (L-&gt;len == 0) return;
	L-&gt;cursor_node = L-&gt;back;
	L-&gt;cursor_idx = L-&gt;len - 1;
}

void movePrev(List L) {
	if (L-&gt;cursor_idx == 0) {
		L-&gt;cursor_node = NULL;
		L-&gt;cursor_idx = -1;
	} else if (L-&gt;cursor_idx &gt; 0) {
		L-&gt;cursor_node = L-&gt;cursor_node-&gt;prev;
		L-&gt;cursor_idx --;
	}
}

void moveNext(List L) {
	if (L-&gt;cursor_idx == L-&gt;len - 1) {
		L-&gt;cursor_node = NULL;
		L-&gt;cursor_idx = -1;
	} else if (L-&gt;cursor_idx &gt;= 0) {
		L-&gt;cursor_node = L-&gt;cursor_node-&gt;next;
		L-&gt;cursor_idx ++;
	}
}

void prepend(List L, int x) {
	Node new = newNode(x);
	new-&gt;next = L-&gt;front;
	if (L-&gt;front != NULL) L-&gt;front-&gt;prev = new;
	L-&gt;front = new;
	if (L-&gt;cursor_idx &gt;= 0) L-&gt;cursor_idx ++;
	if (L-&gt;back == NULL) {
		L-&gt;back = new;
	}
	L-&gt;len ++;
}

void append(List L, int x) {
	Node new = newNode(x);
	new-&gt;prev = L-&gt;back;
	if (L-&gt;back != NULL) L-&gt;back-&gt;next = new;
	L-&gt;back = new;
	if (L-&gt;front == NULL) {
		L-&gt;front = new;
	}
	L-&gt;len ++;
}

void insertBefore(List L, int x) {
	my_assert(L-&gt;len &gt; 0, "calling 'insertBefore' on an empty list");
	my_assert(L-&gt;cursor_idx &gt;= 0, "calling 'insertBefore' on a list with an undefined cursor");

	Node new = newNode(x);
	new-&gt;prev = L-&gt;cursor_node-&gt;prev;
	new-&gt;next = L-&gt;cursor_node;
	if (L-&gt;cursor_idx == 0) L-&gt;front = new;
	if (L-&gt;cursor_node-&gt;prev != NULL) L-&gt;cursor_node-&gt;prev-&gt;next = new;
	L-&gt;cursor_node-&gt;prev = new;
	L-&gt;cursor_idx ++;
	L-&gt;len ++;
}

void insertAfter(List L, int x) {
	my_assert(L-&gt;len &gt; 0, "calling 'insertAfter on an empty list");
	my_assert(L-&gt;cursor_idx &gt;= 0, "calling 'insertAfter' on a list with an undefined cursor");

	Node new = newNode(x);
	new-&gt;prev = L-&gt;cursor_node;
	new-&gt;next = L-&gt;cursor_node-&gt;next;
	if (L-&gt;cursor_node-&gt;next != NULL) L-&gt;cursor_node-&gt;next-&gt;prev = new;
	L-&gt;cursor_node-&gt;next = new;
	if (L-&gt;cursor_idx == L-&gt;len - 1) L-&gt;back = new;
	L-&gt;len ++;
}

void deleteFront(List L) {
	my_assert(L-&gt;len &gt; 0, "calling 'deleteFront' on an empty list");

	Node to_del = L-&gt;front;
	L-&gt;front = to_del-&gt;next;
	if (L-&gt;len == 1) {
		L-&gt;back = to_del-&gt;next; // this should always be NULL
	} else {
		to_del-&gt;next-&gt;prev = NULL; // no dangling pointers!
	}
	if (L-&gt;cursor_idx == 0) { // cursor is the front, undefine it
		L-&gt;cursor_node = NULL;
		L-&gt;cursor_idx = -1;
	}
	if (L-&gt;cursor_idx &gt; 0) L-&gt;cursor_idx --;
	L-&gt;len --;
	free(to_del);
}

void deleteBack(List L) {
	my_assert(L-&gt;len &gt; 0, "calling 'deleteBack on an empty list");

	Node to_del = L-&gt;back;
	L-&gt;back = to_del-&gt;prev;
	if (L-&gt;len == 1) {
		L-&gt;front = to_del-&gt;prev; // this should always be NULL
	} else {
		to_del-&gt;prev-&gt;next = NULL; // no dangling pointers!
	}
	if (L-&gt;cursor_idx == L-&gt;len - 1) { // cursor is at the back, undefine it
		L-&gt;cursor_node = NULL;
		L-&gt;cursor_idx = -1;
	}
	L-&gt;len --;
	free(to_del);
}

void delete(List L) {
	my_assert(L-&gt;len &gt; 0, "calling 'delete' on an empty list");
	my_assert(L-&gt;cursor_idx &gt;= 0, "calling 'delete' on a list with an undefined cursor");

	Node to_del = L-&gt;cursor_node;
	if (L-&gt;cursor_idx == 0) L-&gt;front = to_del-&gt;next;
	if (L-&gt;cursor_idx == L-&gt;len - 1) L-&gt;back = to_del-&gt;prev;
	if (to_del-&gt;prev) to_del-&gt;prev-&gt;next = to_del-&gt;next; // no dangling pointers!
	if (to_del-&gt;next) to_del-&gt;next-&gt;prev = to_del-&gt;prev; // no dangling pointers!
	L-&gt;cursor_node = NULL;
	L-&gt;cursor_idx = -1;
	L-&gt;len --;
	free(to_del);
}

void printList(FILE* out, List L) {
	Node x = L-&gt;front;
	while(x != NULL) {
		fprintf(out, "%d ", x-&gt;val);
</font>		x = x-&gt;next;
	}
	fprintf(out, "\n");
}

List copyList(List L) {
	List new = newList();
	Node from = L-&gt;front;
	while(from != NULL) {
<a name="1"></a><font color="#00FF00"><a href="match32-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

		append(new, from-&gt;val);
		from = from-&gt;next;
	}
	return new;
}

List concatList(List A, List B) {
	List A_copy = copyList(A);
	List B_copy = copyList(B);

	// connect the Nodes, if they exist
	if (A_copy-&gt;len &gt; 0) A_copy-&gt;back-&gt;next = B_copy-&gt;front;
	if (B_copy-&gt;len &gt; 0) B_copy-&gt;front-&gt;prev = A_copy-&gt;back;

	A_copy-&gt;back = B_copy-&gt;back; // set A's back to the concat'd back
	if (A_copy-&gt;len == 0) A_copy-&gt;front = B_copy-&gt;front;
	A_copy-&gt;len += B_copy-&gt;len; // update len

	// Now A_copy is the concat'd list, so we can free B_copy (but not its nodes)
	free(B_copy);
</font>	return A_copy;
}
</pre>
</body>
</html>
