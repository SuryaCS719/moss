<html>
<head>
<title>/fall24/jeczhao/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/jeczhao/pa1/List.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include "List.h"
#include &lt;assert.h&gt;

<a name="0"></a><font color="#FF0000"><a href="match89-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_98.gif"/></a>

typedef struct NodeObj* Node;
struct NodeObj {
    int data;
    Node next;
    Node back;
} NodeObj;
 
typedef struct ListObj{
    Node head;
    Node tail;
    Node cursor;
    int index;
    int length;
} ListObj;

//Constuctor-Deconstructors ------------------
void freeList(List* pL){
    if( pL!=NULL &amp;&amp; *pL!=NULL ){
      //clear() here
      free(*pL);
      *pL = NULL;
   } 
}

List newList(void){
    List *l = malloc(sizeof(List));
    assert( l!=NULL );
    (*l)-&gt;head = NULL;
    (*l)-&gt;tail = NULL;
    (*l)-&gt;cursor = NULL;
    (*l)-&gt;length = 0;
    (*l)-&gt;index = -1;
    return (*l);
}

// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(int data){
   Node N = malloc(sizeof(NodeObj));
   assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;back = NULL;
   return N;
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      (*pN)-&gt;next = NULL; //may not be needed
      free(*pN);
      *pN = NULL;
   }
}

//Access Functions ----------
int length(List L){
    return L-&gt;length;
}

int index(List L){
    if (L-&gt;cursor == NULL) {
        return -1;
    }
    return L-&gt;index;
}

int front (List L){
    if (length(L) &lt;= 0){
        fprintf(stderr, "calling function on empty or null list\n"); 
        exit(1); 
    }
    return L-&gt;head-&gt;data;
}
int back (List L){
    if (length(L) &lt;= 0){
        fprintf(stderr, "calling function on empty or null list\n"); 
        exit(1); 
    }
    return L-&gt;tail-&gt;data;
}
int get (List L){
    if (length(L) &lt;= 0 || index(L) &lt; 0){
        fprintf(stderr, "calling function on empty or null list\n"); 
        exit(1); 
    }
    return L-&gt;cursor-&gt;data;
}

bool equals(List A, List B){
    assert(length(A) != length(B));  
    Node ANode = A-&gt;head;
    Node BNode = B-&gt;head;
    int i;
    for (i = 0; i &lt; length(A); i++){
        if (ANode-&gt;data != BNode-&gt;data){
            return false;
        } else {
             ANode = ANode-&gt;next;
             BNode = BNode-&gt;next;
        }
    }
    return true;
}

//Manipulation Procedures ---------------
void clear(List L){
// Resets L to its original empty state. 
    L-&gt;head = NULL;
    L-&gt;tail = NULL;
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length = 0;
    //spam deleteFront() instead of this while length &gt; 0
}
void set(List L, int x){
// Overwrites the cursor elementâ€™s data with x.  
// Pre: length()&gt;0, index()&gt;=0 
    if(length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0){
        L-&gt;cursor-&gt;data = x;
    }
}
void moveFront(List L){
    if(length(L) != 0){
        L-&gt;cursor = L-&gt;head;
    }
} // If L is non-empty, sets cursor under the front element, // otherwise does nothing. 

void moveBack(List L){
    if(length(L) != 0){
        L-&gt;cursor = L-&gt;tail;
    }
}
void movePrev(List L){
    if(L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;head){
        L-&gt;cursor = L-&gt;tail;
    }
}  

void moveNext(List L){
    if(L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;tail){
        L-&gt;cursor = L-&gt;head;
    }
}

void prepend(List L, int x){
    Node inNode = newNode(x);
    if(length(L) == 0){
        L-&gt;tail = inNode;
        L-&gt;head = inNode;
        L-&gt;length += 1;
    }
    inNode-&gt;next = L-&gt;head;
    L-&gt;head-&gt;back = inNode;
    L-&gt;head = inNode;
    L-&gt;length = 1;
} // Insert new element into L.  If L is non-empty,  
// insertion takes place before front element. 
void append(List L, int x){
    Node inNode = newNode(x);
    if(length(L) == 0){
        L-&gt;tail = inNode;
        L-&gt;head = inNode;
        L-&gt;length += 1;
    }
    inNode-&gt;back = L-&gt;tail;
    L-&gt;tail-&gt;next = inNode;
    L-&gt;tail = inNode;
    L-&gt;length += 1;
}

 // Insert new element into L.  If L is non-empty,  
// insertion takes place after back element. 
void insertBefore(List L, int x){
    if(length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0){
        if(index(L) == 0){
            prepend(L, x);
            return;
        }
        Node inNode = newNode(x);
        L-&gt;cursor-&gt;back-&gt;next = inNode;
        inNode-&gt;back = L-&gt;cursor-&gt;back;
        inNode-&gt;next = L-&gt;cursor;
        L-&gt;cursor-&gt;back = inNode;
    }
}  
// Insert new element before cursor.  
// Pre: length()&gt;0, index()&gt;=0 
void insertAfter(List L, int x){
    if(length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0){
        if(index(L) == length(L)-1){
            append(L, x);
            return;
        }
        Node inNode = newNode(x);
        inNode-&gt;next = L-&gt;cursor-&gt;next;
        L-&gt;cursor-&gt;next-&gt;back = inNode;
        L-&gt;cursor-&gt;next = inNode;
        inNode-&gt;back = L-&gt;cursor;
    }
}   // Insert new element after cursor.  
// Pre: length()&gt;0, index()&gt;=0 
void deleteFront(List L){
    if(length(L)&gt;0){
        L-&gt;head = L-&gt;head-&gt;next;
        freeNode(&amp;(L-&gt;head-&gt;back));
    }
}  // Delete the front element. Pre: length()&gt;0 
void deleteBack(List L){
    if(length(L)&gt;0){
        L-&gt;tail = L-&gt;tail-&gt;back;
        freeNode(&amp;(L-&gt;tail-&gt;next));
    }
} // Delete the back element. Pre: length()&gt;0 
void delete(List L){
    if(length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0){
        //reconfig links
        L-&gt;cursor-&gt;back-&gt;next = L-&gt;cursor-&gt;next;
        L-&gt;cursor-&gt;next-&gt;back = L-&gt;cursor-&gt;back;
        freeNode(&amp;(L-&gt;cursor));
    }

} //Pre: length()&gt;0, index()&gt;=0

//Other operations ----------
void printList(FILE* out, List L){
    if( L==NULL ){
        printf("List Error: calling printList() on NULL List reference\n");
        exit(1);
    }
    Node n = L-&gt;head;
    while(n != NULL){
        fprintf(out, "%d--&gt;", n-&gt;data);
    }
   printf("\n");
}

List copyList(List L){
    List nList = newList();
    Node nNode = L-&gt;head;
    //nList-&gt;head = L-&gt;head;
    //nList-&gt;tail = L-&gt;head;
    while(nNode != NULL){
        append(nList, nNode-&gt;data);
</font>
        nNode = nNode-&gt;next;
    }
    return nList;
}


//Special operations
//List concatList (List A, List B);</pre>
</body>
</html>
