<html>
<head>
<title>/fall24/jltaft/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/jltaft/pa1/List.c<p></p><pre>
/*
------------------------------------
Jennifer Taft
jltaft
2024 Fall CSE101 PA1
List.c
C file for List ADT
------------------------------------
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#include "List.h"

<a name="0"></a><font color="#FF0000"><a href="match24-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_58.gif"/></a>

void printList(FILE* out, List L);

//--------------Non-exported types
typedef struct NodeObj* Node;

//---------------displays the basic structure of a node in the list ADT
typedef struct NodeObj {
	int data;
	Node next;
	Node prev;
} NodeObj;

//---------------displays the basic structure of the list ADT AKA Node
typedef struct ListObj{
	Node front;
	Node cursor;
	Node back;
	int cursor_index;
	int length;
} ListObj;


// Constructors-Destructors ---------------------------------------------------
// Creates and returns a new empty List.
List newList(void){
	List L = malloc(sizeof(ListObj));
	assert (L != NULL);
	L-&gt;front = NULL;
	L-&gt;cursor = NULL;
	L-&gt;back = NULL;
	L-&gt;cursor_index = 0;
	L-&gt;length = 0;
	return(L);
}

// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List* pL){
	if(pL != NULL &amp;&amp; *pL!=NULL){
		Node one = (*pL)-&gt;front;
		while(one != NULL){
			Node two = one;
			one = one-&gt;next;
			free(two);
		}
		
		free(*pL);
		*pL = NULL;
	}
}

// Access functions -----------------------------------------------------------
// Returns the number of elements in L.
int length(List L){
	return(L-&gt;length);
}

// Returns index of cursor element if defined, -1 otherwise.
int index(List L){
	if(L-&gt;cursor != NULL){ 
		return(L-&gt;cursor_index);
	}
	//returns -1 if cursor is set to NULL 
	return(-1);	
} 

// Returns front element of L. Pre: length()&gt;0
int front(List L){
	if( L==NULL ){
      printf("List Error: calling front() on NULL List reference\n");
      exit(1);
   	}
   	
	if(length(L)&lt;=0){
		printf("Error: List length &lt;= 0\n");
		exit(1);
	}
	return(L-&gt;front-&gt;data);
}

// Returns back element of L. Pre: length()&gt;0
int back(List L){
	if( L==NULL ){
      printf("List Error: calling back() on NULL List reference\n");
      exit(1);
   	}
   	
	if(length(L)&lt;=0){
		printf("Error calling back(): List length &lt;= 0\n");
		exit(1);
	}
	return(L-&gt;back-&gt;data);
} 

// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L){
	if( L==NULL ){
      printf("List Error: calling get() on NULL List reference\n");
      exit(1);
   	}
   	
   	//if preconditions fail or cursor is NULL
	if(length(L)&lt;=0 || index(L) &lt; 0){
		printf("Error calling get(): List length &lt;= 0 and/or index &lt; 0\n");
		exit(1);
	}
	return(L-&gt;cursor-&gt;data);
}

// Returns true iff Lists A and B contain the same sequence of elements, returns false otherwise.
bool equals(List A, List B){
	if( A==NULL || B==NULL ){
      printf("List Error: calling equals() on NULL List reference\n");
      exit(1);
   }
   
   if(A-&gt;length != B-&gt;length){
   		return false;
   }
   Node N,M;
   
   N = A-&gt;front;
   M = B-&gt;front;
   
   //while loop traverses list and compares data
   while(N != NULL){
   	if(N-&gt;data != M-&gt;data){
   		return false;
   	}
   	N = N-&gt;next;
   	M = M-&gt;next;
   }
   
   return true;
}

// Manipulation procedures ----------------------------------------------------
// Resets L to its original empty state.
void clear(List L){

	while(L-&gt;front != NULL){	
		//code from deleteFront()	
		Node old = L-&gt;front;
		//sets new front to next node in List
		L-&gt;front = old-&gt;next;		
	
		//if the list is empty, sets back to NULL
		if(L-&gt;front != NULL){
			L-&gt;front-&gt;prev = NULL;
		} else{ //if list is empty
			L-&gt;back = NULL;
		}
		
		free(old);
		L-&gt;length--;
	}
	
	L-&gt;cursor = NULL;
	L-&gt;cursor_index = -1;
	L-&gt;length = 0;
} 

// Overwrites the cursor elementâ€™s data with x.
// Pre: length()&gt;0, index()&gt;=0
void set(List L, int x){
	if(length(L)&lt;=0 || index(L)&lt;0){
		printf("List Error: invalid call for set()\n");
    	exit(1);
	}
	
	L-&gt;cursor-&gt;data = x;
} 

// If L is non-empty, sets cursor under the front element,
// otherwise does nothing.
void moveFront(List L){
	if(length(L) &lt;= 0){
		printf("List Error: Called moveFront() on empty list \n");
    	exit(1);
	}
	
	L-&gt;cursor = L-&gt;front;
	L-&gt;cursor_index = 0;
} 

// If L is non-empty, sets cursor under the back element,
// otherwise does nothing.
void moveBack(List L){
	if(length(L) &lt;= 0){
		printf("List Error: Called moveFront() on empty list \n");
    	exit(1);
	}
	
	L-&gt;cursor = L-&gt;back;
	L-&gt;cursor_index = L-&gt;length - 1;
} 

// If cursor is defined and not at front, move cursor one
// step toward the front of L; if cursor is defined and at
// front, cursor becomes undefined; if cursor is undefined
// do nothing
void movePrev(List L){
	//if cursor is undefined
	if(L-&gt;cursor == NULL){
		return;
	}
	//if cursor is defined and is at the front
	if(L-&gt;cursor == L-&gt;front){
		L-&gt;cursor = NULL;
		L-&gt;cursor_index = -1;
	} else { //if cursor is defined and is not at the front
		//L's cursor becomes the previous node
		L-&gt;cursor = L-&gt;cursor-&gt;prev;
		L-&gt;cursor_index--;
	}
	
}

// If cursor is defined and not at back, move cursor one
// step toward the back of L; if cursor is defined and at
// back, cursor becomes undefined; if cursor is undefined
// do nothing
void moveNext(List L){
	//if cursor is undefined
	if(L-&gt;cursor == NULL){
		return;
	}

	//if cursor is at the back
	if(L-&gt;cursor == L-&gt;back){
		//printf("cursor index: %d ", L-&gt;cursor_index);
		L-&gt;cursor = NULL;
		L-&gt;cursor_index = -1;
	} else{ //if cursor is defined and not at the back
		L-&gt;cursor = L-&gt;cursor-&gt;next;
		L-&gt;cursor_index++;
	}
}

// Insert new element into L. If L is non-empty,
// insertion takes place before front element.
void prepend(List L, int x){
	//initializes Node
	Node newNode = malloc(sizeof(NodeObj));
	assert(newNode != NULL);
	
	newNode-&gt;data = x;
	newNode-&gt;next = NULL;
	newNode-&gt;prev = NULL;
	
	if(length(L) &gt; 0){
		//sets up newNode to point to old front
		newNode-&gt;next = L-&gt;front;
		//sets up old front's prev to be newNode
		L-&gt;front-&gt;prev = newNode;
		L-&gt;front = newNode;
	} else{ //if list is empty 
		//new front is now newNode
		L-&gt;front = newNode;
		L-&gt;back = newNode;
	}
	L-&gt;cursor_index++;
	L-&gt;length++;
} 

// Insert new element into L. If L is non-empty,
// insertion takes place after back element.
void append(List L, int x){
	//initializes Node
	Node newNode = malloc(sizeof(NodeObj));
	assert(newNode != NULL);
	
	newNode-&gt;data = x;
	newNode-&gt;next = NULL;
	newNode-&gt;prev = NULL;
	
	if(length(L) &gt; 0){
		//sets up newNode to point to old back
		newNode-&gt;prev = L-&gt;back;
		//sets up old back's next to be newNode
		L-&gt;back-&gt;next = newNode;
		L-&gt;back = newNode;
	} else{ //if list is empty
		L-&gt;front = newNode;
		L-&gt;back = newNode;
	}
	L-&gt;length++;
}

// Insert new element before cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x){
	//preconditions
	assert(length(L)&gt;0);
	assert(index(L)&gt;=0);

	//initializes Node
	Node newNode = malloc(sizeof(NodeObj));
	assert(newNode != NULL);
	newNode-&gt;data = x;
	
	//sets newNode's next to cursor
	newNode-&gt;next = L-&gt;cursor;
	
	//if the cursor is placed at the front of the list
	if(L-&gt;cursor==L-&gt;front){
		//newNode's next is the old front
		newNode-&gt;next = L-&gt;front;
		//newNode's prev is NULL 
		newNode-&gt;prev = NULL;
		//old front's prev is newNode
		L-&gt;front-&gt;prev = newNode;
</font>		//new front is newNode
		L-&gt;front = newNode;
	} else{ //if the cursor is not in the front
		//newNode's next is the cursor
		newNode-&gt;next = L-&gt;cursor;
		//newNode's prev points to cursor's prev
		newNode-&gt;prev = L-&gt;cursor-&gt;prev;
		//cursor's prev's next is now newNode
		L-&gt;cursor-&gt;prev-&gt;next = newNode;
		//cursor's prev becomes newNode
<a name="1"></a><font color="#00FF00"><a href="match24-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_37.gif"/></a>

		L-&gt;cursor-&gt;prev = newNode;
		
	}
	L-&gt;cursor_index++;
	L-&gt;length++;
} 

// Insert new element after cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x){
	//preconditions
	assert(length(L)&gt;0);
	assert(index(L)&gt;=0);

	//initializes Node
	Node newNode = malloc(sizeof(NodeObj));
	assert(newNode != NULL);
	newNode-&gt;data = x;
	
	//sets newNode's prev to cursor
	newNode-&gt;prev = L-&gt;cursor;
	
	//if the cursor is placed at the back of the list
	if(L-&gt;cursor==L-&gt;back){
		//newNode's next is NULL 
		newNode-&gt;next = NULL;
		//newNode's prev is the old back
		newNode-&gt;prev = L-&gt;back;
		//old back's next is newNode
		L-&gt;back-&gt;next = newNode;
		//new back is newNode
		L-&gt;back = newNode;
	} else{ //if the cursor is not in the back
		//newNode's next points to cursor's next
		newNode-&gt;next = L-&gt;cursor-&gt;next;
		//newNode's prev is the cursor
		newNode-&gt;prev = L-&gt;cursor;
		
		if(L-&gt;cursor-&gt;next != NULL){ //if the cursor is not in the back
			//cursor's next's prev is now newNode
			L-&gt;cursor-&gt;next-&gt;prev = newNode;
		}
		//cursor's next becomes newNode
		L-&gt;cursor-&gt;next = newNode;
	}
	L-&gt;length++;
} 

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L){
	//precondition
	assert(length(L)&gt;0);
	
	Node old = L-&gt;front;
	
	//if there is only one element
	if(L-&gt;front == L-&gt;back){
		free(old);
		L-&gt;front = NULL;
		L-&gt;back = NULL;
		L-&gt;cursor = NULL;
		L-&gt;cursor_index = -1;
	} else{
		//sets new front to next node in List
		L-&gt;front = old-&gt;next;
		//sets the new front's prev to NULL
		L-&gt;front-&gt;prev = NULL;
		free(old);
	}
	if(L-&gt;cursor == old){ //if the cursor was pointing to the front
		L-&gt;cursor = NULL;
		L-&gt;cursor_index = -1;
	}
	L-&gt;cursor_index--;
	L-&gt;length--;
} 

// Delete the back element. Pre: length()&gt;0
void deleteBack(List L){
		//precondition
	assert(length(L)&gt;0);
	
	Node old = L-&gt;back;
	
	//if there is only one element in the list
	if(L-&gt;back == L-&gt;front){
		free(old);
		L-&gt;back = NULL;
		L-&gt;front = NULL;
		L-&gt;cursor = NULL;
		L-&gt;cursor_index = -1;
	} else{
		//sets new back to prev node in List
		L-&gt;back = old-&gt;prev;
		//sets the new back's next to NULL
		L-&gt;back-&gt;next = NULL;
		free(old);
	}
	if(L-&gt;cursor == old){ //if the cursor was pointing to the back
		L-&gt;cursor = NULL;
		L-&gt;cursor_index = -1;
	}
	L-&gt;length--;
}

// Delete cursor element, making cursor undefined.
// Pre: length()&gt;0, index()&gt;=0
void delete(List L){
	assert(length(L)&gt;0);
	assert(index(L)&gt;=0);
	
	Node old = L-&gt;cursor;
	
	if(L-&gt;cursor == L-&gt;front){ //will also include list with one element
		deleteFront(L);
	} else if(L-&gt;cursor == L-&gt;back){
		deleteBack(L);
	} else { //cursor is anywhere else in the list
		L-&gt;length--;
		L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
		L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
		free(old);
	}
	
	L-&gt;cursor = NULL;
	L-&gt;cursor_index = -1;
}

// Other operations -----------------------------------------------------------

// Prints to the file pointed to by out, a
// string representation of L consisting
// of a space separated sequence of integers,
// with front on left.
void printList(FILE* out, List L){
	Node N = NULL;

	if(L == NULL){
		printf("List Error: calling printList() on NULL List reference\n");
		exit(1);
	}
	
	for(N = L-&gt;front; N != NULL; N = N-&gt;next){
		fprintf(out, "%d ", N-&gt;data);
	}
}


// Returns a new List representing the same integer
// sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.
List copyList(List L){
	List new_list = newList();
	new_list-&gt;cursor_index = -1;
	
	if (length(L)==0){
		return new_list;
	}
	
	Node N = NULL;
	
	for(N = L-&gt;front; N != NULL; N = N-&gt;next){
		append(new_list, N-&gt;data);
	}
	
	return new_list;
</font>}</pre>
</body>
</html>
