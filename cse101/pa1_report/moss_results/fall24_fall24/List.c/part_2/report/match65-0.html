<html>
<head>
<title>/fall24/vperla/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/vperla/pa1/List.c<p></p><pre>
/*
 * Name : Vishal Perla
 * Cruz id : vperla
 * Assignment : pa1
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

// Define the ListObj structure
<a name="0"></a><font color="#FF0000"><a href="match65-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

struct ListObj {
    int *array;      // Pointer to an array of integers
    int front;      // Index of the front element
    int back;       // Index of the back element
    int cursor;     // Index of the current cursor element
    int size;       // Number of elements in the list
    int capacity;   // Maximum capacity of the list
};

// Create a new empty list
List newList() {
    List L = malloc(sizeof(struct ListObj));
    L-&gt;array = malloc(10 * sizeof(int)); // Initial capacity
    L-&gt;front = 0;
    L-&gt;back = -1;
    L-&gt;cursor = -1; // Cursor is undefined initially
    L-&gt;size = 0;
    L-&gt;capacity = 10;
    return L;
}

// Free all memory associated with the list
void freeList(List* pL) {
    if (pL != NULL &amp;&amp; *pL != NULL) {
        free((*pL)-&gt;array);
        free(*pL);
        *pL = NULL;
    }
}

// Get the size of the list
int length(List L) {
    return L-&gt;size;
}

// Get the index of the cursor element
int index(List L) {
    return L-&gt;cursor;
}

// Get the front element
int front(List L) {
    if (L-&gt;size &gt; 0) {
        return L-&gt;array[L-&gt;front];
    }
    printf("List Error: calling front() on an empty list\n");
    exit(1);
}

// Get the back element
int back(List L) {
    if (L-&gt;size &gt; 0) {
        return L-&gt;array[L-&gt;back];
    }
    printf("List Error: calling back() on an empty list\n");
    exit(1);
}

// Get the cursor element
int get(List L) {
    if (L-&gt;size &gt; 0 &amp;&amp; L-&gt;cursor &gt;= 0) {
        return L-&gt;array[L-&gt;cursor];
    }
    printf("List Error: calling get() on undefined cursor\n");
    exit(1);
}

// Check if two lists are equal
bool equals(List A, List B) {
    if (A-&gt;size != B-&gt;size) return false;
    for (int i = 0; i &lt; A-&gt;size; i++) {
        if (A-&gt;array[i] != B-&gt;array[i]) return false;
    }
    return true;
}

// Clear the list
void clear(List L) {
    L-&gt;size = 0;
    L-&gt;front = 0;
    L-&gt;back = -1;
    L-&gt;cursor = -1;
}

// Overwrite the cursor element's data with x
void set(List L, int x) {
    if (L-&gt;cursor &gt;= 0) {
        L-&gt;array[L-&gt;cursor] = x;
    } else {
        printf("List Error: calling set() on undefined cursor\n");
        exit(1);
    }
}

// Move cursor to the front
void moveFront(List L) {
    if (L-&gt;size &gt; 0) {
        L-&gt;cursor = L-&gt;front;
    }
}

// Move cursor to the back
void moveBack(List L) {
    if (L-&gt;size &gt; 0) {
        L-&gt;cursor = L-&gt;back;
    }
}

// Move cursor one step toward the front
void movePrev(List L) {
    if (L-&gt;cursor &gt; 0) {
        L-&gt;cursor--;
    } else if (L-&gt;cursor == 0) {
        L-&gt;cursor = -1;
    }
}

// Move cursor one step toward the back
void moveNext(List L) {
    if (L-&gt;cursor &lt; L-&gt;size - 1) {
        L-&gt;cursor++;
    } else if (L-&gt;cursor == L-&gt;size - 1) {
        L-&gt;cursor = -1;
    }
}

// Prepend a new element to the list
void prepend(List L, int x) {
    if (L-&gt;size &gt;= L-&gt;capacity) {
        L-&gt;capacity *= 2;
        L-&gt;array = realloc(L-&gt;array, L-&gt;capacity * sizeof(int));
    }
    for (int i = L-&gt;size; i &gt; 0; i--) {
        L-&gt;array[i] = L-&gt;array[i - 1];
    }
    L-&gt;array[0] = x;
    L-&gt;size++;
    L-&gt;back++;

    // Adjust cursor because the list has shifted
    if (L-&gt;cursor != -1) {
        L-&gt;cursor++;
    }
}



// Append a new element to the list
void append(List L, int x) {
    if (L-&gt;size &gt;= L-&gt;capacity) {
        L-&gt;capacity *= 2;
        L-&gt;array = realloc(L-&gt;array, L-&gt;capacity * sizeof(int));
    }
    L-&gt;array[L-&gt;size] = x;
    L-&gt;size++;
    L-&gt;back++;
}

// Insert a new element before the cursor
void insertBefore(List L, int x) {
    if (L-&gt;cursor &gt;= 0 &amp;&amp; L-&gt;size &gt; 0) {
        if (L-&gt;size &gt;= L-&gt;capacity) {
            L-&gt;capacity *= 2;
            L-&gt;array = realloc(L-&gt;array, L-&gt;capacity * sizeof(int));
        }
        for (int i = L-&gt;size; i &gt; L-&gt;cursor; i--) {
            L-&gt;array[i] = L-&gt;array[i - 1];
        }
        L-&gt;array[L-&gt;cursor] = x;
        L-&gt;size++;
        L-&gt;back++;

        // Adjust the cursor to point to the newly inserted element
        L-&gt;cursor++;
    } else {
        printf("List Error: calling insertBefore() on undefined cursor\n");
        exit(1);
    }
}


// Insert a new element after the cursor
void insertAfter(List L, int x) {
    if (L-&gt;cursor &gt;= 0 &amp;&amp; L-&gt;size &gt; 0) {
        if (L-&gt;size &gt;= L-&gt;capacity) {
            L-&gt;capacity *= 2;
            L-&gt;array = realloc(L-&gt;array, L-&gt;capacity * sizeof(int));
        }
        for (int i = L-&gt;size; i &gt; L-&gt;cursor + 1; i--) {
            L-&gt;array[i] = L-&gt;array[i - 1];
        }
        L-&gt;array[L-&gt;cursor + 1] = x;
        L-&gt;size++;
        L-&gt;back++;
    } else {
        printf("List Error: calling insertAfter() on undefined cursor\n");
        exit(1);
    }
}

// Delete the front element
void deleteFront(List L) {
    if (L == NULL) {
        printf("List Error: calling deleteFront() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (L-&gt;size &gt; 0) {
        // Shift all elements to the left
        for (int i = 0; i &lt; L-&gt;size - 1; i++) {
            L-&gt;array[i] = L-&gt;array[i + 1];
        }

        // Decrease the size of the list
        L-&gt;size--;

        // Adjust cursor
        if (L-&gt;cursor == 0) {
            L-&gt;cursor = -1;  // Cursor was at the front, now it's undefined
        } else if (L-&gt;cursor &gt; 0) {
            L-&gt;cursor--;  // Move cursor left if it was not at the front
        }

        // Adjust back pointer
        if (L-&gt;size == 0) {
            L-&gt;back = -1;  // List is now empty
        } else {
            L-&gt;back--;  // Decrement back if the list is not empty
        }
    } else {
        printf("List Error: calling deleteFront() on an empty list\n");
        exit(1);
    }
}


// Delete the back element
void deleteBack(List L) {
    if (L-&gt;size &gt; 0) {
        L-&gt;size--;
        L-&gt;back--;
        if (L-&gt;cursor == L-&gt;size) {
            L-&gt;cursor = -1;
        }
    } else {
        printf("List Error: calling deleteBack() on an empty list\n");
        exit(1);
    }
}

// Delete the cursor element
void delete(List L) {
    if (L-&gt;cursor &gt;= 0 &amp;&amp; L-&gt;size &gt; 0) {
        for (int i = L-&gt;cursor; i &lt; L-&gt;size - 1; i++) {
            L-&gt;array[i] = L-&gt;array[i + 1];
        }
        L-&gt;size--;
        L-&gt;back--;
        L-&gt;cursor = -1;
    } else {
        printf("List Error: calling delete() on undefined cursor\n");
        exit(1);
    }
}

// Print the list
void printList(FILE* out, List L) {
    for (int i = 0; i &lt; L-&gt;size; i++) {
        fprintf(out, "%d ", L-&gt;array[i]);
    }
    fprintf(out, "\n");
}

// Copy the list
List copyList(List L) {
    List copy = newList();
    for (int i = 0; i &lt; L-&gt;size; i++) {
        append(copy, L-&gt;array[i]);
</font>    }
    return copy;
}

</pre>
</body>
</html>
