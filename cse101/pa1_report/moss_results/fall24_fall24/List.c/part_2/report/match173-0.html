<html>
<head>
<title>/fall24/flee14/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/flee14/pa1/List.c<p></p><pre>
/***
* Paul Lee
* flee14
* 2024 Fall CSE101 PA{1}
* List.c
* This file is where I implement the functions from List.h 
***/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#include "List.h"

// Order: Constructors-Destructors, Access functions, append, prepend, printList

// Exported types--------------------------------------------------------------
typedef int ListElement;
typedef struct ListObj* List;
typedef struct NodeObj* Node;

// structs---------------------------------------------------------------------
typedef struct NodeObj{
   ListElement data;
   Node next;
   Node prev;
} NodeObj;

typedef struct ListObj{
    Node front;
    Node back;
    int length;
    int index;
    Node Cursor;
} ListObj;

// Constructors-Destructors ---------------------------------------------------
Node newNode(ListElement data){
    Node New = malloc(sizeof(NodeObj));
    assert(New != NULL);
    New-&gt;data = data;
    New-&gt;next = NULL;
    New-&gt;prev = NULL;
    return (New);
}

void freeNode(Node* pointer_New){
    if (pointer_New != NULL &amp;&amp; *pointer_New != NULL){
        free(*pointer_New);
        *pointer_New = NULL;
    }
}

List newList(void){
    List L;
    L = malloc(sizeof(ListObj)); // creates memory in your ram and return the address that's big enough for it to be stored
    assert(L != NULL);
    // initialize front pointer, back pointer, cursor to NULL (Undefined)
    L-&gt;front = L-&gt;back = L-&gt;Cursor = NULL;
    // set initial length to 0
    L-&gt;length = 0;
    // set initial cursor to -1 (Undefined)
    L-&gt;index = -1;
    return(L);
}

// can test this last
void freeList(List* pL){
    if (pL != NULL &amp;&amp; *pL != NULL){
        // remove all the elements from the list
        clear(*pL);
        // free the list structure
        free(*pL);
        // set the pointeer to NULL (avoid danging pointer)
        *pL = NULL;
    }
}

// clear() resets the list to its original empty state
void clear(List L) {
    // if list reference is null, return error message
<a name="3"></a><font color="#00FFFF"><a href="match173-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    if (L == NULL){
        fprintf(stderr, "Error: calling clear func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // while the list is not empty
    while (length(L) &gt; 0){
        // remove elements from the front
        // use deleteFront()
        deleteFront(L);
    }
    // Ensure front pointer and back pointer are NULL
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    // reset cursor to NULL, reset length to 0, reset cursor index to undefined (-1)
    L-&gt;Cursor = NULL;
    L-&gt;length = 0;
</font>    L-&gt;index = -1;
}

// Access functions -----------------------------------------------------------

// Rule of thumb:
// 1) Check if list reference is NULL
// 2) if yes then return error message
// 3) else return what the function is asking for

int length(List L){
    // here we want to check if list reference is NULL
    // if yes then return error message
    if (L == NULL){
        fprintf(stderr, "Error: calling length func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // return the length of the list
    return L-&gt;length;
}

int index(List L){
    // check if list reference is NULL, if yes return error
    if (L == NULL){
        fprintf(stderr, "Error: calling index func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // return the index(current cursor index) of the list
    return L-&gt;index;
}

int front(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling front func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // return data from the front node
    return L-&gt;front-&gt;data;
}

int back(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling back func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // return data from the back node
    return L-&gt;back-&gt;data;
}

// get() returns cursor element of the list when length() &gt; 0 and index() &gt;= 0

int get(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling get func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // condition: when length() &lt;= 0, return error
    if (length(L) &lt;= 0){
        fprintf(stderr, "Error: calling get func on an empty list\n");
        exit(EXIT_FAILURE);
    } 
    // condition: when index() &lt; 0, return error
    if (index(L) &lt; 0){
        fprintf(stderr, "Error: calling get func on an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    // return data from the cursor mode
<a name="2"></a><font color="#0000FF"><a href="match173-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    return L-&gt;Cursor-&gt;data;
}

// This function returns true if and only if Lists A and B contain the same sequence of elements

bool equals(List A, List B){
    // Check if either List reference is NULL since it involves two lists
    // if yes, return error
    if (A == NULL || B == NULL){
        fprintf(stderr, "Error: calling equals func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // To check if two lists are identical, first compare the lengths
    if (length(A) != length(B)){
        // if the lengths are different, lists are not equal, return false
        return false;
    }
    // otherwise, start from the front of both List A and B
    Node list_A = A-&gt;front;
    Node list_B = B-&gt;front;
</font>    // traverse both lists simultaneously from the front
    // use while loop
    while (list_A != NULL &amp;&amp; list_B != NULL){
        // compare data of current nodes
        if (list_A-&gt;data != list_B-&gt;data){
            // if any pair is different, lists are not equal, return false
            return false;
        }
        // move to next node in list A
        list_A = list_A-&gt;next;
        // move to next node in list B
        list_B = list_B-&gt;next;
    }
    // if all elements matched, lists are equal, return true
    return true;
}

// Manipulation procedures ----------------------------------------------------

// Rule of thumb:
// 1) Check if list reference is NULL
// 2) if yes then return error message
// 3) else return what the function is asking for

void prepend (List L, int x){
<a name="4"></a><font color="#FF00FF"><a href="match173-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    if (L == NULL){
        fprintf(stderr, "Error: calling prepend func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // Create a new node with data x
    Node N = newNode(x);
    // if List is empty
    if (length(L) == 0){
        // set front to new node
        L-&gt;front = N;
        // set back to new node
        L-&gt;back = N;
</font>    // if List is not empty
    }else{
        // Link new node to current front
        N-&gt;next = L-&gt;front;
        // Link current front back to new Node N
        L-&gt;front-&gt;prev = N;
        // Update front to new Node N
        L-&gt;front = N;
    }
    // Afterwards, you need to increment the list length
    L-&gt;length++;
    // if cursor is defined, you need to adjust the cursor index as well
    if(L-&gt;Cursor != NULL){
        L-&gt;index++;
    }
}

void append(List L, int x){
<a name="5"></a><font color="#FF0000"><a href="match173-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

    if (L == NULL){
        fprintf(stderr, "Error: calling append func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // Create a new node with data x
    Node N = newNode(x);
    // if List is empty
    if (length(L) == 0){
        // set front to new node
        L-&gt;front = N;
        // set back to new node
        L-&gt;back = N;
</font>    // if List is not empty
    }else{
        // Similar to prepend, but here you use prev and back
        // Link new node back to current back
        N-&gt;prev = L-&gt;back;
        // Link current back back to new Node N
        L-&gt;back-&gt;next = N;
        // Update back to new Node N
        L-&gt;back = N;
    }
    // increment List Length
    L-&gt;length++;
}

void moveFront(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling moveFront func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // when it comes to List ADT
<a name="1"></a><font color="#00FF00"><a href="match173-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    // you only move cursor if List is non-empty
    // here I need to use the length function that I implement earlier
    if (length(L)&gt;0){
        // moveFront sets cursor under the front element
        L-&gt;Cursor = L-&gt;front;
        // now since we move the cursor to the front
        // we need to update the cursor index from -1 to 0
        L-&gt;index = 0;
    }
}

// same logic applies to moveBack(), but be mindful of the node and index
void moveBack(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling moveBack func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (length(L)&gt;0){
        L-&gt;Cursor = L-&gt;back;
        // now since we move the cursor to the back
        // we need to update the cursor index to the last position
        // meaning the length(L)-1
        L-&gt;index = length(L)-1;
</font>    }
}

void moveNext(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling moveNext func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // If a cursor is undefined, do nothing
    // Here, check if cursor is defined
    if (L-&gt;Cursor != NULL){
        // If cursor is defined and not at back, move cursor one step toward the back of L
        if (L-&gt;Cursor-&gt;next != NULL){
            // I should move cursor to next node, and increment the cursor index
            L-&gt;Cursor = L-&gt;Cursor-&gt;next;
            L-&gt;index++;
        // If cursor is defined and at back, cursor becomes undefined (meaning = NULL)
        // undefined cursor index should be -1?
        } else {
            L-&gt;Cursor = NULL;
            L-&gt;index = -1;
        }
    }
}

// similar logic to moveNext, but vice versa
// be mindful here that I should move cursor to prev node, and decrement the cursor index 

void movePrev(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling movePrev func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // If a cursor is undefined, do nothing
    if (L-&gt;Cursor != NULL){
        // If cursor is defined and not at front, move cursor one step toward the front of L
        if (L-&gt;Cursor-&gt;prev != NULL){
            // I should move cursor to previous node, and decrement the cursor index
            L-&gt;Cursor = L-&gt;Cursor-&gt;prev;
            L-&gt;index--;
        // If cursor is defined and at front, cursor becomes undefined (meaning = NULL)
        } else {
            L-&gt;Cursor = NULL;
<a name="0"></a><font color="#FF0000"><a href="match173-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

            L-&gt;index = -1;
        }
    }
}

// This function overwrites the cursor element's data with x
// similar logic to the get()
// returns cursor element's data when length() &gt; 0 and index() &gt;= 0

void set(List L, int x){
    if (L == NULL){
        fprintf(stderr, "Error: calling set func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // condition: when length() &lt;= 0, return error
    if (length(L) &lt;= 0){
        fprintf(stderr, "Error: calling set func on an empty list\n");
        exit(EXIT_FAILURE);
    } 
    // condition: when index() &lt; 0, return error
    if (index(L) &lt; 0){
        fprintf(stderr, "Error: calling set func on an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    // set the cursor's data to x
    L-&gt;Cursor-&gt;data = x;
}

void deleteFront(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling deleteFront func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // Also need to ensure that the list is not empty
    if (length(L) &lt;= 0){
</font>        fprintf(stderr, "Error: calling deleteFront func on an empty list\n");
        exit(EXIT_FAILURE);
    }
    // create a temporary node to hold front
    Node N = L-&gt;front;
    // This function deletes the front element when length() &gt; 0
    // so if the cursor is at the front, undefined cursor
    if (L-&gt;Cursor == L-&gt;front){
        // undefined cursor = NULL and cursor index is -1
        L-&gt;Cursor = NULL;
        L-&gt;index = -1;
    // if cursor is defined and not at front
    } else if (L-&gt;index != -1){
    // decrement cursor index
        L-&gt;index--;
    }
    // if more than one element exists
    if (L-&gt;length &gt; 1){
        // move front to next node
        L-&gt;front = L-&gt;front-&gt;next;
        // set the updated front's prev to NULL
        L-&gt;front-&gt;prev = NULL;
    // if only one element exists, set both front and back of the list to NULL
    } else {
        L-&gt;front = NULL;
        L-&gt;back = NULL;
    }
    // Since this function deletes an element
    // decrement list length and free the removed temporary node 
    L-&gt;length--;
    freeNode(&amp;N);
}

// deleteBack() uses the same logic, but replace front with back
void deleteBack(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling deleteBack func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // Also need to ensure that the list is not empty
    if (length(L) &lt;= 0){
        fprintf(stderr, "Error: calling deleteBack func on an empty list\n");
        exit(EXIT_FAILURE);
    }
    // create a temporary node to hold back
    Node N = L-&gt;back;
    // This function deletes the back element when length() &gt; 0
    // so if the cursor is at the back, undefined cursor
    if (L-&gt;Cursor == L-&gt;back){
        // undefined cursor = NULL and cursor index is -1
        L-&gt;Cursor = NULL;
        L-&gt;index = -1;
    }
    // if more than one element exists
    if (L-&gt;length &gt; 1){
        // move back to prev node
        L-&gt;back = L-&gt;back-&gt;prev;
        // set the updated back's next to NULL
        L-&gt;back-&gt;next = NULL;
    // if only one element exists, set both front and back of the list to NULL
    } else {
        L-&gt;front = NULL;
        L-&gt;back = NULL;
    }
    // Since this function deletes an element
    // decrement list length and free the removed temporary node 
    L-&gt;length--;
    freeNode(&amp;N);
}

void delete(List L){
    // This function deletes cursor element, making cursor undefined when length() &gt; 0, index() &gt;= 0
    // use deleteFront() and deleteBack() in this function
    if (L == NULL){
        fprintf(stderr, "Error: calling delete func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // condition: when length() &lt;= 0, return error
    if (length(L) &lt;= 0){
        fprintf(stderr, "Error: calling delete func on an empty list\n");
        exit(EXIT_FAILURE);
    } 
    // condition: when index() &lt; 0, return error
    if (index(L) &lt; 0){
        fprintf(stderr, "Error: calling delete func on an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    // create a to-be-deleted node for the cursor element
    Node N = L-&gt;Cursor;
    // if cursor is at front, deleteFront()
    if (N == L-&gt;front){
        deleteFront(L);
    // if cursor is at back, deleteBack()
    } else if (N == L-&gt;back){
        deleteBack(L);
    // if cursor is in the middle
    } else {
        // link previous node to next node
        N-&gt;prev-&gt;next = N-&gt;next;
        // link next node back to previous node
        N-&gt;next-&gt;prev = N-&gt;prev;
        // undefined cursor
        L-&gt;Cursor = NULL;
        L-&gt;index = -1;
        // decrement list length when delete
        L-&gt;length--;
        // freenode
        freeNode(&amp;N);
    }
}

void insertBefore(List L, int x){
    // insert new element before cursor when length () &gt; 0, index() &gt;= 0
    if (L == NULL){
        fprintf(stderr, "Error: calling insertBefore func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // condition: when length() &lt;= 0, return error
    if (length(L) &lt;= 0){
<a name="6"></a><font color="#00FF00"><a href="match173-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        fprintf(stderr, "Error: calling insertBefore func on an empty list\n");
        exit(EXIT_FAILURE);
    } 
    // condition: when index() &lt; 0, return error
    if (index(L) &lt; 0){
        fprintf(stderr, "Error: calling insertBefore func on an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    // if cursor is at the front
    if(L-&gt;Cursor == L-&gt;front){
        // prepend the new node
        prepend(L, x);
</font>    // if cursor is defined
    } else if(L-&gt;Cursor != NULL){
        // create a new node
        Node N = newNode(x);
        // link new node to cursor
        N-&gt;next = L-&gt;Cursor;
        // link new node to cursor's prev node
        N-&gt;prev = L-&gt;Cursor-&gt;prev;
        // link cursor's previous node to new node
        L-&gt;Cursor-&gt;prev-&gt;next = N;
        // link cursor to new node
        L-&gt;Cursor-&gt;prev = N;
        // adjust cursor index and increment list length
        L-&gt;index++;
        L-&gt;length++;
    }
    // // Create a new node with data x
    // Node N = newNode(x);
    // // if cursor is at the front
    // if (L-&gt;Cursor == L-&gt;front){
    //     // update front to new node
    //     L-&gt;front = N;
    // // if cursor is not at the front
    // } else {
    //     // link new node to previous node
    //     N-&gt;prev = L-&gt;Cursor-&gt;prev;
    //     // link previous node to new node
    //     L-&gt;Cursor-&gt;prev-&gt;next = N;
    // }
    // // Link new node to cursor
    // L-&gt;Cursor-&gt;prev = N;
    // // Link cursor back to the new node
    // L-&gt;Cursor-&gt;prev-&gt;next = N;
    // // increment list length
    // L-&gt;length++;
    // // adjust cursor index
    // L-&gt;index++;
}

void insertAfter(List L, int x){
    // insert new element before cursor when length () &gt; 0, index() &gt;= 0
    if (L == NULL){
        fprintf(stderr, "Error: calling insertAfter func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // condition: when length() &lt;= 0, return error
    if (length(L) &lt;= 0){
<a name="7"></a><font color="#0000FF"><a href="match173-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

        fprintf(stderr, "Error: calling insertAfter func on an empty list\n");
        exit(EXIT_FAILURE);
    } 
    // condition: when index() &lt; 0, return error
    if (index(L) &lt; 0){
        fprintf(stderr, "Error: calling insertAfter func on an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    // if cursor is at the back
    if(L-&gt;Cursor == L-&gt;back){
        // use append() to append the new node
        append(L, x);
</font>    // if cursor is defined
    } else if(L-&gt;Cursor != NULL){
        // create a new node
        Node N = newNode(x);
        // link new node to cursor
        N-&gt;prev = L-&gt;Cursor;
        // link new node to cursor's next node
        N-&gt;next = L-&gt;Cursor-&gt;next;
        // link cursor's next node to new node
        L-&gt;Cursor-&gt;next-&gt;prev = N;
        // link cursor to new node
        L-&gt;Cursor-&gt;next = N;
        // increment list length
        L-&gt;length++;
    }
    // // Create a node with data x
    // Node N = newNode(x);
    // // if cusor is at the back
    // if (L-&gt;Cursor == L-&gt;back){
    //     // update back to new node
    //     L-&gt;back = N;
    // // if cursor is not at the back
    // } else {
    //     // link new node to next node
    //     N-&gt;next = L-&gt;Cursor-&gt;next;
    //     // link next node back to new node
    //     L-&gt;Cursor-&gt;next-&gt;prev = N;
    // }
    // // link new node back to cursor
    // N-&gt;prev = L-&gt;Cursor;
    // // link cursor to new node
    // L-&gt;Cursor-&gt;next = N;
    // // increment List length
    // L-&gt;length++;
}

// Other operations -----------------------------------------------------------

// Rule of thumb:
// 1) Check if list reference is NULL
// 2) if yes then return error message
// 3) else return what the function is asking for

void printList(FILE* out, List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling printList func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // start from the front node
    Node N = L-&gt;front;
    // then traverse the list from front to back
    while (N != NULL){
        // print each node's data followed by a space
        // %d
        fprintf(out, "%d ", N-&gt;data);
        // move to the next node
        N = N-&gt;next;
    }
}

// This function returns a new List representing the same integer sequence as L
// The cursor in the new list is undefined, regardless of the state of the cursor in L
// The state of L is unchanged

List copyList(List L){
    if (L == NULL){
        fprintf(stderr, "Error: calling copyList func on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    // Create a new empty list
    List copyList = newList();
    // start from the front node of copyList
    Node N = L-&gt;front;
    // traverse the original List
    while (N != NULL){
        // append each data element to the copy
        append(copyList, N-&gt;data);
        // move to the next node
        N = N-&gt;next;
    }
    return copyList;
}</pre>
</body>
</html>
