<html>
<head>
<title>/fall24/edwhuang/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/edwhuang/pa1/List.c<p></p><pre>
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include "List.h"


// structs --------------------------------------------------------------------

// private NodeObj type
<a name="2"></a><font color="#0000FF"><a href="match10-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

typedef struct NodeObj {
    ListElement data;
    struct NodeObj* next;
    struct NodeObj* prev;
} NodeObj;

// private Node type
typedef NodeObj* Node;

// private ListObj type
typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int index;
    int length;
} ListObj;


// Constructors-Destructors ---------------------------------------------------

// newNode()
// returns reference to new empty Node object.
Node newNode(ListElement data) {
    Node N  = malloc(sizeof(NodeObj));
    assert(N != NULL);

    N-&gt;data = data;
    N-&gt;next = N-&gt;prev = NULL;
</font>    return (N);
}

// freeNode()
// free all heap memory associated with List *pL, and sets *pL to NULL
void freeNode(Node* pN) {
    if (pN != NULL &amp;&amp; *pN != NULL) {
        free(*pN);
    }
    *pN = NULL;
}


// newList()
// Returns reference to new empty List object. 
List newList(void) {
    List L;
    L = malloc(sizeof(ListObj));
    assert (L != NULL);

<a name="0"></a><font color="#FF0000"><a href="match10-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_50.gif"/></a>

    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length = 0;

    return(L);
}

// freeList()
// Frees all heap memory associated with List *pL, and sets *pL to NULL.
void freeList(List* pL) {
    if (pL == NULL || *pL == NULL) {
        return;
    }

    List L = *pL;
    Node currNode = L-&gt;front;
    Node nextNode;

    // deleting all nodes and freeing their memory
    while (currNode != NULL) {
        nextNode = currNode-&gt;next;
        free(currNode);
        currNode = nextNode;
    }

    free(L);
    *pL = NULL;
}




// Access functions -----------------------------------------------------------

// length()
// Returns the length of L.
int length(List L) {
    if (L == NULL) {
        printf("List Error: Calling length() on a NULL List reference\n");
        return(EXIT_FAILURE);
    }
    return (L-&gt;length);
}

// index()
// returns index of cursor element if defined, -1 otherwise
int index(List L) {
    if (L == NULL || L-&gt;cursor == NULL) {
        return -1;
    }

    Node temp = L-&gt;front;
    int ind = 0;

    // get the current index in the list
    while (temp != NULL) {
        if (temp == L-&gt;cursor) {
            return ind;
        }
        temp = temp-&gt;next;
        ind++;
    }
    return -1;
}

// front()
// returns front element of L.
// Pre: length() &gt; 0
int front(List L) {
    if (L == NULL) {
        printf("List Error: Calling front() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt; 0) {
        printf("List Error: Calling front() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    return(L-&gt;front-&gt;data);
}

// back()
// returns back element of L.
// Pre: length() &gt; 0
int back(List L) {
    if (L == NULL) {
        printf("List Error: Calling back() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt;= 0 || L-&gt;back == NULL) {
        printf("List Error: Calling back() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    return (L-&gt;back-&gt;data);
}

// get()
// returns cursor element of L
// Pre: length() &gt; 0, index() &gt;= 0
int get(List L) {
    if (L == NULL) {
        printf("List Error: Calling get() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt;= 0 || index(L) &lt; 0) {
        printf("List Error: calling get() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    return(L-&gt;cursor-&gt;data);
}

// equals()
// returns true iff Lists A and B contain the same sequence of elements, returns false otherwise
bool equals(List A, List B) {
    if (A == NULL || B == NULL) {
        printf("List Error: Calling equals() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    Node aPtr = A-&gt;front;
    Node bPtr = B-&gt;front;

    // traverse both lists at the same time
    while (aPtr != NULL &amp;&amp; bPtr != NULL) {
        if (aPtr-&gt;data != bPtr-&gt;data) {
            return false;
        }
        aPtr = aPtr-&gt;next;
        bPtr = bPtr-&gt;next;
    }

    // if the same length, then both lists are the same
    if (aPtr == NULL &amp;&amp; bPtr == NULL) {
        return true;
    }
    
    return false;
}



// Manipulation procedures ----------------------------------------------------

// clear()
// resets L to its original empty state.
void clear(List L) {
    if (L == NULL || L-&gt;front == NULL) {
        printf("List Error: Calling clear on a NULL List reference\n");
        return;
    }

    Node currNode = L-&gt;front;
    Node nextNode;

    while (currNode != NULL) {
        nextNode = currNode-&gt;next;
        free(currNode);
        currNode = nextNode;
    }

    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
}

// set()
// overwrites the cursor element's data with x
// Pre: length() &gt; 0, index() &gt;= 0
void set(List L, int x) {
    if (length(L) &lt;= 0 || index(L) &lt; 0) {
        printf("List Error: Calling set() on a empty List\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursor-&gt;data = x;
}

// moveFront()
// If L isn't empty, sets cursor under the front element. Otherwise, do nothing.
void moveFront(List L) {
    if (L == NULL || L-&gt;front == NULL) {
        return;
    }
    L-&gt;cursor = L-&gt;front;
    L-&gt;index = 0;
}

// moveBack()
// if L isn't empty, sets cursor under the back element. Otherwise, do nothing.
void moveBack(List L) {
    // if the list is empty
    if (L == NULL || L-&gt;front == NULL) {
        return;
    }

    // if only one node is in the list
    if (L-&gt;front == L-&gt;back) {
        L-&gt;cursor = L-&gt;front;
    }

    else {
        L-&gt;cursor = L-&gt;back;
        L-&gt;index = length(L) - 1;
    }
}

// movePrev()
// If the cursor is defined and not at front, move cursor one step towards the front of L
// if the cursor is defined and at front, cursor becomes undefined.
// if the cursor is undefined, do nothing.
void movePrev(List L) {
    if (L == NULL || L-&gt;front == NULL || L-&gt;cursor == NULL) {
        return;
    }

    if (L-&gt;cursor-&gt;prev == NULL) {
        L-&gt;cursor = NULL;
    }

    else {
        L-&gt;cursor = L-&gt;cursor-&gt;prev;
    }
    L-&gt;index--;
}


// moveNext()
// If cursor is defined and not at back, move cursor one step toward the back of L
// if cursor is defined and at back, cursor becomes undefined
// if cursor is undefined, then do nothing.
void moveNext(List L) {
    if (L-&gt;cursor == NULL) {
        return;
    }

    if (L-&gt;cursor-&gt;next != NULL) {
        L-&gt;cursor = L-&gt;cursor-&gt;next;
    }
    else {
        L-&gt;cursor = NULL;
    }
    L-&gt;index++;
}

// prepend()
// inserts new element into L.
// if L is non-empty, insertion takes place before front element
void prepend(List L, int x) {
    if (L == NULL) {
        printf("List Error: Calling prepend() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    Node N = newNode(x);

    // if empty list
    if (L-&gt;front == NULL) {
        L-&gt;front = L-&gt;back = N;
    }
    
    // otherwise, insert before front and make the new node the new front
    else {
        N-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = N;
        L-&gt;front = N;
    }
    L-&gt;length++;
}

// append()
// insert new element into L.
// if L is non-empty, insertion takes place after back element
void append(List L, int x) {
    Node N = newNode(x);

    if (L == NULL) {
        printf("List Error: Calling append() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    // when list is empty
    if (L-&gt;front == NULL) {
        // set front and back to the new node
        L-&gt;front = L-&gt;back = N;
    }
    else {
        // set the back's next pointer to point at the new node
        L-&gt;back-&gt;next = N;

        // set the new node's prev pointer to the back
        N-&gt;prev = L-&gt;back;

        // sets the back to become the new node
        L-&gt;back = N;
    }

    L-&gt;length++;
}

// insertBefore()
// insert new element before cursor
// Pre: length() &gt; 0, index() &gt;= 0
void insertBefore(List L, int x) {
    if (L-&gt;front == NULL) {
        printf("List Error: Calling insertBefore() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt;= 0) {
        printf("List Error: Calling insertBefore() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    if (L-&gt;index == -1) {
        printf("List Error: Calling insertBefore() with a undefined cursor\n");
    }

    Node N = newNode(x);

    // if at head, then add at beginning
    if (L-&gt;cursor == L-&gt;front) {
        // point the new node's next pointer to the cursor
        N-&gt;next = L-&gt;cursor;
        // link the cursor's prev pointer to the new node
        L-&gt;cursor-&gt;prev = N;
</font>        // link the front to become the new node
        L-&gt;front = N;
    }
    // otherwise, link new node with the cursor and the prev node
    else {
        // link new node's next to the cursor
        N-&gt;next = L-&gt;cursor;
        // link new node's prev pointer to the cursor's prev
<a name="1"></a><font color="#00FF00"><a href="match10-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_38.gif"/></a>

        N-&gt;prev = L-&gt;cursor-&gt;prev;

        // link the prev node's next to the new node
        L-&gt;cursor-&gt;prev-&gt;next = N;
        // link the cursor's prev to the new node
        L-&gt;cursor-&gt;prev = N;
    }

    if (L-&gt;cursor != NULL) {
        L-&gt;index++;
    }
    L-&gt;length++;
}

// insertAfter()
// insert new element after cursor
// Pre: length() &gt; 0, index() &gt;= 0
void insertAfter(List L, int x) {
    if (L-&gt;front == NULL) {
        printf("List Error: Calling insertAfter() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt;= 0 || index(L) &lt; 0) {
        printf("List Error: Calling insertAfter() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    Node N = newNode(x);

    // if cursor is at the back, then insert at back
    if (L-&gt;cursor == L-&gt;back) {
        L-&gt;cursor-&gt;next = N;
        N-&gt;prev = L-&gt;cursor;
        L-&gt;back = N;
    }
    // otherwise, then insert in the middle
    else {
        N-&gt;next = L-&gt;cursor-&gt;next;
        N-&gt;prev = L-&gt;cursor;
        L-&gt;cursor-&gt;next-&gt;prev = N;
        L-&gt;cursor-&gt;next = N;
    }
    L-&gt;length++;
}

// deleteFront()
// delete the front element.
// Pre: length() &gt; 0
void deleteFront(List L) {

    if (L-&gt;front == NULL) {
        printf("List Error: Calling deleteFront() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt; 0) {
        printf("List Error: Calling deleteFront() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    Node temp = L-&gt;front;
    L-&gt;front = L-&gt;front-&gt;next;

    // if a node exists at the front, then make its pointer undefined
    if (L-&gt;front != NULL) {
        L-&gt;front-&gt;prev = NULL;
    }

    L-&gt;length--;
    freeNode(&amp;temp);
}

// deleteBack()
// delete the back element
// Pre: length() &gt; 0
void deleteBack(List L) {
    if (L-&gt;front == NULL) {
        printf("List Error: Calling deleteBack() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt; 0) {
        printf("List Error: Calling deleteBack() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    // // if there's nothing left, then just do nothing
    if (L-&gt;back == NULL) {

        return;
    }

    Node temp = L-&gt;back;

    // delete node if cursor points to the back
    if (L-&gt;cursor == temp) {
        L-&gt;cursor = NULL;
    }

    // if only one element is in the list
    if (L-&gt;front == L-&gt;back) {
        L-&gt;front = L-&gt;back = NULL;
    }

    else {
        L-&gt;back = L-&gt;back-&gt;prev;
        L-&gt;back-&gt;next = NULL;
    }

    L-&gt;length--;
    freeNode(&amp;temp);
}


// delete()
// delete cursor element, making cursor undefined
// Pre: length() &gt; 0, index &gt;= 0
void delete(List L) {
    if (L == NULL) {
        printf("List Error: Calling delete() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    if (length(L) &lt;= 0 || index &lt; 0) {
        printf("List Error: Calling delete() on a empty List\n");
        exit(EXIT_FAILURE);
    }

    if (L-&gt;cursor == NULL) {
        printf("List Error: calling delete() when the cursor is undefined");
        exit(EXIT_FAILURE);
    }

    Node temp = L-&gt;cursor;

    // 3 cases:
    // 1) cursor is at front
    // 2) cursor is at back
    // 3) cursor is in the middle

    // delete front node
    if (temp == L-&gt;front) {
        L-&gt;front = temp-&gt;next;

        if (L-&gt;front != NULL) {
            L-&gt;front-&gt;prev = NULL;
        }
    }

    // delete back node
    else if (temp == L-&gt;back) {
        L-&gt;back = temp-&gt;prev;
        if (L-&gt;back != NULL) {
            L-&gt;back-&gt;next = NULL;
        }
    }

    // delete node in the middle and reconnect the nodes
    else {
        // link temp's next node with the node after it
        temp-&gt;prev-&gt;next = temp-&gt;next;
        // links temp's prev node with the node after it
        temp-&gt;next-&gt;prev = temp-&gt;prev;
    }
    

    // reset cursor afterwards
    free(temp);
    L-&gt;length--;
    L-&gt;index = -1;
    L-&gt;cursor = NULL;
}

// Other Functions ------------------------------------------------------------

// printList()
// Prints a string representation of Q consisting of a space separated List 
// of ints to stdout.
void printList(FILE* out, List L) {
    if (L == NULL) {
        printf("List Error: Calling printList() on a NULL List reference\n");
        exit(EXIT_FAILURE);
    }

    // gets front node
    Node N = L-&gt;front;
    
    while (N != NULL) {
        // prints to stdout
        printf("%d ", N-&gt;data);
        N = N-&gt;next;
    }

    printf("\n");
}

// copyList()
// returns a new List representing the same integer sequence as L
// the cursor in the new list is undefined, regardless of the state of L's cursor.
// the state of L is unchanged
List copyList(List L) {
    // return a new list if the original is also empty
    if (L == NULL || L-&gt;front == NULL) {
        return newList();
    }

    List new_list = newList();
    Node currNode = L-&gt;front;

    // append until the original list is traversed entirely
    while (currNode != NULL) {
        append(new_list, currNode-&gt;data);
        currNode = currNode-&gt;next;
    }

    return new_list;
}

// optional
// concatList()
// returns a new List which is the concatenation of A and B.
// the cursor in the new List is undefined, regardless of the states of A and B's cursors
// the state of A and B is unchanged
List concatList(List A, List B) {
    // 3 cases:
    // 1) both lists are empty, then do nothing
    // 2) one list is empty, can only concat the list that is full
    // 3) both lists have something inside, continue as normal

    if (A == NULL &amp;&amp; B == NULL) {
        printf("List Error: Calling concatList() on BOTH of the empty Lists\n");
        exit(EXIT_FAILURE);
    }

    List C = newList();
    C-&gt;front = NULL;

    // pointers for List A and B respectively
    Node aPtr, bPtr;

    // copying values from the first list if it isn't empty
    aPtr = A-&gt;front;
    while (aPtr != NULL) {
        append(C, aPtr-&gt;data);
        aPtr = aPtr-&gt;next;
</font>    }

    // copy values from the second list if it isnt empty
    bPtr = B-&gt;front;
    while (bPtr != NULL) {
        append(C, bPtr-&gt;data);
        bPtr = bPtr-&gt;next;
    }

    return C;
}
</pre>
</body>
</html>
