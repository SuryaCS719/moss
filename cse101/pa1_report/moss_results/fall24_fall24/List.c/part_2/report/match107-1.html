<html>
<head>
<title>/fall24/atruji13/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/atruji13/pa1/List.c<p></p><pre>
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "List.h"

// Private Structures
typedef struct NodeObj {
	int data;
	struct NodeObj* next;
	struct NodeObj* prev;
} NodeObj;

typedef NodeObj* Node; 

typedef struct ListObj {
	Node front;
	Node back;
	Node cursor;
	int length;
	int index;
} ListObj;


// Constructors &amp; Destructors
List newList(void) {
	List L = malloc(sizeof(ListObj)); 
	L-&gt;front = NULL;
	L-&gt;back = NULL;
	L-&gt;cursor = NULL;
	L-&gt;length = 0;
	L-&gt;index = -1;
	return L;
}

void freeList(List* pL) {
	if (pL != NULL &amp;&amp; *pL != NULL) {
		while ((*pL)-&gt;length &gt; 0) {
			deleteFront(*pL); // Delete the node from the front
		}
		free(*pL); // Free the List struct
<a name="2"></a><font color="#0000FF"><a href="match107-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

		*pL = NULL;
	}
}


// Access Functions
int length(List L) {
	return L-&gt;length;
}

int index(List L) {
	if (L-&gt;cursor == NULL) {
		return -1;
	}
	return L-&gt;index;
}

int front(List L) {
	if (L-&gt;length == 0) { // If list is empty
		printf("Error: calling front() on an empty list\n");
		exit(EXIT_FAILURE);
	}
	return L-&gt;front-&gt;data;
}

int back(List L) {
	if (L-&gt;length == 0) {
		printf("Error: calling back() on an empty list\n");
		exit(EXIT_FAILURE);
	}
	return L-&gt;back-&gt;data;
}

int get(List L) {
	if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
		printf("Error: calling get() on an undefined cursor\n");
		exit(EXIT_FAILURE);
	}
	return L-&gt;cursor-&gt;data;
}

bool equals(List A, List B) {
	// Check if lengths of both lists are the same
	if (length(A) != length(B)) {
		return false;
	}
	
	Node currentA = A-&gt;front;
	Node currentB = B-&gt;front;

	// Traverse both lists
	while (currentA != NULL &amp;&amp; currentB != NULL) {
</font>		// Compare data
		if (currentA-&gt;data != currentB-&gt;data) {
			return false;
		}

		currentA = currentA-&gt;next;
		currentB = currentB-&gt;next;
	}
	
	// Lists matched
	return true;	
}


// Manipulation Procedures
void clear(List L) {
	while (L-&gt;length &gt; 0) {
<a name="4"></a><font color="#FF00FF"><a href="match107-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

		deleteFront(L); // Delete each node
	}
	// Reset to empty state
	L-&gt;cursor = NULL;
	L-&gt;index = -1;
}

void set(List L, int x) {
	if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
		printf("Error: calling set() on an undefined cursor or empty list\n");
		exit(EXIT_FAILURE);

	}

	// Set value of cursor element to x
	L-&gt;cursor-&gt;data = x;
}

void moveFront(List L) {
	if (L-&gt;length &gt; 0) {
		L-&gt;cursor = L-&gt;front;
</font>		L-&gt;index = 0;
	}
}

void moveBack(List L) {
	if (L-&gt;length &gt; 0) {
		L-&gt;cursor = L-&gt;back;
		L-&gt;index = L-&gt;length - 1;
	}
}

void movePrev(List L) {
	// Check if cursor is defined and not already at the front, if undefined then the function does nothing
	if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;front) {
		// Move cursor one step towards the front
		L-&gt;cursor = L-&gt;cursor-&gt;prev;
<a name="3"></a><font color="#00FFFF"><a href="match107-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_9.gif"/></a>

		L-&gt;index--;
	} else if (L-&gt;cursor == L-&gt;front) {
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	} else {
		printf("Warning: movePrev() called on undefined cursor\n");
	}
}

void moveNext(List L) {
	if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;back) {
		// Move cursor one step back
		L-&gt;cursor = L-&gt;cursor-&gt;next;
		L-&gt;index++;
	} else if (L-&gt;cursor == L-&gt;back) {
		// If cursor is already at back
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	} else {
		printf("Warning: moveNext() called on undefined cursor\n");
	}
}

void prepend(List L, int data) {
	Node newNode = malloc(sizeof(NodeObj)); // Create new node
	newNode-&gt;data = data;
	newNode-&gt;prev = NULL;
</font>	newNode-&gt;next = L-&gt;front;

	if (L-&gt;length == 0) {
<a name="6"></a><font color="#00FF00"><a href="match107-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

		L-&gt;back = newNode; // If list = empty, set front and back to newNode
	} else {
		L-&gt;front-&gt;prev = newNode; // Adjust previous front element
	}
	L-&gt;front = newNode; // Set new node as the front
	L-&gt;length++;

	// Adjust the cursor index
	if (L-&gt;index != -1) {
		L-&gt;index++;
</font>	}
}

void append(List L, int data) {
	Node newNode = malloc(sizeof(NodeObj)); // Create new node
	newNode-&gt;data = data;
	newNode-&gt;next = NULL;
	newNode-&gt;prev = L-&gt;back;

	if (L-&gt;length == 0) {
		L-&gt;front = newNode; // If list = empty, set both front and back to newNode
	} else {
<a name="0"></a><font color="#FF0000"><a href="match107-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_19.gif"/></a>

		L-&gt;back-&gt;next = newNode; // Adjust previous back element
	}
	L-&gt;back = newNode; // Set new node as back
	L-&gt;length++;
}

void insertBefore(List L, int data) {
	if(L-&gt;length == 0 || L-&gt;cursor == NULL) {
		printf("Error: calling insertBefore() on an empty list or undefined cursor\n");
		exit(EXIT_FAILURE);
	}

	Node newNode = malloc(sizeof(NodeObj)); // Create new node
	newNode-&gt;data = data;
	newNode-&gt;next = L-&gt;cursor;
	newNode-&gt;prev = L-&gt;cursor-&gt;prev;

	if (L-&gt;cursor == L-&gt;front) {
		L-&gt;front = newNode; // If cursor it at front, newNode become the front
	} else {
		L-&gt;cursor-&gt;prev-&gt;next = newNode; // Adjust surrounding nodes
	}
	L-&gt;cursor-&gt;prev = newNode;
	L-&gt;length++;
	L-&gt;index++; // Cursor index
}

void insertAfter(List L, int data) {
	if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
		printf("Error: calling insertAfter() on empty list or undefined cursor\n");
        	exit(EXIT_FAILURE);
    	}

	Node newNode = malloc(sizeof(NodeObj));
    	newNode-&gt;data = data;
    	newNode-&gt;prev = L-&gt;cursor;
    	newNode-&gt;next = L-&gt;cursor-&gt;next;

    	if (L-&gt;cursor == L-&gt;back) {
        	L-&gt;back = newNode; // If cursor is at the back, newNode becomes the back
    	} else {
        	L-&gt;cursor-&gt;next-&gt;prev = newNode; // Adjust surrounding nodes
    	}	
    	L-&gt;cursor-&gt;next = newNode;
    	L-&gt;length++;
}

void deleteFront(List L) {
	if (L-&gt;length == 0) {
		printf("Error: calling deleteFront() on an empty list\n");
		exit(EXIT_FAILURE);
	}
	
	// Storing current node in temp
	Node temp = L-&gt;front;
	
	if (L-&gt;length &gt; 1) {
</font>		L-&gt;front = L-&gt;front-&gt;next; // Front pointer is now next node
		L-&gt;front-&gt;prev = NULL; // Set previous pointer to NULL, it's now front
	} else {
		// If list has only one element
<a name="1"></a><font color="#00FF00"><a href="match107-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

		L-&gt;front = L-&gt;back = NULL;
	}
	
	// If cursor was pointing to front element, it becomes undefined
	if (L-&gt;cursor == temp) {
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	} else if (L-&gt;index != -1) {
		L-&gt;index--; // If cursor isn't at front, shift left 1
	}

	free(temp); // Frees mem of old front node

	L-&gt;length--;
}

void deleteBack(List L) {
	if (L-&gt;length == 0 || L-&gt;length == 0) {
		printf("Error: calling deleteBacK() on an empty list\n");
		exit(EXIT_FAILURE);
	}

	Node temp = L-&gt;back;

	if (L-&gt;length &gt; 1) {
		L-&gt;back = L-&gt;back-&gt;prev;
		L-&gt;back-&gt;next = NULL; // Set next pointer of new back to NULL (since it's now the back)
	} else {
		L-&gt;front = NULL;
		L-&gt;back = NULL;
	}

	// If cursor was pointing to the back element, it becomes undefined
	if (L-&gt;cursor == temp) {
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	}

	free(temp);
	L-&gt;length--;
}

void delete(List L) {
	if (L == NULL || L-&gt;length == 0 || L-&gt;cursor == NULL) {
		printf("Error: calling delete() on an empty list or undefined cursor\n");
		exit(EXIT_FAILURE);
	}

	Node temp = L-&gt;cursor;

	// If cursor is at front, use deleteFront
	if (L-&gt;cursor == L-&gt;front) {
		deleteFront(L);
	} else if (L-&gt;cursor == L-&gt;back) { // Cursor is at back
</font>		deleteBack(L);
	} else { // Cursor is somewhere in the middle
		//Adjust surrounding nodes pointers to bypass cursor node
		L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
		L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;

		free(temp);
		L-&gt;length--;

		// Make cursor undefined after deletion
		L-&gt;cursor = NULL;
		L-&gt;index = -1;
	}
}


// Other
void printList(FILE* out, List L) {
	if (L == NULL) {
		printf("Error: calling printList() on NULL list reference\n");
		exit(EXIT_FAILURE);
	}

	Node current = L-&gt;front;

	// Traverse list and print each element
	while (current != NULL) {
<a name="5"></a><font color="#FF0000"><a href="match107-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

		fprintf(out, "%d ", current-&gt;data);
		current = current-&gt;next;
	}
}

List copyList(List L) {
	if (L == NULL) {
		printf("Error: calling copyList() on NULL list reference\n");
		exit(EXIT_FAILURE);
	}

	List copy = newList(); // New empty list
</font>
	Node current = L-&gt;front;

	// Traverse og list and append each element to new list
	while (current != NULL) {
		append(copy, current-&gt;data);
		current = current-&gt;next;
	}

	return copy;
}
</pre>
</body>
</html>
