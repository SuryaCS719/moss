<html>
<head>
<title>/fall24/ygloria/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/ygloria/pa1/List.c<p></p><pre>
// Name: Yanelli Gloria, CruzID: ygloria, Assignment: pa1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "List.h"

// Node struct to store data and links to the next and previous nodes
typedef struct NodeObj {
    int data;
    struct NodeObj* next;
    struct NodeObj* prev;
} NodeObj;

typedef NodeObj* Node;

// List struct to store front, back, cursor, length, and index
typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int length;
    int index;
} ListObj;

// Constructors-Destructors

// Creates a new empty List
List newList(void) {
    // Allocate memory for the List
    List L = malloc(sizeof(ListObj)); 
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
    return L;
}

// Free memory associated with the list and sets the pointer to NULL
void freeList(List* pL) {
    if (pL != NULL &amp;&amp; *pL != NULL) {
<a name="0"></a><font color="#FF0000"><a href="match110-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_19.gif"/></a>

        clear(*pL); // Clears the list
        free(*pL);  // Frees the memory
        *pL = NULL; // Sets the pointer to NULL
    }
}

// Access functions 

// Return the number of elements in the list
int length(List L) {
    return L-&gt;length; // Return the length stored in the List struct
}

// Return the index of the cursor element, or -1 if undefined
int index(List L) {
    if (L-&gt;cursor == NULL) return -1; // Return cursor index or -1 if undefined
    return L-&gt;index;
}

// Return the data at the front of the list. Error if the list is empty
int front(List L) {
    if (L-&gt;length == 0) exit(1); // Error: calling front on empty list
    return L-&gt;front-&gt;data;
}

// Return the data at the back of the list. Error if the list is empty
int back(List L) {
    if (L-&gt;length == 0) exit(1); // Error: calling back on empty list
    return L-&gt;back-&gt;data;
}

// Return the data at the cursor element. Error if the cursor is undefined
int get(List L) {
    if (L-&gt;cursor == NULL) exit(1); // Error: calling get on undefined cursor
    return L-&gt;cursor-&gt;data;
}

// Compare two lists to see if they are equal by comparing data in each node
int equals(List A, List B) {
    if (A-&gt;length != B-&gt;length) return 0;  // If lengths are different, return 0
    Node nodeA = A-&gt;front;
    Node nodeB = B-&gt;front;
    while (nodeA != NULL &amp;&amp; nodeB != NULL) {
        if (nodeA-&gt;data != nodeB-&gt;data) return 0;  // If data is not equal, return 0
        nodeA = nodeA-&gt;next;
        nodeB = nodeB-&gt;next;
    }
    return 1;  // Lists are equal
}

// Manipulation procedures 

// Clear the List by deleting all nodes
void clear(List L) {
    while (L-&gt;length &gt; 0) {
        deleteFront(L);  // Delete the front node until List is empty
    }
    L-&gt;cursor = NULL;  // Reset the cursor
    L-&gt;index = -1;     // Reset the index
}

// Move the cursor to the front of the List
void moveFront(List L) {
    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;front;  // Set cursor to the front
        L-&gt;index = 0;          // Update index to 0
    }
}

// Move the cursor to the back of the List
void moveBack(List L) {
</font>    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;back;            // Set cursor to the back
        L-&gt;index = L-&gt;length - 1;      // Update index to the last element
    }
}

// Move the cursor one step toward the front of the List
void movePrev(List L) {
    if (L-&gt;cursor != NULL) {
        if (L-&gt;cursor == L-&gt;front) {  // If at the front, set cursor to undefined
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        } else {
            L-&gt;cursor = L-&gt;cursor-&gt;prev;  // Move cursor one step toward the front
            L-&gt;index--;
        }
    }
}

// Move the cursor one step toward the back of the List
void moveNext(List L) {
    if (L-&gt;cursor != NULL) {
        if (L-&gt;cursor == L-&gt;back) {   // If at the back, set cursor to undefined
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        } else {
<a name="1"></a><font color="#00FF00"><a href="match110-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_18.gif"/></a>

            L-&gt;cursor = L-&gt;cursor-&gt;next;  // Move cursor one step toward the back
            L-&gt;index++;
        }
    }
}

// Insert a new element at the front of the List
void prepend(List L, int x) {
    Node newNode = (Node)malloc(sizeof(struct NodeObj));
    newNode-&gt;data = x;
    newNode-&gt;prev = NULL;
    newNode-&gt;next = L-&gt;front;

    if (L-&gt;length == 0) {
        L-&gt;back = newNode;  // If list was empty, set back to new node
    } else {
        L-&gt;front-&gt;prev = newNode;
    }

    L-&gt;front = newNode;
    L-&gt;length++;

    if (L-&gt;index &gt;= 0) {
        L-&gt;index++;  // Update index if cursor is defined
    }
}

// Insert a new element at the back of the List
void append(List L, int x) {
    Node newNode = (Node)malloc(sizeof(struct NodeObj));
    newNode-&gt;data = x;
    newNode-&gt;prev = L-&gt;back;
    newNode-&gt;next = NULL;

    if (L-&gt;length == 0) {
        L-&gt;front = newNode;  // If list was empty, set front to new node
    } else {
        L-&gt;back-&gt;next = newNode;
    }

    L-&gt;back = newNode;
    L-&gt;length++;
}

// Insert a new element before the cursor element
void insertBefore(List L, int x) {
    if (L-&gt;cursor == NULL) exit(1);  // Error: undefined cursor
    Node newNode = (Node)malloc(sizeof(struct NodeObj));
    newNode-&gt;data = x;
    newNode-&gt;next = L-&gt;cursor;
    newNode-&gt;prev = L-&gt;cursor-&gt;prev;
</font>
    if (L-&gt;cursor-&gt;prev != NULL) {
        L-&gt;cursor-&gt;prev-&gt;next = newNode;
    } else {
        L-&gt;front = newNode;  // Cursor was at the front
    }

<a name="3"></a><font color="#00FFFF"><a href="match110-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

    L-&gt;cursor-&gt;prev = newNode;
    L-&gt;length++;
    L-&gt;index++;
}

// Insert a new element after the cursor element
void insertAfter(List L, int x) {
    if (L-&gt;cursor == NULL) exit(1);  // Error: undefined cursor
    Node newNode = (Node)malloc(sizeof(struct NodeObj));
    newNode-&gt;data = x;
    newNode-&gt;prev = L-&gt;cursor;
    newNode-&gt;next = L-&gt;cursor-&gt;next;
</font>
    if (L-&gt;cursor-&gt;next != NULL) {
<a name="4"></a><font color="#FF00FF"><a href="match110-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

        L-&gt;cursor-&gt;next-&gt;prev = newNode;
    } else {
        L-&gt;back = newNode;  // Cursor was at the back
    }

    L-&gt;cursor-&gt;next = newNode;
    L-&gt;length++;
}

// Delete the front element of the List
void deleteFront(List L) {
    if (L-&gt;length == 0) exit(1);  // Error: deleting from an empty List
    Node temp = L-&gt;front;

    if (L-&gt;length &gt; 1) {
        L-&gt;front = L-&gt;front-&gt;next;
        L-&gt;front-&gt;prev = NULL;
</font>    } else {
<a name="2"></a><font color="#0000FF"><a href="match110-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_14.gif"/></a>

        L-&gt;front = L-&gt;back = NULL;  // If List had one element
    }

    if (L-&gt;cursor == temp) {
        L-&gt;cursor = NULL;
        L-&gt;index = -1;  // Cursor becomes undefined
    } else if (L-&gt;index &gt;= 0) {
        L-&gt;index--;  // Adjust index if necessary
    }

    free(temp);  // Free the memory
    L-&gt;length--;
}

// Delete the back element of the List
void deleteBack(List L) {
    if (L-&gt;length == 0) exit(1);  // Error: deleting from an empty List
    Node temp = L-&gt;back;

    if (L-&gt;length &gt; 1) {
        L-&gt;back = L-&gt;back-&gt;prev;
        L-&gt;back-&gt;next = NULL;
    } else {
        L-&gt;front = L-&gt;back = NULL;  // If List had one element
    }

    if (L-&gt;cursor == temp) {
        L-&gt;cursor = NULL;
        L-&gt;index = -1;  // Cursor becomes undefined
    }

    free(temp);  // Free the memory
    L-&gt;length--;
}

// Delete the cursor element
void delete(List L) {
    if (L-&gt;cursor == NULL) exit(1);  // Error: undefined cursor

    if (L-&gt;cursor == L-&gt;front) {
        deleteFront(L);  // Cursor is at the front
    } else if (L-&gt;cursor == L-&gt;back) {
        deleteBack(L);   // Cursor is at the back
    } else {
        Node temp = L-&gt;cursor;
</font><a name="5"></a><font color="#FF0000"><a href="match110-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
        L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
        free(temp);
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
        L-&gt;length--;
    }
}

// Other operations 

// Print the List to the given file in a space-separated format
void printList(FILE* out, List L) {
    Node node = L-&gt;front;
</font>    while (node != NULL) {
        fprintf(out, "%d ", node-&gt;data);
        node = node-&gt;next;
    }
}

// Create a copy of the List and returns it
List copyList(List L) {
    List copy = newList();  // Create a new empty list
    Node node = L-&gt;front;
    while (node != NULL) {
        append(copy, node-&gt;data);  // Append each element to the new list
        node = node-&gt;next;
    }
    return copy;
}
</pre>
</body>
</html>
