<html>
<head>
<title>/fall24/tlaruiz/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/tlaruiz/pa1/List.c<p></p><pre>
/* Tlaloc Ruiz
tlaruiz@ucsc.edu
1937060
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "List.h"
//Creates a structure called NodeObj which holds information for LinkedList
typedef struct NodeObj {
   int data;
   struct NodeObj* next;
   struct NodeObj* prev;
} NodeObj;

typedef NodeObj* Node;

//Creates a structure called ListObj which holds information about where things are on a list
typedef struct ListObj {
   Node front;
   Node cursor;
   Node back;
   int length;
   int index;
} ListObj; 
// Creates a new list, allocating memory equal to the size of ListObj, initializing all needed pointers to their initial values
List newList(void) {
   List L = malloc(sizeof(ListObj));
   L-&gt;front = NULL;
   L-&gt;back = NULL;
   L-&gt;cursor = NULL;
   L-&gt;length = 0;
   L-&gt;index = -1;
   return L;
}
//This frees the stuff within a list, keeping the list
void freeList(List* pL) {
   if (pL != NULL &amp;&amp; *pL != NULL) {
      while ((*pL)-&gt;length &gt;0) {
<a name="2"></a><font color="#0000FF"><a href="match58-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_18.gif"/></a>

         deleteFront(*pL);//target remote | /usr/bin/vgdb --pid=204569
      }
      free(*pL);
      *pL = NULL;
    }
}
//This just returns the Length of the List
int length(List L) {
   return L-&gt;length;
}
//This returns the index
int index(List L) {
   if (L-&gt;index &gt; -1) {
      return L-&gt;index;
   }
   else {
      return -1;
   }
}
//This function 
int front(List L) {
   if (L-&gt;length &gt; 0) {
      return L-&gt;front-&gt;data;
   }
   else {
      fprintf(stderr, "LIST ERROR: calling front() on an empty List\n");
      exit(EXIT_FAILURE);
   }
}
//This function returns the data found at the back of the list
int back(List L) {
   if (L-&gt;length &gt; 0) {
      return L-&gt;back-&gt;data;
   }
   else {
      fprintf(stderr, "LIST ERROR: calling back() on an empty List\n");
      exit(EXIT_FAILURE);
   }
}
//This function returns the position of the cursor within the list
int get(List L) {
   if (L-&gt;length != 0 &amp;&amp; L-&gt;cursor != NULL) {
      return L-&gt;cursor-&gt;data;
   }
   else {
      return -1;
   }
}
//This function compares the words found within a list and checks if they are the same list
bool equals(List A, List B) {
   if (A-&gt;length != B-&gt;length) {
      return false; 
   }
   if (A-&gt;length == 0 &amp;&amp; B-&gt;length == 0) {
     return true;
   }
   Node P = A-&gt;front; 
   Node Q = B-&gt;front;
   
   while (P-&gt;next != NULL) {
      if (P-&gt;data != Q-&gt;data) {
         return false;
      }
      P = P-&gt;next; 
      Q = Q-&gt;next; 
   }
   return true; 
} 
//This function calls on deleteFront until the List's length is 0 then we reset the cursor and index.
void clear(List L) {
   while (L-&gt;length &gt; 0) {
      deleteFront(L);
   }
   L-&gt;cursor = NULL; 
   L-&gt;index = -1; 
}
//This function checks if you are trying to access a null cursor, if not, the cursors' data becomes x.
void set(List L, int x) { 
   if (L-&gt;cursor == NULL) {
      fprintf(stderr, "List Set Error: Trying to set a value at an undefined index\n");
      exit(EXIT_FAILURE);
   }
   L-&gt;cursor-&gt;data = x; 
}
//This function simply moves the cursor to the front of the list
void moveFront(List L) {
   if (L-&gt;length &gt; 0) {
</font>      L-&gt;cursor = L-&gt;front;
      L-&gt;index = 0;
   }
}
//This function simply moves the cursor to the end of the list
void moveBack(List L) { 
   if (L-&gt;length &gt; 0) {
<a name="0"></a><font color="#FF0000"><a href="match58-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_25.gif"/></a>

      L-&gt;cursor = L-&gt;back;
      L-&gt;index = (L-&gt;length - 1); 
   }
}
//This function checks if you are trying to access a null cursor, if not, moves the cursor one back. 
void movePrev(List L) {
   if (L-&gt;cursor == NULL) {
      return; 
   }
   if (L-&gt;cursor == L-&gt;front) {
      L-&gt;cursor = NULL;
      L-&gt;index = -1; 
   }
   else if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;front) {
      L-&gt;cursor = L-&gt;cursor-&gt;prev;
      L-&gt;index--; 
   }
}
//This function checks if you are truing to access a null cursor, if not, moves the cursor one forward.
void moveNext(List L) {
   if (L-&gt;cursor == NULL) {
      L-&gt;index = -1;
      return;
   }
   if (L-&gt;cursor == L-&gt;back) {
      L-&gt;cursor = NULL; 
      L-&gt;index = -1; 
   }
   else if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;back) {
      L-&gt;cursor = L-&gt;cursor-&gt;next; 
      L-&gt;index++; 
   }
}
//
void prepend(List L, int x) {
   if (L == NULL) {
      fprintf(stderr, "List Error (Prepend), trying to call prepend() on a list that does not exist\n");
      exit(EXIT_FAILURE);
   }
   Node T = malloc(sizeof(NodeObj)); 
   if (T == NULL) {
      fprintf(stderr, "Memory Error (Prepend), trying to initalize a node as null\n");
      exit(EXIT_FAILURE); 
   }
   if (L-&gt;length == 0) {
      T-&gt;data = x; 
      T-&gt;next = NULL; 
      T-&gt;prev = NULL; 
      L-&gt;front = T;
      L-&gt;back = T; 
      L-&gt;length++;
   }
   else {
      T-&gt;data = x; 
      T-&gt;next = L-&gt;front;
      T-&gt;prev = NULL; 
      L-&gt;front-&gt;prev = T;
      L-&gt;front = T;
      L-&gt;length++;
   }
   if (L-&gt;cursor !=NULL) {
      L-&gt;index++; 
   }
}
//This adds a node to the end of the list after all required checks pass.
 void append(List L, int x) {
   if (L == NULL) {
      fprintf(stderr, "List Error (Prepend), trying to call prepend() on a list that does not exist\n");
      exit(EXIT_FAILURE);
   }
   Node T = malloc(sizeof(NodeObj));
   if (T == NULL) {
      fprintf(stderr, "Memory Error (Prepend), trying to initalize a node as null\n");
      exit(EXIT_FAILURE);
   }
   T-&gt;data = x;
   T-&gt;next = NULL;
   if (L-&gt;length == 0) {
      T-&gt;prev = NULL;
      L-&gt;front = T;
      L-&gt;back = T;
   }
   else {
   T-&gt;prev = L-&gt;back;
</font>   L-&gt;back-&gt;next = T;
   L-&gt;back = T;
   }
<a name="1"></a><font color="#00FF00"><a href="match58-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_19.gif"/></a>

   L-&gt;length++;
}
//This function adds a node before where you currently are in the list, if you are nowhere, this shoots out an error.
void insertBefore(List L, int x) {
   if ((L-&gt;length) &lt;= 0 &amp;&amp; (L-&gt;index) &lt;= 0) {
      fprintf(stderr, "List Error (insertBefore), attempting to insert before on an unitialized cursor/list\n");
      exit(EXIT_FAILURE);
   }
   Node T = malloc(sizeof(NodeObj));
   if (T== NULL) {
      fprintf(stderr, "Memory Error (insertBefore), trying to initialze a node as null\n");
   }
   if (L-&gt;index == 0) {

      T-&gt;data = x;
      T-&gt;next = L-&gt;front;
      T-&gt;prev = NULL;
      L-&gt;front-&gt;prev = T;
      L-&gt;front = T;
      L-&gt;index++;
      L-&gt;length++; 
   }
   else {
      T-&gt;data = x;
      T-&gt;next = L-&gt;cursor-&gt;prev-&gt;next; 
      T-&gt;prev = L-&gt;cursor-&gt;prev;
      L-&gt;cursor-&gt;prev-&gt;next = T;
      L-&gt;cursor-&gt;prev = T; 
      L-&gt;index++; 
      L-&gt;length++;
   }
}
//
void insertAfter(List L, int x) {
   if ((L-&gt;length) &lt;= 0 &amp;&amp; (L-&gt;index) &lt;= 0) {
      fprintf(stderr, "List Error (insertAfter), attempting to insert before on an unitialized cursor/list\n");
      exit(EXIT_FAILURE);
   }
   Node T = malloc(sizeof(NodeObj));
   if (T== NULL) {
      fprintf(stderr, "Memory Error (insertAfter), trying to initialze a node as null\n");
   }
   if (L-&gt;index == L-&gt;length -1) {
      T-&gt;data = x;
      T-&gt;next = NULL; 
      T-&gt;prev = L-&gt;back; 
      L-&gt;back-&gt;next = T;
      L-&gt;back = T;
      L-&gt;length++; 
   }
   else {
      T-&gt;data = x;
      T-&gt;next = L-&gt;cursor-&gt;next;
      T-&gt;prev = L-&gt;cursor;
      L-&gt;cursor-&gt;next-&gt;prev = T;
</font>      L-&gt;cursor-&gt;next = T;
<a name="3"></a><font color="#00FFFF"><a href="match58-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

      L-&gt;length++;
   }
}
//This function deletes the front of the list.
void deleteFront(List L) {
   if (L-&gt;length &gt; 0) {
      Node Anthony = L-&gt;front; 
      if (L-&gt;length == 1) {
         L-&gt;front = NULL;
	 L-&gt;back = NULL; 
      }
      else {
         L-&gt;front = L-&gt;front-&gt;next;
	 L-&gt;front-&gt;prev = NULL;
      }
      free(Anthony);
      L-&gt;length--;
      if (L-&gt;cursor != NULL) {
        L-&gt;index--;
      }
   }
}
//This function deletes the back of the list.
void deleteBack(List L) {
   if (L-&gt;length &gt; 0) {
      Node Anthony = L-&gt;back;
      if (L-&gt;length == 1) {
         L-&gt;front = NULL;
         L-&gt;back = NULL;
      }
      else {
</font>         L-&gt;back = L-&gt;back-&gt;prev;
         L-&gt;back-&gt;next = NULL;
      }
<a name="4"></a><font color="#FF00FF"><a href="match58-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

      if (L-&gt;cursor == Anthony) {
         L-&gt;cursor = NULL;
	 L-&gt;index = -1;
      }

      free(Anthony);
      L-&gt;length--;
   }
   else {
      fprintf(stderr, "List Error, (deleteBack), calling deleteBack on an empty List\n");
      exit(EXIT_FAILURE);
   }
}
//This function deletes the cursor element and nullifies the cursor
void delete(List L) {
   if (L-&gt;index &gt;=0 &amp;&amp; L-&gt;length &gt; 0) { 
      Node D = L-&gt;cursor; 
      if (D == L-&gt;front) {
         deleteFront(L);
      }
      else if (D == L-&gt;back) {
         deleteBack(L);
      }
      else {
         D-&gt;prev-&gt;next = D-&gt;next;
</font><a name="5"></a><font color="#FF0000"><a href="match58-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

         D-&gt;next-&gt;prev = D-&gt;prev; 
         free(D);
         L-&gt;length--;
      }
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   }
   else {
      fprintf(stderr, "List Error, (deleteBack), calling deleteBack on an empty List\n");
      exit(EXIT_FAILURE);
   }
}
//This function prints out whilst P is not null, ensuring the whole list is printed.
void printList(FILE* out, List L) {
   Node P = L-&gt;front;
   while (P != NULL) {
      fprintf(out, "%d ", P-&gt;data);
</font>      P = P-&gt;next; 
   }
}
//This function copies a list into a new list.
List copyList(List L) {
   List N = newList(); 
   Node C = L-&gt;front; 
   while (C != NULL) {
     append(N, C-&gt;data);
     C = C-&gt;next;
   }
   return N;
}
//
 List concatList(List A, List B) {
    List C = copyList(A);
    Node CE = B-&gt;front;
    while (CE != NULL) {
       append(C, CE-&gt;data);
       CE = CE-&gt;next;
    }
    return C;
}     
</pre>
</body>
</html>
