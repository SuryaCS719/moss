<html>
<head>
<title>/fall24/aaacacio/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/aaacacio/pa1/List.c<p></p><pre>
// Andre Acacio
// 1895405
// pa1

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"


//defines
#define Undefined -1

/// Structs 
//Priv Node type
typedef struct NodeObj* Node;

//Priv Node Obj type
typedef struct NodeObj{
   ListElement data;
   Node next;
   Node prev;
<a name="2"></a><font color="#0000FF"><a href="match21-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

} NodeObj;

// Priv QueueObj type
typedef struct ListObj{
   Node front;
   Node back;
   Node Cursor;
   int length;
   int index;
} ListObj;

///Constructors and Deconstructors


// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(ListElement data){
   Node N = (Node)malloc(sizeof(NodeObj));
   //assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;prev = NULL;
   return(N);
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
</font>   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      free(*pN);
      *pN = NULL;
   }
}

// newList()
// Returns reference to new empty Queue object.
<a name="0"></a><font color="#FF0000"><a href="match21-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_85.gif"/></a>

List newList(){
   List L;
   L = malloc(sizeof(ListObj));
   assert( L!=NULL );
   L-&gt;front = L-&gt;back = NULL;
   L-&gt;index = -1;
   L-&gt;length = 0;
   return(L);
}

// freeList()
// Frees all heap memory associated with Queue *pQ, and sets *pQ to NULL.
void freeList(List* pL){
   if(pL!=NULL &amp;&amp; *pL!=NULL) { 
      while( length(*pL) &gt; 0 ) { 
         deleteFront(*pL); 
      }
      free(*pL);
      *pL = NULL;
   }
}


/// Access functions

 //Simple functions returning certain values, prints error if list is NULL or empty
int length(List L){
    if (L == NULL){
        printf("List Error: calling length() on NULL List reference\n");
            exit(EXIT_FAILURE);
    }
    else{
        return L-&gt;length;
    }
}

int indexx(List L){
    if (L == NULL){
        printf("List Error: calling index() on NULL List reference\n");
            exit(EXIT_FAILURE);
    }
    return L-&gt;index;
} 

int front(List L){
    if (L-&gt;length &lt; 1){
        printf("List Error: calling front() on NULL List reference\n");
            exit(EXIT_FAILURE);
    }
    return L-&gt;front-&gt;data;
} 

int back(List L){
    if (L-&gt;length &lt; 1){
        printf("List Error: calling back() on NULL List reference\n");
            exit(EXIT_FAILURE);
    }
    return L-&gt;back-&gt;data;
} 

int get(List L){
    if (L-&gt;length &lt; 1){
        printf("List Error: calling get() on NULL List reference\n");
            exit(EXIT_FAILURE);
    }
    else if (L-&gt;Cursor &lt; 0){
        printf("List Error: calling get() with UNDEFINED Cursor\n");
            exit(EXIT_FAILURE);
    }
    return L-&gt;Cursor-&gt;data;
    }

bool equals(List A, List B){
    
    Node LA = A-&gt;front;
    Node LB = B-&gt;front;
    if (length(A) == length(B)){
        for (int i = 1; i &lt;= length(A); i++){
            if(LA-&gt;data != LB-&gt;data){ // Checks every value
                return false;
            }
            LA = LA-&gt;next;
            LB = LB-&gt;next;
        }
        return true;
    }
    else return false;
}

// Manipulation procedures
void clear (List L){
    if( L==NULL ){ //Checks if list exists
      printf("List Error: calling clear() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
    Node N = NULL;
    L-&gt;back = L-&gt;front = L-&gt;Cursor = N;
    L-&gt;length = 0;
    L-&gt;index = -1;
}

void set(List L, int x){
    if( L==NULL ){ //Checks if list exists
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

    if (length(L) &lt; 1){
        printf("List Error: calling set() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    else if (L-&gt;index == Undefined){
        printf("List Error: calling set() where cursor is UNDEFINED\n");
        exit(EXIT_FAILURE);
    }

    L-&gt;Cursor-&gt;data = x;
}

void moveFront(List L){
    if (length(L) &lt; 1){
        printf("List Error: calling move moveFront() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;Cursor = L-&gt;front; //Becomes front node
    L-&gt;index = 0;
}
void moveBack(List L){
    if (length(L) &lt; 1){
        printf("List Error: calling move moveFront() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;Cursor = L-&gt;back;
    L-&gt;index = (L-&gt;length - 1); // Set to highest index
}

void movePrev(List L){

    if ((L-&gt;index == Undefined) || (length(L) &lt; 1) || (L==NULL)){
        L = L; //Do nothing
    }

    if(L-&gt;index == 0){
        L-&gt;index = -1;
        L-&gt;Cursor = NULL;
    }

    else{
        L-&gt;index--;
        L-&gt;Cursor = L-&gt;Cursor-&gt;prev; //Moves backwards
    }

}


void moveNext(List L){
    if ((L-&gt;index == Undefined) || (length(L) &lt; 1) || (L==NULL)){
        L = L;
    }

    if(L-&gt;index == (L-&gt;length -1)){ //Max index
        L-&gt;index = -1;
        L-&gt;Cursor = NULL;
    }

    else{
        L-&gt;index++;
        L-&gt;Cursor = L-&gt;Cursor-&gt;next; //moves forwards
    }

}

void prepend(List L, int x){
    Node N = newNode(x);
    if( L==NULL ){ //Checks if list exists
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( length(L) &lt; 1 ) { 
      L-&gt;front = L-&gt;back = N; 
   }else{ 
    N-&gt;next = L-&gt;front; //redifines all four pointers
    N-&gt;prev = NULL;
    L-&gt;front-&gt;prev = N;
    L-&gt;front = N;
   }
   if (indexx(L) &gt; -1){ //Only changes index if cursor is active
    L-&gt;index++;}
   L-&gt;length++;
}
 void append(List L, int x){
    Node N = newNode(x);
    if( L==NULL ){ //Checks if list exists
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if( length(L) &lt; 1 ) { 
    N-&gt;next = N-&gt;prev = NULL;

      L-&gt;front = L-&gt;back = N;
      printf("I REPENT!!\n"); 
   }else{ 
      L-&gt;back-&gt;next = N; 
      N-&gt;prev = L-&gt;back;
      N-&gt;next = NULL;
      L-&gt;back = N; 
   }
   L-&gt;length++;
 }

void insertBefore(List L, int x){

    if( L-&gt;length &lt; 1 ){
      printf("List Error: calling insertAfter() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
    else if (L-&gt;index == Undefined){
        printf("List Error: calling insertAfter() where cursor is UNDEFINED\n");
        exit(EXIT_FAILURE);
    }

    Node N = newNode(x);
    N-&gt;next = L-&gt;Cursor;
    N-&gt;prev = L-&gt;Cursor-&gt;prev;
    
    
    if (L-&gt;Cursor != L-&gt;front){
        printf("Inside Insert b4: so we got index: %d   N-&gt;data:%d    \n", L-&gt;index, N-&gt;data );
        L-&gt;Cursor-&gt;prev-&gt;next = N;
        L-&gt;Cursor-&gt;prev = N;
        L-&gt;index++;
        L-&gt;length++;}
    else{
        prepend(L, x);
        L-&gt;Cursor-&gt;prev = N;
        
    }
}

void insertAfter(List L, int x){
    if( L-&gt;length &lt; 1 ){
      printf("List Error: calling insertAfter() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
    else if (L-&gt;index == Undefined){
        printf("List Error: calling insertAfter() where cursor is UNDEFINED\n");
        exit(EXIT_FAILURE);
    }

    Node N = newNode(x);
    if (L-&gt;Cursor != L-&gt;back){
        L-&gt;Cursor-&gt;next-&gt;prev = N;
        N-&gt;next = L-&gt;Cursor-&gt;next;
        L-&gt;length++;}
    else{
        append(L, x);
    }
    L-&gt;Cursor-&gt;next = N;
    N-&gt;prev = L-&gt;Cursor;
}

 void deleteFront(List L){
    if( L-&gt;length &lt; 1 ){
      printf("List Error: calling deleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node N = NULL;
   if( L==NULL ){
      printf("List Error: calling deleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   N = L-&gt;front;
   if( length(L)&gt;1 ) { 
      L-&gt;front = L-&gt;front-&gt;next; 
    freeNode(&amp;L-&gt;front-&gt;prev); //Eliminates fogotten Node
      L-&gt;front-&gt;prev = NULL; //Removes trace
   }else{ 
      L-&gt;front = L-&gt;back = NULL; 
   }
   L-&gt;length--;

   if (indexx(L) == 0){
    L-&gt;index = -1; //undeclared index if cursor is on it
   }
   else L-&gt;index--;
 }

void deleteBack(List L){
    if( L-&gt;length &lt; 1 ){
      printf("List Error: calling deleteBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node N = NULL;
   if( L==NULL ){
      printf("Queue Error: calling deleteBack() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if( length(L)&gt;1 ) { 
      L-&gt;back = L-&gt;back-&gt;prev; 
      freeNode(&amp;L-&gt;back-&gt;next); //Eliminates fogotten Node
      L-&gt;back-&gt;next = NULL; //Removes trace
   }else{ 
      L-&gt;front = L-&gt;back = NULL; 
      L-&gt;index = -1;
   }

   if (L-&gt;index == (L-&gt;length - 1)){
    L-&gt;index = -1;
   }
   L-&gt;length--;
   
 }
 
void delete(List L){
    if( L-&gt;length &lt; 1 ){
      printf("List Error: calling delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
    else if (L-&gt;index == Undefined){
        printf("List Error: calling delete() where cursor is UNDEFINED\n");
        exit(EXIT_FAILURE);
    }
   
   if( L==NULL ){
      printf("Queue Error: calling delete() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   Node N = L-&gt;Cursor;
   if (L-&gt;index == 0){
    deleteFront(L);
   }
   else if (L-&gt;index == (L-&gt;length - 1)){
    deleteBack(L);
   }
   else{
    L-&gt;Cursor-&gt;prev-&gt;next = L-&gt;Cursor-&gt;next;
    L-&gt;Cursor-&gt;next-&gt;prev = L-&gt;Cursor-&gt;prev;
   }
    L-&gt;index = -1;
    L-&gt;length--;
    L-&gt;Cursor = NULL;
    freeNode(&amp;N);
}
/// Other

void printList(FILE* out, List L){

    if( L==NULL ){
      printf("List Error: calling printList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
    
    Node N = L-&gt;front;
</font>
    while(N != NULL){
        fprintf(out, "%d ", N-&gt;data);
<a name="1"></a><font color="#00FF00"><a href="match21-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

        N = N-&gt;next;
    }

    fprintf(out, "\n");
}

List copyList(List L){
    if( L==NULL ){
      printf("List Error: calling copyList() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
    List NL = newList();
    prepend (NL, L-&gt;front-&gt;data);

    moveFront(L);
    moveNext(L);

    for (int i = 2; i &lt;= length(L); i++){
            append(NL, L-&gt;Cursor-&gt;data);
            moveNext(L);
        }

    NL-&gt;front = L-&gt;front;
    NL-&gt;length = length(L);
    NL-&gt;back = NL-&gt;back;
    NL-&gt;index = -1;
</font>
}
 
 </pre>
</body>
</html>
