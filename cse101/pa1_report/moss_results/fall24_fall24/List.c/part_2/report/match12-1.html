<html>
<head>
<title>/fall24/pshapoor/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/pshapoor/pa1/List.c<p></p><pre>
/***
* Parisa Shapoorian 
* pshapoor 
* 2024 Fall CSE101 PA1  
* List.c // 
* doubly-linked list data structure, providing functions for creating, 
* manipulating, and traversing a list of integers. The file includes 
* functions for common list operations such as insertion, deletion, 
* concatenation, and searching, as well as utility functions for 
* printing and copying lists.
***/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "List.h"

typedef struct NodeObj{
    int data;
    struct NodeObj* next;
    struct NodeObj* prev;

} NodeObj;

typedef NodeObj* Node;

typedef struct ListObj{
    Node front;
    Node back;
    Node cursor;
    int length;
    int Lindex;
} ListObj;

//Constructors
List newList(void) {
    List L = malloc(sizeof(ListObj));
<a name="0"></a><font color="#FF0000"><a href="match12-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_79.gif"/></a>

    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;Lindex = -1;
    return L;
}

Node newNode(int data){
    Node N = malloc(sizeof(NodeObj));
    N-&gt;data= data;
    N-&gt;next = NULL;
    N-&gt;prev = NULL;
    return(N);
}
//destructor for List &amp; Node
void freeNode(Node* pN) {
    if (pN != NULL &amp;&amp; *pN != NULL)
    {
        free(*pN);
        *pN = NULL;
    }
}

void freeList(List* pL) {
    if (pL != NULL &amp;&amp; *pL != NULL)
    {
        clear(*pL); // Can use clear function to empty the list
        free(*pL);
        *pL = NULL;
    }
}


//access functions
int length(List L) {
    if (L==NULL){
        printf("List error: calling length()\n");
        exit(1);
    }
    else{
        return L-&gt;length;
    }
    
}
int index(List L) {
    if (L==NULL){
        printf("List error: calling index()\n");
        exit(1);
    }
    else {
        return L-&gt;Lindex;
    }
}

int front(List L){
    if(L == NULL){
        printf("List error: calling front()\n");
        exit(1);
    }
    else{
        return (L-&gt;front-&gt;data);
    }
}

int back(List L){
    if(L == NULL){
        printf("List error: calling back()\n");
        exit(1);
    }
    else{
        return(L-&gt;back-&gt;data);
    }

}

int get(List L){
    if(L == NULL){
        printf("List error: calling get()\n");
        exit(1);   
    }
    return (L-&gt;cursor-&gt;data);
}

bool equals(List A, List B){
    // Check if either list is NULL
    if(A == NULL || B == NULL){
        return 0;
    }

    // Check if the lists are valid
    if(A-&gt;length &lt; 0 || B-&gt;length &lt; 0){
        return 0;
    }

    // Check if the lists have the same length
    if (A-&gt;length != B-&gt;length){
        return 0;
    }

    // Check if both lists are empty
    if (A-&gt;length == 0 &amp;&amp; B-&gt;length == 0){
        return 1;
    }

    // Create temporary nodes to iterate through the lists
    Node tempA = A-&gt;front;
    Node tempB = B-&gt;front;

    // Iterate through the lists and compare elements
    while (tempA != NULL &amp;&amp; tempB != NULL){
        if(tempA-&gt;data != tempB-&gt;data){
            return 0;
        }
        // if (tempA-&gt;next == NULL || tempB-&gt;next == NULL) {
        //     break;
        // }
        tempA = tempA-&gt;next;
        tempB = tempB-&gt;next;
    }

    // If we reach this point, the lists are equal
    return 1;
}

//manipulation procedures

void clear(List L){
    if(L == NULL){
        printf("List error: calling clear()\n");
        exit(1);
    }
    while(L-&gt;back != NULL){
        deleteBack(L);
    }
}

void moveFront(List L){
    if(L == NULL){
        printf("List error: calling moveFront()\n");
        exit(1);
    }
    if(L != NULL){
        if(L-&gt;length&gt;0)
        {
            L-&gt;cursor = L-&gt;front;
            L-&gt;Lindex=0;
        }
    }

}

void moveBack(List L){
    //printf("Entering moveBack function\n");
    if(L == NULL){
        //printf("List Error: calling moveBack on NULL\n");
        return;

    }
    if (L != NULL &amp;&amp; L-&gt;length &gt; 0){
        //printf("Moving cursor to back of list\n");
        L-&gt;cursor = L-&gt;back;
        L-&gt;Lindex=L-&gt;length-1;
        //printf("Updated cursor index: %d\n", L-&gt;Lindex);
       
    }
    //printf("Exiting moveBack function\n");

}
void movePrev(List L){
    if (L == NULL){
        L-&gt;Lindex = -1;   
        return; 
    }
    if (L -&gt; cursor != NULL &amp;&amp; L-&gt;cursor-&gt;prev != NULL){
        L-&gt;cursor = L-&gt;cursor-&gt;prev;
        if(L-&gt;Lindex &gt; 0){
            L-&gt;Lindex--;
        }
    }
    else if (L-&gt;cursor == L-&gt;front){ //adjust new cursor
        L-&gt;cursor = NULL;
        L-&gt;Lindex=-1;
    }
}

void moveNext(List L){
    if(L== NULL){
        L-&gt;Lindex = -1;
        return;
    }
    if (L != NULL) {
        if (L-&gt;cursor != NULL){
            if(L-&gt;cursor != L-&gt;back){
                L-&gt;cursor = L-&gt;cursor-&gt;next;
                if(L-&gt;Lindex &lt; length(L) - 1){
                    L-&gt;Lindex++;
                }
        }
        else if(L-&gt;cursor-&gt;next== NULL){ //adjust cursor
            L-&gt;cursor = NULL;
            L-&gt;Lindex=-1;
            }   
        }
    }
}

void prepend(List L, int data){
    if(L== NULL){
        printf("List error: calling prepend()\n");
        exit(1);
    }
    if (L != NULL){
        if(L-&gt;length != 0){
            Node temp = newNode(data);
            L-&gt;front-&gt;prev = temp;
            temp-&gt;next = L-&gt;front;
            L-&gt;front = temp;
            L-&gt;length++;
            L-&gt;Lindex++;
        } else {
            Node temp = newNode(data);
            L-&gt;front = L-&gt;back = temp;
            L-&gt;length++;
        }
    }

}
void append(List L, int data){
    if(L== NULL){
        printf("List error: calling append()\n");
        exit(1);
    }
    if (L != NULL){
        if(L-&gt;length != 0){
            Node temp = newNode(data);
            L-&gt;back-&gt;next = temp;
            temp-&gt;prev = L-&gt;back;
            L-&gt;back = temp;
            L-&gt;length++;
        } else{
            Node temp = newNode(data);
            L-&gt;front = L-&gt;back = temp;
            L-&gt;length++;
        }            
    }
}

void insertBefore(List L, int x){
    if(L == NULL)
    {
        printf("List Error: calling insetBefore()\n");
        exit(1);
    }
    if (L != NULL)
    {
        if (L-&gt;cursor == L-&gt;front) // Can append if only a single element in list.
        {
            prepend(L, x);
        }
        else
        {
            Node temp = newNode(x);
            temp-&gt;next = L-&gt;cursor;
            temp-&gt;prev = L-&gt;cursor-&gt;prev;
            L-&gt;cursor-&gt;prev-&gt;next = temp;
            L-&gt;cursor-&gt;prev = temp;
            L-&gt;length++;
            if (L-&gt;cursor != NULL)
            {
                L-&gt;Lindex++;
            }
        }
    }


}
void insertAfter(List L, int x){
    if(L == NULL)
    {
        printf("List Error: NULL\n");
        exit(1);
    }
    if (L != NULL)
    {
        if (L-&gt;cursor == L-&gt;back) // Can append if theres only a single element in list.
        {
            append(L, x);
        }
        else
        {
            Node temp = newNode(x);
            temp-&gt;prev = L-&gt;cursor;
            temp-&gt;next = L-&gt;cursor-&gt;next;
            L-&gt;cursor-&gt;next-&gt;prev = temp;
            L-&gt;cursor-&gt;next = temp;
            L-&gt;length++;
            if (L-&gt;cursor != NULL)
            {
                L-&gt;Lindex++;
            }
        }
    }


}

void deleteFront(List L)
{
    if (L == NULL)
    {
        printf("List Error: calling deleteFront() on NULL List reference\n");
        exit(1);
    }

    if (L-&gt;length &lt;= 0)
    {
        printf("List Error: calling deleteFront() on an empty List\n");
        exit(1);
    }

    Node N = L-&gt;front;

    // Case 1: Cursor is at the front
    if (L-&gt;cursor == L-&gt;front)
    {
        L-&gt;cursor = NULL;   // Cursor becomes undefined
        L-&gt;Lindex = -1;     // Index is now undefined
    }
    // Case 2: Cursor is not at the front, but still in the list
    else if (L-&gt;Lindex != -1)
    {
        L-&gt;Lindex--;  // Adjust the index of the cursor
    }

    // Case 3: List has more than one element
    if (L-&gt;length &gt; 1)
    {
        L-&gt;front = L-&gt;front-&gt;next;   // Move front to the next node
        L-&gt;front-&gt;prev = NULL;
    }
    else
    {
        L-&gt;front = L-&gt;back = NULL;  // List becomes empty
    }

    freeNode(&amp;N);  // Free the old front node
    L-&gt;length--;
}

void deleteBack(List L) {
    if (L == NULL) {
        printf("List Error: calling deleteBack on NULL List reference\n");
        exit(1);
    }

    if (L-&gt;length &lt;= 0) {
        printf("List Error: calling deleteBack on an empty List\n");
        exit(1);
    }

    Node N = L-&gt;back;

    // Case 1: If the cursor is at the back, make the cursor undefined
    if (L-&gt;cursor == L-&gt;back) {
        L-&gt;cursor = NULL;
        L-&gt;Lindex = -1;
    }
    // Case 2: If the cursor is before the back, no need to adjust the index
    else if (L-&gt;Lindex != -1) {
        // No change needed to Lindex unless you are adjusting for other operations
    }

    // Case 3: List has more than one element
    if (L-&gt;length &gt; 1) {
        L-&gt;back = L-&gt;back-&gt;prev;  // Move back pointer to the previous node
        L-&gt;back-&gt;next = NULL;
    } else {
        L-&gt;front = L-&gt;back = NULL;  // List becomes empty
        L-&gt;cursor = NULL;  // Cursor becomes undefined
        L-&gt;Lindex = -1;
    }

    freeNode(&amp;N);  // Free the old back node
    L-&gt;length--;
}

void delete(List L) {
    if (L == NULL) {
        printf("List Error: calling delete() on NULL List reference\n");
        exit(1);
    }

    if (L-&gt;cursor == NULL || L-&gt;length == 0) {
        printf("List Error: calling delete() on an empty List or with no cursor\n");
        exit(1);
    }

    Node N = L-&gt;cursor;

    // Case 1: Cursor is at the front, use deleteFront
    if (L-&gt;cursor == L-&gt;front) {
        deleteFront(L);
    }
    // Case 2: Cursor is at the back, use deleteBack
    else if (L-&gt;cursor == L-&gt;back) {
</font>        deleteBack(L);
    }
    // Case 3: Cursor is somewhere in the middle
    else {
<a name="1"></a><font color="#00FF00"><a href="match12-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_15.gif"/></a>

        L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
        L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
        freeNode(&amp;N);
        L-&gt;cursor = NULL;   // After deletion, cursor becomes undefined
        L-&gt;Lindex = -1;     // Set index to -1 to indicate undefined
        L-&gt;length--;
    }
}



//other opers

void printList(FILE* out, List L){
    if(L == NULL)
    {
        printf("List Error: NULL\n");
        exit(1);
    }
    Node N = NULL;
    if (L != NULL)
    {
        for (N = L-&gt;front; N != NULL; N = N-&gt;next)
        {
            fprintf(out,"%d ", N-&gt;data);
        }
        fprintf(out,"\n");
    }

}
List copyList(List L){
    if(L == NULL)
    {
        printf("List Error: calling copyList() on NULL\n");
        exit(1);
    }
    List copiedList = newList();
    Node temp = L-&gt;front;
    while (temp != NULL)
    {
        append(copiedList, temp-&gt;data);
        temp = temp-&gt;next;
    }
    copiedList-&gt;cursor = NULL;
    copiedList-&gt;Lindex = -1;
    return copiedList;
}
List concatList(List A, List B){
    	if(A== NULL || B== NULL) {
		printf("List Error: calling concatList() on NULL List reference\n");
		exit(1);
	}
	else {
		List returnList = newList();
		Node NodeA = A-&gt;front;
		for(int i=0; i&lt;length(A); i++) {
			append(returnList, NodeA-&gt;data);
			NodeA = NodeA-&gt;next;
		}
		Node NodeB = B-&gt;front;
		for(int i=0; i&lt;length(B); i++) {
			append(returnList, NodeB-&gt;data);
			NodeB = NodeB-&gt;next;
</font>		}
		return returnList;
	}


}</pre>
</body>
</html>
