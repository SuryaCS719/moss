<html>
<head>
<title>/fall24/jkaur81/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/arkolli/pa1/List.c<p></p><pre>
//------------------------------------------------------------------------------
// Anshul Kolli
// arkolli
// 2024 Fall CSE101 PA1 
// List.c for CSE 101 Programming Assignment 1
//
// This file defines a doubly-linked list ADT with a cursor for traversing
// and manipulating the list. This List ADT will be used to store and manipulate
// indices of strings in a client program.
//
// Preconditions:
// - The List must be properly initialized and non-null for all operations.
// - List length, cursor, and index constraints should be maintained.
//------------------------------------------------------------------------------

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

// NodeObj: Represents a node in the doubly linked list
typedef struct NodeObj {
    int data;
    struct NodeObj* next;
    struct NodeObj* prev;
} NodeObj;

typedef NodeObj* Node;

// ListObj: Represents the doubly linked list with a cursor
typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int length;
    int index;
} ListObj;

typedef ListObj* List;

//------------------------------------------------------------------------------
// newList
// Creates and returns a new empty List.
// Preconditions: None
//------------------------------------------------------------------------------
<a name="0"></a><font color="#FF0000"><a href="match235-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

List newList(void) {
    List L = malloc(sizeof(ListObj));
    if (L == NULL) {
        fprintf(stderr, "Error: malloc failed in newList\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
    return L;
</font>}

//------------------------------------------------------------------------------
// freeList
// Frees all memory associated with *pL and sets *pL to NULL.
// Preconditions: *pL must not be NULL.
//------------------------------------------------------------------------------
void freeList(List* pL) {
    if (pL != NULL &amp;&amp; *pL != NULL) {
        clear(*pL);
        free(*pL);
        *pL = NULL;
    }
}

//------------------------------------------------------------------------------
// length
// Returns the number of elements in the List.
// Preconditions: L must not be NULL.
//------------------------------------------------------------------------------
int length(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling length() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;length;
}

//------------------------------------------------------------------------------
// index
// Returns the index of the cursor element, or -1 if the cursor is undefined.
// Preconditions: L must not be NULL.
//------------------------------------------------------------------------------
int index(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling index() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;index;
}

//------------------------------------------------------------------------------
// front
// Returns the front element of the List.
// Preconditions: L must not be NULL, and List must be non-empty.
//------------------------------------------------------------------------------
int front(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling front() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0) return L-&gt;front-&gt;data;
    fprintf(stderr, "Error: calling front() on empty List\n");
    exit(EXIT_FAILURE);
}

//------------------------------------------------------------------------------
// back
// Returns the back element of the List.
// Preconditions: L must not be NULL, and List must be non-empty.
//------------------------------------------------------------------------------
int back(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling back() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0) return L-&gt;back-&gt;data;
    fprintf(stderr, "Error: calling back() on empty List\n");
    exit(EXIT_FAILURE);
}

//------------------------------------------------------------------------------
// get
// Returns the cursor element of the List.
// Preconditions: L must not be NULL, List must be non-empty, and cursor must be defined.
//------------------------------------------------------------------------------
int get(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling get() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) return L-&gt;cursor-&gt;data;
    fprintf(stderr, "Error: calling get() when cursor is undefined\n");
    exit(EXIT_FAILURE);
}

//------------------------------------------------------------------------------
// equals
// Returns true if Lists A and B are identical, false otherwise.
// Preconditions: A and B must not be NULL.
//------------------------------------------------------------------------------
bool equals(List A, List B) {
    if (A == NULL || B == NULL) {
        fprintf(stderr, "Error: calling equals() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (A-&gt;length != B-&gt;length) return false;
    Node N = A-&gt;front;
    Node M = B-&gt;front;
    while (N != NULL) {
        if (N-&gt;data != M-&gt;data) return false;
        N = N-&gt;next;
        M = M-&gt;next;
    }
    return true;
}

//------------------------------------------------------------------------------
// clear
// Clears all elements from the List.
// Preconditions: L must not be NULL.
//------------------------------------------------------------------------------
void clear(List L) {
<a name="1"></a><font color="#00FF00"><a href="match235-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

    if (L == NULL) {
        fprintf(stderr, "Error: calling clear() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    while (L-&gt;length &gt; 0) {
        deleteFront(L);
    }
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
}

//------------------------------------------------------------------------------
// moveFront
// Moves the cursor to the front of the List.
// Preconditions: L must not be NULL, and List must be non-empty.
//------------------------------------------------------------------------------
void moveFront(List L) {
</font>    if (L == NULL) {
        fprintf(stderr, "Error: calling moveFront() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;front;
        L-&gt;index = 0;
    }
}

//------------------------------------------------------------------------------
// moveBack
// Moves the cursor to the back of the List.
// Preconditions: L must not be NULL, and List must be non-empty.
//------------------------------------------------------------------------------
void moveBack(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling moveBack() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;back;
        L-&gt;index = L-&gt;length - 1;
    }
}

//------------------------------------------------------------------------------
// movePrev
// Moves the cursor one step toward the front of the List.
// Preconditions: L must not be NULL, and cursor must be defined.
//------------------------------------------------------------------------------
void movePrev(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling movePrev() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursor != NULL) {
        L-&gt;cursor = L-&gt;cursor-&gt;prev;
        if (L-&gt;cursor != NULL) {
            L-&gt;index--;
        } else {
            L-&gt;index = -1;
        }
    }
}

//------------------------------------------------------------------------------
// moveNext
// Moves the cursor one step toward the back of the List.
// Preconditions: L must not be NULL, and cursor must be defined.
//------------------------------------------------------------------------------
void moveNext(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling moveNext() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;cursor != NULL) {
        L-&gt;cursor = L-&gt;cursor-&gt;next;
        if (L-&gt;cursor != NULL) {
            L-&gt;index++;
        } else {
            L-&gt;index = -1;
        }
    }
}

//------------------------------------------------------------------------------
// prepend
// Inserts a new element at the front of the List.
// Preconditions: L must not be NULL.
//------------------------------------------------------------------------------
void prepend(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling prepend() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    Node N = malloc(sizeof(NodeObj));
<a name="2"></a><font color="#0000FF"><a href="match235-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

    if (N == NULL) {
        fprintf(stderr, "Error: malloc failed in prepend\n");
        exit(EXIT_FAILURE);
    }
    N-&gt;data = x;
    N-&gt;next = L-&gt;front;
    N-&gt;prev = NULL;
    if (L-&gt;front != NULL) {
</font>        L-&gt;front-&gt;prev = N;
    } else {
        L-&gt;back = N;
    }
    L-&gt;front = N;
    L-&gt;length++;

    if (L-&gt;index &gt;= 0) {
        L-&gt;index++;
    }
}

//------------------------------------------------------------------------------
// append
// Inserts a new element at the back of the List.
// Preconditions: L must not be NULL.
//------------------------------------------------------------------------------
void append(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling append() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    Node N = malloc(sizeof(NodeObj));
    if (N == NULL) {
        fprintf(stderr, "Error: malloc failed in append\n");
        exit(EXIT_FAILURE);
    }
    N-&gt;data = x;
    N-&gt;next = NULL;
    N-&gt;prev = L-&gt;back;
    if (L-&gt;back != NULL) {
        L-&gt;back-&gt;next = N;
    } else {
        L-&gt;front = N;
    }
    L-&gt;back = N;
    L-&gt;length++;
}

//------------------------------------------------------------------------------
// deleteFront
// Deletes the front element of the List.
// Preconditions: L must not be NULL, and List must be non-empty.
//------------------------------------------------------------------------------
void deleteFront(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling deleteFront() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0) {
        Node temp = L-&gt;front;
        L-&gt;front = L-&gt;front-&gt;next;
        if (L-&gt;front != NULL) {
            L-&gt;front-&gt;prev = NULL;
        } else {
            L-&gt;back = NULL;
        }
        free(temp);
        L-&gt;length--;

        if (L-&gt;index == 0) {
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        } else if (L-&gt;index &gt; 0) {
            L-&gt;index--;
        }
    } else {
        fprintf(stderr, "Error: calling deleteFront() on empty List\n");
        exit(EXIT_FAILURE);
    }
}

//------------------------------------------------------------------------------
// deleteBack
// Deletes the back element of the List.
// Preconditions: L must not be NULL, and List must be non-empty.
//------------------------------------------------------------------------------
void deleteBack(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling deleteBack() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0) {
        Node temp = L-&gt;back;
        L-&gt;back = L-&gt;back-&gt;prev;
        if (L-&gt;back != NULL) {
            L-&gt;back-&gt;next = NULL;
        } else {
<a name="3"></a><font color="#00FFFF"><a href="match235-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

            L-&gt;front = NULL;
        }
        free(temp);
        L-&gt;length--;

        if (L-&gt;index == L-&gt;length) {
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
</font>        }
    } else {
        fprintf(stderr, "Error: calling deleteBack() on empty List\n");
        exit(EXIT_FAILURE);
    }
}

//------------------------------------------------------------------------------
// printList
// Prints the List to the output file.
// Preconditions: L must not be NULL, and out must be a valid file pointer.
//------------------------------------------------------------------------------
void printList(FILE* out, List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling printList() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    Node N = L-&gt;front;
    while (N != NULL) {
        fprintf(out, "%d ", N-&gt;data);
        N = N-&gt;next;
    }
}

//------------------------------------------------------------------------------
// copyList
// Returns a copy of the List.
// Preconditions: L must not be NULL.
//------------------------------------------------------------------------------
List copyList(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling copyList() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    List newL = newList();
    Node N = L-&gt;front;
    while (N != NULL) {
        append(newL, N-&gt;data);
        N = N-&gt;next;
    }
    return newL;
}

//------------------------------------------------------------------------------
// insertBefore
// Inserts a new element before the cursor.
// Preconditions: L must not be NULL, List must be non-empty, and cursor must be defined.
//------------------------------------------------------------------------------
void insertBefore(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling insertBefore() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) {
        Node N = malloc(sizeof(NodeObj));
        if (N == NULL) {
<a name="4"></a><font color="#FF00FF"><a href="match235-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

            fprintf(stderr, "Error: malloc failed in insertBefore\n");
            exit(EXIT_FAILURE);
        }
        N-&gt;data = x;
        N-&gt;next = L-&gt;cursor;
        N-&gt;prev = L-&gt;cursor-&gt;prev;

        if (L-&gt;cursor-&gt;prev != NULL) {
</font>            L-&gt;cursor-&gt;prev-&gt;next = N;
        } else {
            L-&gt;front = N;
        }
        L-&gt;cursor-&gt;prev = N;
        L-&gt;length++;
        L-&gt;index++;
    } else {
        fprintf(stderr, "Error: insertBefore() called on undefined cursor or empty List\n");
        exit(EXIT_FAILURE);
    }
}

//------------------------------------------------------------------------------
// insertAfter
// Inserts a new element after the cursor.
// Preconditions: L must not be NULL, List must be non-empty, and cursor must be defined.
//------------------------------------------------------------------------------
void insertAfter(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling insertAfter() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) {
        Node N = malloc(sizeof(NodeObj));
        if (N == NULL) {
<a name="5"></a><font color="#FF0000"><a href="match235-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

            fprintf(stderr, "Error: malloc failed in insertAfter\n");
            exit(EXIT_FAILURE);
        }
        N-&gt;data = x;
        N-&gt;prev = L-&gt;cursor;
        N-&gt;next = L-&gt;cursor-&gt;next;

        if (L-&gt;cursor-&gt;next != NULL) {
</font>            L-&gt;cursor-&gt;next-&gt;prev = N;
        } else {
            L-&gt;back = N;
        }
        L-&gt;cursor-&gt;next = N;
        L-&gt;length++;
    } else {
        fprintf(stderr, "Error: insertAfter() called on undefined cursor or empty List\n");
        exit(EXIT_FAILURE);
    }
}

//------------------------------------------------------------------------------
// delete
// Deletes the cursor element, making the cursor undefined.
// Preconditions: L must not be NULL, List must be non-empty, and cursor must be defined.
//------------------------------------------------------------------------------
void delete(List L) {
    if (L == NULL) {
        fprintf(stderr, "Error: calling delete() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) {
        Node N = L-&gt;cursor;

        if (N == L-&gt;front) {
            L-&gt;front = N-&gt;next;
            if (L-&gt;front != NULL) {
                L-&gt;front-&gt;prev = NULL;
            } else {
                L-&gt;back = NULL;
            }
        } else if (N == L-&gt;back) {
<a name="6"></a><font color="#00FF00"><a href="match235-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

            L-&gt;back = N-&gt;prev;
            if (L-&gt;back != NULL) {
                L-&gt;back-&gt;next = NULL;
            } else {
                L-&gt;front = NULL;
            }
        } else {
            N-&gt;prev-&gt;next = N-&gt;next;
</font>            N-&gt;next-&gt;prev = N-&gt;prev;
        }

        free(N);
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
        L-&gt;length--;
    } else {
        fprintf(stderr, "Error: delete() called on undefined cursor or empty List\n");
        exit(EXIT_FAILURE);
    }
}
</pre>
</body>
</html>
