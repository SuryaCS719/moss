<html>
<head>
<title>/fall24/zzhan442/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/zzhan442/pa1/List.c<p></p><pre>
/***
 * Zeyuan Zhang
 * zzhan442
 * 2024 Fall CSE101 PA1
 * List.c
 * Implementation for List ADT
 ***/

#include "List.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

<a name="2"></a><font color="#0000FF"><a href="match5-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_15.gif"/></a>

typedef struct NodeObj *Node;

typedef struct NodeObj
{
        ListElement data;
        Node prev;
        Node next;
} NodeObj;

typedef struct ListObj *List;

typedef struct ListObj
{
        int length;
        int index;
        Node cursor;
        Node front;
        Node back;
} ListObj;

Node newNode(ListElement data)
{ // Creates and returns a new Node.
        Node N = malloc(sizeof(NodeObj));
        assert(N != NULL);
        N-&gt;data = data;
        N-&gt;prev = NULL;
        N-&gt;next = NULL;
        return (N);
}

List newList()
{ // Creates and returns a new empty List.
        List L = malloc(sizeof(ListObj));
        assert(L != NULL);
        L-&gt;index = -1;
        L-&gt;length = 0;
        L-&gt;cursor = NULL;
        L-&gt;front = NULL;
        L-&gt;back = NULL;
        return (L);
}

// Frees all heap memory associated with *pN, and sets *pN to NULL.
void freeNode(Node *pN)
{
        if (pN != NULL &amp;&amp; *pN != NULL)
        {
                free(*pN);
                *pN = NULL;
        }
}

// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List *pL)
{
        if (pL != NULL &amp;&amp; *pL != NULL)
        {
                while ((*pL)-&gt;length &gt; 0)
                {
                        deleteFront(*pL); // casusing segmentation fault?
                }
                free(*pL);
                *pL = NULL;
        }
}

// Access functions -----------------------------------------------------------
int length(List L)
{ // Returns the number of elements in L.
        if (L == NULL)
        {
                fprintf(stderr, "calling length() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        return L-&gt;length;
}

int index(List L)
{ // Returns index of cursor element if defined, -1 otherwise.
        if (L == NULL)
        {
                fprintf(stderr, "calling index() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;cursor == NULL)
        {
                return -1;
        }
        return L-&gt;index;
}

int front(List L)
{ // Returns front element of L. Pre: length()&gt;0
        if (L == NULL)
        {
                fprintf(stderr, "calling front() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
</font>        {
                fprintf(stderr, "calling front() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        return (L-&gt;front)-&gt;data;
}

int back(List L)
{ // Returns back element of L. Pre: length()&gt;0
        if (L == NULL)
        {
                fprintf(stderr, "calling back() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling back() on an empty List\n");
                exit(EXIT_FAILURE);
        }
<a name="1"></a><font color="#00FF00"><a href="match5-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_33.gif"/></a>

        return (L-&gt;back)-&gt;data;
}

int get(List L)
{ // Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
        if (L == NULL)
        {
                fprintf(stderr, "calling get() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0 || L-&gt;index == -1)
        {
                fprintf(stderr, "calling get() on an empty List or an undefined cursor\n");
                exit(EXIT_FAILURE);
        }
        return (L-&gt;cursor)-&gt;data;
}

// Returns true if Lists A and B contain the same sequence of elements, returns false otherwise.
bool equals(List A, List B)
{
        if (A == NULL || B == NULL)
        {
                fprintf(stderr, "calling equals() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }

        Node cA = A-&gt;front;
        Node cB = B-&gt;front;

        while (cA != NULL &amp;&amp; cB != NULL)
        {
                if (cA-&gt;data != cB-&gt;data)
                {
                        return false;
                }
                cA = cA-&gt;next;
                cB = cB-&gt;next;
        }

        return (cA == NULL &amp;&amp; cB == NULL);
}

// Manipulation procedures ----------------------------------------------------
void clear(List L)
{ // Resets L to its original empty state.
        if (L == NULL)
        {
                fprintf(stderr, "calling clear() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        while (L-&gt;length &gt; 0)
        {
                deleteFront(L);
        }
        L-&gt;length = 0;
        L-&gt;index = -1;
        L-&gt;cursor = NULL;
        L-&gt;front = NULL;
        L-&gt;back = NULL;
}

void set(List L, int x)
{ // Overwrites the cursor elementâ€™s data with x.
        if (L == NULL)
        { // Pre: length()&gt;0, index()&gt;=0
                fprintf(stderr, "calling set() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0 || L-&gt;index == -1)
        {
                fprintf(stderr, "calling set() on an empty List or an undefined cursor\n");
                exit(EXIT_FAILURE);
        }
        (L-&gt;cursor)-&gt;data = x;
}

void moveFront(List L)
{ // If L is non-empty, sets cursor under the front element, otherwise does nothing.
  // Pre: length()&gt;0
        if (L == NULL)
        {
                fprintf(stderr, "calling moveFront() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling moveFront() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        L-&gt;cursor = L-&gt;front;
        L-&gt;index = 0;
}

void moveBack(List L)
{ // If L is non-empty, sets cursor under the back element, otherwise does nothing.
  // Pre: length()&gt;0
        if (L == NULL)
        {
                fprintf(stderr, "calling moveBack() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling moveBack() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        L-&gt;cursor = L-&gt;back;
        L-&gt;index = (L-&gt;length) - 1;
}

// If cursor is defined and not at front, move cursor one step toward the front of L; if cursor is defined and at
// front, cursor becomes undefined; if cursor is undefined, do nothing. Pre: length()&gt;0
void movePrev(List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling moveFront() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling moveFront() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;index == 0)
        {
                L-&gt;cursor = NULL;
                L-&gt;index = -1;
        }
        else if (L-&gt;index &gt; 0)
        {
                L-&gt;cursor = (L-&gt;cursor)-&gt;prev;
                L-&gt;index--;
        }
}

// If cursor is defined and not at back, move cursor one step toward the back of L; if cursor is defined and at
// back, cursor becomes undefined; if cursor is undefined, do nothing. Pre: length()&gt;0
void moveNext(List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling moveFront() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling moveFront() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;index == L-&gt;length - 1)
        {
                L-&gt;cursor = NULL;
                L-&gt;index = -1;
        }
        else if (L-&gt;index &lt; L-&gt;length - 1)
        {
                L-&gt;cursor = (L-&gt;cursor)-&gt;next;
                L-&gt;index++;
        }
}

// Insert new element into L. If L is non-empty,insertion takes place before front element.
void prepend(List L, int x)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling prepend() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        Node n = newNode(x);
        if (L-&gt;length == 0)
        {
                L-&gt;front = n;
                L-&gt;back = n;
        }
        else
        {
                Node m = L-&gt;front;
                n-&gt;next = m;
                m-&gt;prev = n;
                L-&gt;front = n;
        }
        L-&gt;index++;
        L-&gt;length++;
}

// Insert new element into L. If L is non-empty, insertion takes place after back element.
void append(List L, int x)
</font>{
        if (L == NULL)
        {
                fprintf(stderr, "calling apend() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
<a name="0"></a><font color="#FF0000"><a href="match5-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_41.gif"/></a>

        Node n = newNode(x);
        if (L-&gt;length == 0)
        {
                L-&gt;front = n;
                L-&gt;back = n;
        }
        else
        {
                Node m = L-&gt;back;
                n-&gt;prev = m;
                m-&gt;next = n;
                L-&gt;back = n;
        }
        L-&gt;length++;
}

// Insert new element before cursor. Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling insertBefore() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0)
        {
                Node n = newNode(x);
                if (L-&gt;index == 0)
                {
                        Node c = L-&gt;cursor;
                        n-&gt;next = c;
                        c-&gt;prev = n;
                        L-&gt;front = n;
                }
                else
                {
                        Node c = L-&gt;cursor;
                        Node b = c-&gt;prev;
                        n-&gt;next = c;
                        n-&gt;prev = b;
                        c-&gt;prev = n;
                        b-&gt;next = n;
                }
                L-&gt;index++;
                L-&gt;length++;
        }
        else
        {
                fprintf(stderr, "calling insertBefore() on an empty List or an undefined cursor\n");
                exit(EXIT_FAILURE);
        }
}

// Insert new element after cursor.Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling insertAfter() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0)
        {
                Node n = newNode(x);
                if (L-&gt;index == L-&gt;length - 1)
                {
                        Node c = L-&gt;cursor;
                        n-&gt;prev = c;
                        c-&gt;next = n;
                        L-&gt;back = n;
                }
                else
                {
                        Node c = L-&gt;cursor;
                        Node b = c-&gt;next;
                        n-&gt;next = b;
                        n-&gt;prev = c;
                        b-&gt;prev = n;
                        c-&gt;next = n;
                }
                L-&gt;length++;
        }
        else
        {
                fprintf(stderr, "calling insertAfter() on an empty List or an undefined cursor\n");
                exit(EXIT_FAILURE);
        }
}

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling deleteFront() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling deleteFront() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        Node f = L-&gt;front;
        L-&gt;front = f-&gt;next;
        if (L-&gt;front != NULL)
        {
                L-&gt;front-&gt;prev = NULL;
        }
        else
        {
                L-&gt;back = NULL;
        }
        if (L-&gt;index == 0)
        {
                L-&gt;cursor = NULL;
                L-&gt;index = -1;
        }
        else if (L-&gt;index &gt; 0)
        {
                L-&gt;index--;
        }

        L-&gt;length--;
        freeNode(&amp;f);
}

// Delete the back element. Pre: length()&gt;0
void deleteBack(List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling deleteBack() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0)
        {
                fprintf(stderr, "calling deleteBack() on an empty List\n");
                exit(EXIT_FAILURE);
        }
        Node b = L-&gt;back;
        L-&gt;back = b-&gt;prev;
        if (L-&gt;back != NULL)
        {
                L-&gt;back-&gt;next = NULL;
        }
        else
        {
                L-&gt;front = NULL;
        }
        if (L-&gt;index == L-&gt;length - 1)
        { // situation where cursor at back
                L-&gt;cursor = NULL;
                L-&gt;index = -1;
        }
        L-&gt;length--;
        freeNode(&amp;b);
}

/* Abandoned
void delete(List L){
        if(L==NULL){
                fprintf(stderr, "calling delete() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if(L-&gt;length==0&amp;&amp;L-&gt;index&gt;=0){
                fprintf(stderr, "calling delete() on an empty List or an undefined cursor\n");
                exit(EXIT_FAILURE);
        }
        Node c = L-&gt;cursor;
        (c-&gt;prev)-&gt;next = c-&gt;next;
        (c-&gt;next)-&gt;prev = c-&gt;prev;
        freeNode(&amp;c);
        L-&gt;index = -1;
        L-&gt;length--;
}
*/

// Delete cursor element, making cursor undefined. Pre: length()&gt;0, index()&gt;=0
void delete(List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling delete() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;length == 0 || L-&gt;index == -1)
        {
                fprintf(stderr, "calling delete() on an empty List or an undefined cursor\n");
                exit(EXIT_FAILURE);
        }

        Node c = L-&gt;cursor;

        // cursor at the front
        if (c == L-&gt;front)
        {
                L-&gt;front = c-&gt;next;
                if (L-&gt;front != NULL)
                {
                        L-&gt;front-&gt;prev = NULL;
                }
        }

        // cursor at the back
        if (c == L-&gt;back)
        {
                L-&gt;back = c-&gt;prev;
                if (L-&gt;back != NULL)
                {
                        L-&gt;back-&gt;next = NULL;
                }
        }

        if (c-&gt;prev != NULL)
        {
                c-&gt;prev-&gt;next = c-&gt;next;
        }
        if (c-&gt;next != NULL)
        {
                c-&gt;next-&gt;prev = c-&gt;prev;
        }

        freeNode(&amp;c);
        L-&gt;index = -1;
        L-&gt;cursor = NULL;
        L-&gt;length--;
}

// Other operations -----------------------------------------------------------

// Prints to the file pointed to by out, a string representation of L consisting
// of a space separated sequence of integers, with front on left.
void printList(FILE *out, List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling printList() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        Node current = L-&gt;front;
</font>        while (current != NULL)
        {
                fprintf(out, "%d", current-&gt;data);
<a name="3"></a><font color="#00FFFF"><a href="match5-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

                current = current-&gt;next;
                if (current != NULL)
                {
                        fprintf(out, " ");
                }
        }
}

// Returns a new List representing the same integer
// sequence as L. The cursor in the new list is undefined,
// regardless of the stat
List copyList(List L)
{
        if (L == NULL)
        {
                fprintf(stderr, "calling copyList() on NULL List reference\n");
                exit(EXIT_FAILURE);
        }
        List nL = newList();
</font>        Node current = L-&gt;front;
        while (current != NULL)
        {
                append(nL, current-&gt;data);
                current = current-&gt;next;
        }
        return (nL);
}

List concatList(List A, List B); // Returns a new List which is the concatenation of
                                 // A and B. The cursor in the new List is undefined,
                                 // regardless of the states of the cursors in A and B.
                                 // The states of A and B are unchanged.
</pre>
</body>
</html>
