<html>
<head>
<title>/fall24/wwu107/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/wwu107/pa1/List.c<p></p><pre>
/***
 * Mandy Wu
 * wwu107
 * 2024 Fall CSE101 PA1 
 * List.c 
 * implements the List ADT as defined in List.h, contains the declaration of the Node and List struct
***/


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

//defining the structs
typedef struct NodeObj {
  int data;
  struct NodeObj* next;
<a name="5"></a><font color="#FF0000"><a href="match79-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

  struct NodeObj* prev;
} NodeObj;

typedef NodeObj* Node;

typedef struct ListObj {
  Node front;
  Node back;
  Node cursor;
  int length;
  int cursor_index;
} ListObj;

//constructors - destructors 
List newList(){
  List L = malloc(sizeof(ListObj));
  if (L == NULL){
    fprintf(stderr, "memory allocation error for newList\n");
    exit(EXIT_FAILURE);
  }
  L-&gt;front = NULL;
  L-&gt;back = NULL; 
</font>  L-&gt;cursor = NULL;
  L-&gt;length = 0;
<a name="2"></a><font color="#0000FF"><a href="match79-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_13.gif"/></a>

  L-&gt;cursor_index = -1;
  return L;
 }

void freeList(List* pL){
  if ((pL != NULL)&amp;&amp;(*pL != NULL)){
     Node current = (*pL) -&gt; front;
     while(current != NULL){
       Node temp = current;
       current = current -&gt; next;
       free(temp);
     }
   }

  free(*pL);
  *pL = NULL;
}

//access functions
int length(List L){
   return L-&gt;length;
}

int index(List L){
   return L-&gt;cursor_index;
}

int front(List L){
   if (L-&gt;length==0){
      fprintf(stderr, "List Error: front() called on empty List\n");
      exit(EXIT_FAILURE);
   }
   return L -&gt; front -&gt; data;
}

int back(List L){
   if (L-&gt;length==0){
      fprintf(stderr, "List Error: back() called on empty List\n");
      exit(EXIT_FAILURE);
   }
   return L -&gt; back -&gt; data;
}

int get(List L){
   if ((L-&gt;length ==0) || (L-&gt;cursor_index &lt; 0)){
      fprintf(stderr, "List Error: get() called on undefined cursor, List.c\n");
      exit(EXIT_FAILURE);
   }
   return L -&gt; cursor -&gt; data;
}

bool equals(List A, List B){
   if (A-&gt;length != B-&gt;length){
</font>      return false;
   }
   
   Node C = A-&gt;front;
   Node D = B-&gt;front;

   while (C != NULL){
<a name="0"></a><font color="#FF0000"><a href="match79-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_27.gif"/></a>

      if (C -&gt; data != D -&gt; data){
	 return false;
      }
      C = C-&gt;next;
      D = D-&gt;next;
   }
   return true;
}

//manipulation procedures
void clear(List L){
   if (L==NULL){
     return;
   }
   Node N = L-&gt;front;
   while(N != NULL){
     Node temp = N;
     N = N-&gt;next;
     free(temp);
   }
   L -&gt; front = NULL;
   L -&gt; back = NULL;
   L -&gt; cursor = NULL;
   L -&gt; cursor_index = -1;
   L -&gt; length = 0;
}

void set(List L, int x){
  if ((L-&gt;length &lt;=0) || (L-&gt;cursor_index &lt;0)){
    fprintf(stderr, "List Error: set() called on an empty list\n");
    exit(EXIT_FAILURE);
  }
  L-&gt;cursor-&gt;data = x;
}

void moveFront(List L){
  if (L-&gt; length &lt; 0){
    return;
  }
  L-&gt;cursor = L-&gt;front;
  L-&gt;cursor_index = 0;
}

void moveBack(List L){
  if (L-&gt;length &lt; 0){
    return;
  }
  L-&gt;cursor = L-&gt;back;
  L-&gt;cursor_index = (L-&gt;length)-1;
}

void movePrev(List L){
  if ((L-&gt;cursor != NULL)&amp;&amp;(L-&gt;cursor_index!=0)){
    L-&gt;cursor = L-&gt;cursor-&gt;prev;
    L-&gt;cursor_index--;
  } else if(L-&gt;cursor_index ==0){
    L-&gt;cursor = NULL;
    L-&gt;cursor_index = -1;
  }
}

void moveNext(List L){
  if ((L-&gt;cursor !=NULL)&amp;&amp;(L-&gt;cursor_index != (L-&gt;length)-1)){
    L-&gt;cursor = L-&gt;cursor-&gt;next;
    L-&gt;cursor_index++;
  } else if (L-&gt;cursor_index == L-&gt;length-1){
    L-&gt;cursor = NULL;
    L-&gt;cursor_index = -1;
  }
}

//adds to the front of the list
void prepend(List L, int x){
  Node N = malloc(sizeof(NodeObj));
  N-&gt;data = x;
  N-&gt;next = L-&gt;front;
  N-&gt;prev = NULL;

  if (L-&gt;length &gt; 0) {
    L-&gt;front-&gt;prev = N;
  } else {
    L-&gt;back = N;
  }
  L-&gt;front = N;

  L-&gt;length++;
  if (L-&gt;cursor_index != -1){
    L-&gt;cursor_index ++;
</font>  }
}

void append(List L, int x){
<a name="1"></a><font color="#00FF00"><a href="match79-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_22.gif"/></a>

  Node N = malloc(sizeof(NodeObj));
  N-&gt;data = x;
  N-&gt;next = NULL;
  N-&gt;prev = L-&gt;back;

  if (L-&gt;length&gt;0){
     L-&gt;back-&gt;next = N;
     L-&gt;back = N;
  } else {
     L-&gt;front = N;
     L-&gt;back = N;
  }
  L-&gt;length++;
}

void insertBefore(List L, int x){
  if ((L-&gt;length&lt;=0)||(L-&gt;cursor_index&lt;0)){
     fprintf(stderr,"List Error: calling insertBefore() on an empty list or undefined cursor\n");
     exit(EXIT_FAILURE);
  }
  Node N = malloc(sizeof(NodeObj));
  N-&gt;data = x;
  N-&gt;next = L-&gt;cursor;
  N-&gt;prev = L-&gt;cursor-&gt;prev;

  if (L-&gt;cursor-&gt;prev != NULL){
     L-&gt;cursor-&gt;prev-&gt;next = N;
  } else {
     L-&gt;front = N;
  }

  L-&gt;length++;
  L-&gt;cursor-&gt;prev = N;
  L-&gt;cursor_index++;
}

void insertAfter(List L, int x){
  if ((L-&gt;length &lt;=0) || (L-&gt;cursor_index &lt;0)){
    fprintf(stderr,"List Error: called insertAfter() on empty list or undefined cursor\n");
    exit(EXIT_FAILURE);
  }
  //allocate a new node
  Node N = malloc(sizeof(NodeObj));
  N-&gt;data = x; 
  N-&gt;prev = L-&gt;cursor;
  N-&gt;next = L-&gt;cursor-&gt;next;

  if ((L-&gt;cursor-&gt;next != NULL)||(L-&gt;cursor != L-&gt;back)){
     L-&gt;cursor-&gt;next-&gt;prev = NULL;
  } else {
     L-&gt;back = N;
  }

  L-&gt;length++;
  L-&gt;cursor-&gt;next=N;
}

void deleteFront(List L){
  if (L-&gt;length &lt;= 0){
    fprintf(stderr, "List Error: deleteFront() on an empty list\n");
    exit(EXIT_FAILURE);
  }
  Node N = L-&gt;front;
  if (L-&gt;cursor == L-&gt;front){
</font>     L-&gt;cursor = NULL;
     L-&gt;cursor_index = -1;
  }

  if (L-&gt;length &gt; 1){
<a name="3"></a><font color="#00FFFF"><a href="match79-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

    L-&gt;front = L-&gt;front-&gt;next;
    L-&gt;front-&gt;prev = NULL;
  } else {
    L-&gt;front = L-&gt;back = NULL;
  }

  free(N);
  if (L-&gt;cursor_index != -1){
     L-&gt;cursor_index--;
  }
  L-&gt;length--;

}

void deleteBack(List L){
  if (L-&gt;length &lt;= 0){
     fprintf(stderr, "List Error: deleteback() on empty list\n");
     exit(EXIT_FAILURE);
  }

  Node N = L-&gt;back;
  if (L-&gt;cursor == L-&gt;back){
</font>    L-&gt;cursor = NULL;
    L-&gt;cursor_index = -1;
  }
  if (L-&gt;length &gt; 1){
<a name="4"></a><font color="#FF00FF"><a href="match79-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

    L-&gt;back = L-&gt;back-&gt;prev;
    L-&gt;back-&gt;next = NULL;
  } else {
    L-&gt;front = L-&gt;back = NULL;
  }
  free(N);
  L-&gt;length--;
}

void delete(List L){
   if ((L-&gt;length &lt;=0)||(L-&gt;cursor_index&lt;0)){
     fprintf(stderr,"List Error: delete() called on an undefined cursor\n");
     exit(EXIT_FAILURE);
   }
   Node N = L-&gt;cursor;
   if (L-&gt;cursor == L-&gt;front){
     deleteFront(L);
   } else if (L-&gt;cursor == L-&gt;back){
</font>     deleteBack(L);
   } else {
     L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
     L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
     free(N);
     L-&gt;length--;
   }
   L-&gt;cursor = NULL;
   L-&gt;cursor_index = -1;
}

//other operations
void printList(FILE* out, List L){
  Node N = L-&gt;front;
  while (N != NULL){
    fprintf(out, "%d ", N-&gt;data);
    N = N-&gt;next;
  }
}

List copyList(List L){
  List new = newList();
  Node N = L-&gt;front;
  while(N != NULL){
    append(new, N-&gt;data);
    N = N-&gt;next;
  }
  return new;
}


    
</pre>
</body>
</html>
