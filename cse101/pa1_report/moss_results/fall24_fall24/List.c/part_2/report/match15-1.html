<html>
<head>
<title>/fall24/mibanez1/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/mibanez1/pa1/List.c<p></p><pre>
/***
* Marshall Ibanez
* mibanez1
* 2024 Fall CSE101 pa1
* List.c
* Defined the functions in List.h
***/

#include "List.h"

<a name="0"></a><font color="#FF0000"><a href="match15-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef struct NodeObj
{
    ListElement data; // index in an int format
    struct NodeObj* next; //Next node
    struct NodeObj* prev; //Previous node
} NodeObj;

// private Node type
typedef NodeObj* Node;

// private ListObj type
typedef struct ListObj
{
    Node front; //Front node
    Node back; //Back node
    Node current; //Current node
    int length; //Length of list
    int cursor; //Position of cursor
} ListObj;

// Constructors-Destructors ---------------------------------------------------
List newList(void) // Creates and returns a new empty List.
{
    List L = malloc(sizeof(ListObj));
    if (L == NULL)
    {
        exit(EXIT_FAILURE);
    }
    L-&gt;front = NULL;
    L-&gt;current = NULL;
    L-&gt;back = NULL;
    L-&gt;length = 0;
    L-&gt;cursor = -1;
    return L;
}
void freeList(List* pL)
{
    clear(*pL);
    free(*pL);
    *pL = NULL;
    return;
}
int length(List L)
{
    return L-&gt;length;
}
int index(List L)
{
    if (L-&gt;cursor &gt;= 0)
    {
        return L-&gt;cursor;
    }
    return -1;
}
int front(List L)
{
    if (length(L) &lt;= 0)
    {
        return -1;
    }
    return L-&gt;front-&gt;data;
}
int back(List L)
{
    if (length(L) &lt;= 0)
    {
        return -1;
    }
    return L-&gt;back-&gt;data;
}
int get(List L)
{
    if ((length(L) &lt;= 0) || (index(L) &lt; 0))
    {
        return -100;
    }
    return L-&gt;current-&gt;data;
}
bool equals(List A, List B)
{
    if (length(A) != length(B))
    {
        return false;
    }

    if (length(A) &lt;= 0)
    {
        return true;
    }
    
    int cursor_pos_a = index(A);
    int cursor_pos_b = index(B);

    moveFront(A);
    moveFront(B);

    bool is_equal = true;
    for (int i = 0; i &lt; length(A); i++)
    {
        if (get(A) != get(B))
        {
            is_equal = false;
        }
        moveNext(A);
        moveNext(B);
    }

    moveFront(A);
    for (int i = 0; i &lt; cursor_pos_a; i++)
    {
        moveNext(A);
    }
    if (cursor_pos_a == -1)
    {
        A-&gt;current = NULL;
    }

    moveFront(B);
    for (int i = 0; i &lt; cursor_pos_b; i++)
    {
        moveNext(B);
    }
    if (cursor_pos_b == -1)
    {
        B-&gt;current = NULL;
    }
    return is_equal;
}
void clear(List L)
{
    moveFront(L);
    while (length(L) &gt; 0)
    {
        deleteBack(L);
    }
    return;
}
void set(List L, int x) 
{
    if ((length(L) &lt;= 0) || (index(L) &lt; 0))
    {
        return;
    }
    L-&gt;current-&gt;data = x;
    return;
}
void moveFront(List L)
{
    if (length(L) == 0)
    {
        return;
    }
    L-&gt;cursor = 0;
    L-&gt;current = L-&gt;front;
    return;
}
void moveBack(List L)
{
    if (length(L) == 0)
    {
        return;
    }
    L-&gt;cursor = length(L) - 1;
    L-&gt;current = L-&gt;back;
    return;
}
void movePrev(List L)
{
    if (index(L) == -1)
    {
        return;
    }
    
    if ((length(L) == 0) || index(L) == 0)
    {
        L-&gt;cursor = -1;
        return;
    }
    L-&gt;cursor--;
    L-&gt;current = L-&gt;current-&gt;prev;
    return;
}
void moveNext(List L)
{
    if (index(L) == -1)
    {
        return;
    }
    
    if ((length(L) == 0) || (index(L) == length(L) - 1))
    {
        L-&gt;cursor = -1;
        return;
    }

    L-&gt;cursor++;
    L-&gt;current = L-&gt;current-&gt;next;
    return;
}
void prepend(List L, int x)
{
    Node new_node = malloc(sizeof(NodeObj));
    if (new_node == NULL)
    {
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = x;
    new_node-&gt;prev = NULL;
    if (index(L) &gt;= 0)
    {
        L-&gt;cursor++;
    }
    if (length(L) == 0)
    {
        new_node-&gt;next = NULL;
        L-&gt;front = new_node;
        L-&gt;back = new_node;
        L-&gt;length++;
        return;
    }
    new_node-&gt;next = L-&gt;front;
    L-&gt;front-&gt;prev = new_node;
    L-&gt;front = new_node;
    L-&gt;length++;
    return;
}
void append(List L, int x)
{
    Node new_node = malloc(sizeof(NodeObj));
    if (new_node == NULL)
    {
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = x;
    new_node-&gt;next = NULL;
    if (length(L) == 0)
    {
        new_node-&gt;prev = NULL;
        L-&gt;front = new_node;
        L-&gt;back = new_node;
        L-&gt;length++;
        return;
    }
    new_node-&gt;prev = L-&gt;back;
    L-&gt;back-&gt;next = new_node;
    L-&gt;back = new_node;
    L-&gt;length++;
    return;
}
void insertBefore(List L, int x) 
{
    if ((length(L) &lt;= 0) || (index(L) &lt; 0))
    {
        return;
    }

    Node new_node = malloc(sizeof(NodeObj));
    if (new_node == NULL)
    {
        exit(EXIT_FAILURE);
    }
    
    new_node-&gt;data = x;
    new_node-&gt;next = L-&gt;current;
    new_node-&gt;prev = L-&gt;current-&gt;prev;

    // If cursor is at the front, update the front pointer
    if (L-&gt;current == L-&gt;front) {
        L-&gt;front = new_node;
    } else {
        // Update the previous node's next pointer if current is not the first node
        L-&gt;current-&gt;prev-&gt;next = new_node;
    }

    L-&gt;current-&gt;prev = new_node;
    L-&gt;cursor++;
    L-&gt;length++;
    return;
}
void insertAfter(List L, int x)
{
    if ((length(L) &lt;= 0) || (index(L) &lt; 0))
    {
        return;
    }
    Node new_node = malloc(sizeof(NodeObj));
    if (new_node == NULL)
    {
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = x;
    new_node-&gt;prev = L-&gt;current;
    new_node-&gt;next = L-&gt;current-&gt;next;

    if (L-&gt;current == L-&gt;back) 
    {
        L-&gt;back = new_node;
    } else 
    {
        L-&gt;current-&gt;next-&gt;prev = new_node;
    }

    L-&gt;current-&gt;next = new_node;
    L-&gt;length++;
    return;
}
void deleteFront(List L)
{
    if (length(L) &lt;= 0) 
    {
        return;
    }

    // Handle the case where the list has only one element
    if (L-&gt;length == 1) 
    {
        free(L-&gt;front);
        L-&gt;back = NULL;
        L-&gt;front = NULL;
        L-&gt;current = NULL;
        L-&gt;cursor = -1;
        L-&gt;length = 0;
        return;
    }

    Node temp_front = L-&gt;front;  // Store current back node
    L-&gt;front = L-&gt;front-&gt;next;   // Move back to the previous node
    L-&gt;front-&gt;prev = NULL;      // Update the new back's next pointer to NULL
    free(temp_front);           // Free the old back node
    L-&gt;length--;

    // If the cursor was at the back, set it to undefined
    if (index(L) == 0) 
    {
        L-&gt;cursor = -1;
        L-&gt;current = NULL;
        return;
    }
    L-&gt;cursor--;

    return;
}
void deleteBack(List L) // Delete the back element. Pre: length()&gt;0
{
    if (length(L) &lt;= 0) {
        return;
    }

    // Handle the case where the list has only one element
    if (L-&gt;length == 1) {
        free(L-&gt;back);
        L-&gt;back = NULL;
        L-&gt;front = NULL;
        L-&gt;current = NULL;
        L-&gt;cursor = -1;
        L-&gt;length = 0;
        return;
    }

    Node temp_back = L-&gt;back;  // Store current back node
    L-&gt;back = L-&gt;back-&gt;prev;   // Move back to the previous node
    L-&gt;back-&gt;next = NULL;      // Update the new back's next pointer to NULL
    free(temp_back);           // Free the old back node
    L-&gt;length--;

    // If the cursor was at the back, set it to undefined
    if (index(L) == length(L)) {
        L-&gt;cursor = -1;
        L-&gt;current = NULL;
    }

    return;
}
void delete(List L) 
{
    if ((length(L) &lt;= 0) || (index(L) &lt; 0))
    {
        return;
    }
    if (length(L) == 1)
    {
        free(L-&gt;current);
        L-&gt;length--;
        L-&gt;current = NULL;
        L-&gt;back = NULL;
        L-&gt;front = NULL;
        L-&gt;cursor = -1;
        return;
    }

    if (index(L) == 0)
    {
        deleteFront(L);
        L-&gt;cursor = -1;
        return;
    }

    if (index(L) == length(L) - 1)
    {
        deleteBack(L);
        L-&gt;cursor = -1;
        return;        
    }

    // General case: cursor is somewhere in the middle
    Node temp = L-&gt;current;  // Save the current node to be deleted
    L-&gt;current-&gt;prev-&gt;next = L-&gt;current-&gt;next;  // Link the previous node to the next node
    L-&gt;current-&gt;next-&gt;prev = L-&gt;current-&gt;prev;  // Link the next node to the previous node

    free(temp);  // Free the current node
    L-&gt;current = NULL;  // Reset current pointer
    L-&gt;cursor = -1;  // Se t cursor to undefined
    L-&gt;length--;  // Decrease the list length

    return;
}
// Other operations -----------------------------------------------------------
void printList(FILE* out, List L)
{
    int cursor_pos = index(L);
    moveFront(L);

    for (int i = 0; i &lt; length(L); i++)
    {
        fprintf(out, "%d ", get(L));
        moveNext(L);
    }


    moveFront(L);
    for (int i = 0; i &lt; cursor_pos; i++)
    {
        moveNext(L);
    }
    return;
}
List copyList(List L)
{
    List new_list = newList();
    int L_cursor = index(L);
    moveFront(L);
    for (int i = 0; i &lt; length(L); i++)
    {
        append(new_list, get(L));
        moveNext(L);
    }

    moveFront(L);
    for (int i = 0; i &lt; L_cursor; i++)
    {
        moveNext(L);
    }
    new_list-&gt;cursor = -1;
    return new_list;
}
List concatList(List A, List B)
{
    List new_list = copyList(A);
    int L_cursor = index(B);
    moveFront(B);
    for (int i = 0; i &lt; length(B); i++)
    {
        append(new_list, get(B));
        moveNext(B);
    }

    moveFront(B);
    for (int i = 0; i &lt; L_cursor; i++)
    {
        moveNext(B);
    }
    new_list-&gt;cursor = -1;
</font>    return new_list;   
}
</pre>
</body>
</html>
