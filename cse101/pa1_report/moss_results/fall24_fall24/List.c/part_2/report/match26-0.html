<html>
<head>
<title>/fall24/hzliang/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/hzliang/pa1/List.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

#include "List.h"

<a name="0"></a><font color="#FF0000"><a href="match26-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_34.gif"/></a>

List newList(void){
    List L = malloc(sizeof(ListObj));
	if(L == NULL){
        fprintf(stderr,"Memory Allocation error\n");
        exit(1);
	}
    L-&gt;length = 0;
    L-&gt;index = -1;
    L-&gt;front = NULL;                  
    L-&gt;back = NULL;                   
    L-&gt;current = NULL;   
    return L;
}
Node newNode(int data){
    Node N = malloc(sizeof(NodeObj));
	if(N == NULL){
		fprintf(stderr,"Memory Allocation error\n");
	}
    N-&gt;data = data;
    N-&gt;next = NULL;
    N-&gt;prev = NULL;
    return N;
}
void freeList(List *pL) {
    if (pL != NULL &amp;&amp; *pL != NULL) { 
        Node curr = (*pL)-&gt;front; //Start at front of list
        while (curr != NULL) {
            Node temp = curr;         
            curr = curr-&gt;next; 
            free(temp);
        }
        free(*pL);
        *pL = NULL;
    }
}
int length(List L){
    int len = 0;
    if(L != NULL){
        Node curr = L-&gt;front;
        while(curr != NULL)
        {
            len = len + 1;
            curr = curr-&gt;next;
        }
    }
    return len;
}
int index(List L){
    if(L == NULL || L-&gt;current == NULL){
        return -1;
    }
    return L-&gt;index;
}
int front(List L){
    if(L == NULL || L-&gt;length &lt;= 0){
        fprintf(stderr, "List Error: calling front on NULL list\n");
        exit(1);
    }
    return L-&gt;front-&gt;data;
}
int back(List L){
    if(L == NULL || L-&gt;length &lt;= 0){
        fprintf(stderr, "List Error: calling back on NULL list\n");
        exit(1);
    }
		if(L-&gt;length == 0){
			fprintf(stderr, "List Error: calling back on empty list\n");
		}
    return L-&gt;back-&gt;data;
}
int get(List L){
    if(L == NULL || L-&gt;length &lt;= 0 || L-&gt;index &lt; 0){
        fprintf(stderr, "List Error: calling get with undefined cursor\n");
        exit(1);
    }
    return L-&gt;current-&gt;data;
}
bool equals(List A, List B){
    if (A == NULL || B == NULL) {
        return false;
    }

    if (A-&gt;length != B-&gt;length) {
        return false;
    }
    Node la = A-&gt;front;
    Node lb = B-&gt;front;
    bool test = true;
    while(la != NULL &amp;&amp; lb != NULL){
        if(la-&gt;data != lb-&gt;data){
            test = false;
            break;
        }
        la = la-&gt;next;
        lb = lb-&gt;next;
    }
    return test;
}
void clear(List L){
    Node curr = L-&gt;front;
    while(curr != NULL){
        Node temp = curr;
        curr = curr-&gt;next;
        free(temp);
    }
    L-&gt;front = L-&gt;back = L-&gt;current = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
}
void set(List L, int x){
    if(L == NULL || L-&gt;length &lt;= 0 || L-&gt;index &lt; 0){
        fprintf(stderr, "List Error: calling set with undefined cursor\n");
        exit(1);
    }
    L-&gt;current-&gt;data = x;
}
void moveFront(List L){
    if (L != NULL &amp;&amp; L-&gt;length &gt; 0) {
        L-&gt;current = L-&gt;front;
</font>        L-&gt;index = 0;
    }
}
void moveBack(List L){
    if (L != NULL &amp;&amp; L-&gt;length &gt; 0) {
<a name="4"></a><font color="#FF00FF"><a href="match26-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_7.gif"/></a>

        L-&gt;current = L-&gt;back;
        L-&gt;index = L-&gt;length - 1;
    }
}
void movePrev(List L){
    if(L != NULL &amp;&amp; L-&gt;current != NULL){
        if(L-&gt;front == L-&gt;current){
            L-&gt;index = -1;
            L-&gt;current = NULL;
        } else{
            L-&gt;current = L-&gt;current-&gt;prev;
            L-&gt;index--;
        }
    }
}
void moveNext(List L){
    if(L != NULL &amp;&amp; L-&gt;current != NULL){
        if(L-&gt;back == L-&gt;current){
            L-&gt;current-&gt;next = NULL;
            L-&gt;index = -1;
        } else{
            L-&gt;current = L-&gt;current-&gt;next;
            L-&gt;index++;
</font>        }
    }
}
void prepend(List L, int x){
    Node new = newNode(x);
    if(L-&gt;length == 0){
        L-&gt;front = L-&gt;back = new;
    } else{
        new-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = new;
        L-&gt;front = new;
    }
<a name="2"></a><font color="#0000FF"><a href="match26-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_15.gif"/></a>

    L-&gt;length++;
    if(L-&gt;length &gt;= 0){
        L-&gt;index++;
    }
}
void append(List L, int x){
    Node new = newNode(x);
    if(L-&gt;length == 0){
        L-&gt;front = L-&gt;back = new;
    } else{
        L-&gt;back-&gt;next = new;
        new-&gt;prev = L-&gt;back;
        L-&gt;back = new;
    }
    L-&gt;length++;
}
void insertBefore(List L, int x){
    if(L == NULL || L-&gt;length &lt;= 0 || L-&gt;index &lt; 0){
        fprintf(stderr, "List Error: calling insertBefore with undefined cursor\n");
        exit(1);
    }
    if (L-&gt;current == L-&gt;front) {
        prepend(L, x);
    } else {
        Node in = newNode(x);
		if(in == NULL){
			fprintf(stderr,"Memory Allocation error\n");
		}
        in-&gt;next = L-&gt;current;
        in-&gt;prev = L-&gt;current-&gt;prev;
        L-&gt;current-&gt;prev-&gt;next = in;
        L-&gt;current-&gt;prev = in;
        L-&gt;length++;
        L-&gt;index++;
    }
}
void insertAfter(List L, int x) {
    if (L == NULL || L-&gt;length &lt;= 0 || L-&gt;index &lt; 0) {
        fprintf(stderr, "List Error: calling insertAfter with undefined cursor\n");
        exit(1);
    }
    if (L-&gt;current == L-&gt;back){
        append(L, x);
    } else{
        Node in = newNode(x);
        in-&gt;next = L-&gt;current-&gt;next;
</font>        in-&gt;prev = L-&gt;current;
        L-&gt;current-&gt;next-&gt;prev = in;
<a name="1"></a><font color="#00FF00"><a href="match26-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_17.gif"/></a>

        L-&gt;current-&gt;next = in;
        L-&gt;length++;
    }
}

void deleteFront(List L){
    if (L == NULL || L-&gt;length &lt;= 0) {
        fprintf(stderr, "List Error: calling deleteFront on empty or NULL list\n");
        exit(1);
    }
    if (L-&gt;length == 1) {
        free(L-&gt;front);
        L-&gt;front = NULL;
        L-&gt;back = NULL;
		L-&gt;index = -1;
    } else{
        Node temp = L-&gt;front;
        L-&gt;front = L-&gt;front-&gt;next;
		if(L-&gt;current == temp){
			L-&gt;index = -1;
		} else{
			L-&gt;index--;
		}
        free(temp);
    }
    L-&gt;length--;
}
void deleteBack(List L){
    if(L == NULL || L-&gt;length &lt;= 0){
        fprintf(stderr, "List Error: calling deleteBack on empty or NULL list\n");
        exit(1);
    }
    if(L-&gt;length == 1){
        free(L-&gt;front);
        L-&gt;front = NULL;
        L-&gt;back = NULL;
				L-&gt;index = -1;  
        
    } else{
        Node temp = L-&gt;back;
        L-&gt;back = L-&gt;back-&gt;prev;
		L-&gt;back-&gt;next = NULL;
		if(L-&gt;current == temp){
            L-&gt;index = -1;
        }
        free(temp);
    }
    L-&gt;length--;
}
void delete(List L){
    if (L == NULL || L-&gt;length &lt;= 0 || L-&gt;index &lt; 0) {
        fprintf(stderr, "List error: calling delete with undefined cursor\n");
        exit(1);
    }
    if(L-&gt;current == L-&gt;front){
        deleteFront(L);
    } else if(L-&gt;current == L-&gt;back){
        deleteBack(L);
    } else{
</font>        Node temp = L-&gt;current;
<a name="3"></a><font color="#00FFFF"><a href="match26-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_14.gif"/></a>

        temp-&gt;prev-&gt;next = temp-&gt;next;
        temp-&gt;next-&gt;prev = temp-&gt;prev;
        free(temp);
        L-&gt;length--;
        L-&gt;index = -1;
        L-&gt;current = NULL;
    }
}
void printList(FILE* out, List L){
    if (L == NULL) {
        fprintf(stderr, "List Error: calling printList on NULL List\n");
        exit(1);
    }
    Node curr = L-&gt;front; 
    while(curr != NULL){
        fprintf(out, "%d ", curr-&gt;data);
        curr = curr-&gt;next;
    }
    fprintf(out, "\n");
}
List copyList(List L){
		if(L == NULL){
			fprintf(stderr, "List Error: calling copyList on NULL List\n");
		}
    List copy = newList();  
    Node curr = L-&gt;front; 

    while (curr != NULL) {
        append(copy, curr-&gt;data);
        curr = curr-&gt;next;
    }
		copy-&gt;index = -1;
    return copy;
}
List concatList(List A, List B){
     if (A == NULL || B == NULL) {
        fprintf(stderr, "List Error: calling concatList on NULL List\n");
        exit(1);
    }
    List new = newList();
    Node currA = A-&gt;front;
    while(currA != NULL){
        append(new,currA-&gt;data);
        currA = currA-&gt;next;
    }
    Node currB = B-&gt;front;
    while(currB != NULL){
        append(new,currB-&gt;data);
        currB = currB-&gt;next;
    }
    new-&gt;index = -1;
</font>    return new;
}
</pre>
</body>
</html>
