<html>
<head>
<title>/fall24/aanbaner/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/aanbaner/pa1/List.c<p></p><pre>
#include "List.h"

// #define FUNCTION_CALLOUTS

<a name="0"></a><font color="#FF0000"><a href="match1-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_67.gif"/></a>

typedef struct NodeObj* Node;
typedef int NodeData;

typedef struct NodeObj {
    Node nextItem;
    Node prevItem;
    NodeData data;
} NodeObj;

typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int length;
    int index;
} ListObj;

void showListQualities(List L) {
    printf("printing qualities: \n");
    printf("index: %d\n", index(L));
    printf("length: %d\n", length(L));
    printf("front: %d\n", front(L));
    printf("back: %d\n", back(L));
    printf("cursor: %d\n", get(L));
}

void incrementIndex(List L) {
    (L-&gt;index)++;
    if (L-&gt;index &gt;= L-&gt;length) L-&gt;index = -1;
}

void decrementIndex(List L) {
    (L-&gt;index)--;
}

// Constructors-Destructors ---------------------------------------------------

// Creates and returns a new Node
Node newNode(int x) {
#ifdef FUNCTION_CALLOUTS
    printf("newNode() CALLED\n");
#endif
    Node N = (Node) malloc(sizeof(NodeObj));
    N-&gt;data = x;
    N-&gt;nextItem = NULL;
    N-&gt;prevItem = NULL;
    return N;
}

// Creates and returns a new empty List.
List newList(void) {
#ifdef FUNCTION_CALLOUTS
    printf("newList() CALLED\n");
#endif
    List L = (List) malloc(sizeof(ListObj));
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
    return L;
}

// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List* pL) {
#ifdef FUNCTION_CALLOUTS
    printf("freeList() CALLED\n");
#endif
    if (*pL == NULL) {
        fprintf(stderr, "freeList() was passed NULL arg\n");
        exit(1);
    }
    clear(*pL);
    free(*pL);
    *pL = NULL;
}

// Access functions -----------------------------------------------------------

// Returns the number of elements in L.
int length(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("length() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "length() was passed NULL arg\n");
        exit(1);
    }
    return L-&gt;length;
} 

// Returns index of cursor element if defined, -1 otherwise.
int index(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("index() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "index() was passed NULL arg\n");
        exit(1);
    }
    return L-&gt;index;
}

// Returns front element of L. Pre: length()&gt;0
int front(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("front() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "front() was passed NULL arg\n");
        exit(1);
    }
    if (length(L) == 0) {
        fprintf(stderr, "front() was passed a 0 length list\n");
    }
    return L-&gt;front-&gt;data;
} 

// Returns back element of L. Pre: length()&gt;0
int back(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("back() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "back() was passed NULL arg\n");
        exit(1);
    }
    if (length(L) == 0) {
        fprintf(stderr, "back() was passed a 0 length list\n");
        exit(1);
    }
    return L-&gt;back-&gt;data;
} 

// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("get() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "get() was passed a 0 length list\n");
        exit(1);
    }
    if (length(L) == 0) {
        fprintf(stderr, "get() was passed a 0 length list\n");
        exit(1);
    }
    if (index(L) &lt; 0) {
        fprintf(stderr, "get() was passed a &lt;0 index list\n");
        exit(1);
    }
    return L-&gt;cursor-&gt;data;
} 

// Returns true iff Lists A and B contain the same sequence of elements, returns false otherwise.
bool equals(List A, List B) {
#ifdef FUNCTION_CALLOUTS
    printf("equals() CALLED\n");
#endif
    if ((A == NULL) | (B == NULL)) {
        fprintf(stderr, "equals() was passed NULL arg\n");
        exit(1);
    }
    Node tempA = A-&gt;cursor;
    int indexA = A-&gt;index;
    Node tempB = B-&gt;cursor;
    int indexB = B-&gt;index;

    if (length(A) != length(B)) return false; // if the lengths don't match
    // get to the beginning of the list
    moveFront(A);
    moveFront(B);
    // iterate through the list
    while (A-&gt;cursor != NULL) {
        if (get(A) != get(B)) return false; // return false if A and B's data at cursor doesn't match
        moveNext(A);
        moveNext(B);
    }

    A-&gt;cursor = tempA;
    A-&gt;index = indexA;
    B-&gt;cursor = tempB;
    B-&gt;index = indexB;
    
    return true; // return true if all other tests pass
}

// Manipulation procedures ----------------------------------------------------

// Resets L to its original empty state.
void clear(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("clear() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "clear() was passed NULL arg\n");
        exit(1);
    }
    moveFront(L);
    while (L-&gt;cursor != L-&gt;back) {
        moveNext(L);
        free(L-&gt;cursor-&gt;prevItem);
    }
    free(L-&gt;back);
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
} 

// Overwrites the cursor elementâ€™s data with x. Pre: length()&gt;0, index()&gt;=0
void set(List L, int x) {
#ifdef FUNCTION_CALLOUTS
    printf("set() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "set() received NULL arg\n");
        exit(1);
    }
    L-&gt;cursor-&gt;data = x;
}

// If L is non-empty, sets cursor under the front element, otherwise does nothing.
void moveFront(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("moveFront() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "set() received NULL arg\n");
        exit(1);
    }
    if (length(L) &gt; 0) {
        L-&gt;cursor = L-&gt;front;
        L-&gt;index = 0;
    }
}

// If L is non-empty, sets cursor under the back element, otherwise does nothing.
void moveBack(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("moveBack() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "moveBack() received NULL arg\n");
        exit(1);
    }
    if (length(L) &gt; 0) {
        L-&gt;cursor = L-&gt;back;
        L-&gt;index = length(L) - 1;
    }
}

// If cursor is defined and not at front, move cursor one step toward the front of L; if cursor is defined and at front, cursor becomes undefined; if cursor is undefined do nothing
void movePrev(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("movePrev() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "movePrev() received NULL arg\n");
        exit(1);
    }
    if (L-&gt;cursor != NULL) {
        if (L-&gt;cursor == L-&gt;front) L-&gt;cursor = NULL; // if cursor at front, become undefined
        else L-&gt;cursor = L-&gt;cursor-&gt;prevItem; // if cursor not at front, become previous node
        decrementIndex(L);
    }
}

// If cursor is defined and not at back, move cursor one step toward the back of L; if cursor is defined and at back, cursor becomes undefined; if cursor is undefined do nothing
void moveNext(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("moveNext() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "moveNext() received NULL arg\n");
        exit(1);
    }
    if (L-&gt;cursor != NULL) {
        if (L-&gt;cursor == L-&gt;back) L-&gt;cursor = NULL; // if cursor at back, become undefined
        else L-&gt;cursor = L-&gt;cursor-&gt;nextItem; // if cursor not at back, become next node
        incrementIndex(L);
    }
}

// Insert new element into L. If L is non-empty, insertion takes place before front element.
void prepend(List L, int x) {
#ifdef FUNCTION_CALLOUTS
    printf("prepend() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "prepend() received NULL arg\n");
        exit(1);
    }
    Node N = newNode(x);
    if (length(L) != 0) { // if the list is not empty
        N-&gt;nextItem = L-&gt;front;
        L-&gt;front-&gt;prevItem = N;
        L-&gt;front = N;
        (L-&gt;length)++; // increment the length
        incrementIndex(L); // increment the index
    } else { // if length of the list is 0
        L-&gt;front = N;
        L-&gt;back = N;
        (L-&gt;length)++; // increment the length
    }
} 

// Insert new element into L. If L is non-empty, insertion takes place after back element.
void append(List L, int x) {
#ifdef FUNCTION_CALLOUTS
    printf("append() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "append() received NULL arg\n");
        exit(1);
    }
    Node N = newNode(x);
    if (length(L) != 0) { // if L is non-empty
        N-&gt;prevItem = L-&gt;back;
        L-&gt;back-&gt;nextItem = N;
        L-&gt;back = N;
    } else { // if L is empty;
        L-&gt;front = N;
        L-&gt;back = N;
    }
    (L-&gt;length)++; // increment the length
} 

// Insert new element before cursor. Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
#ifdef FUNCTION_CALLOUTS
    printf("insertBefore() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "insertBefore() received NULL arg\n");
        exit(1);
    }
    if (length(L) &lt;= 0) {
        fprintf(stderr, "insertBefore() received arg with length &lt;= 0");
        exit(1);
    }
    if (index(L) &lt; 0) {
        fprintf(stderr, "insertBefore() received arg with index &lt; 0");
        exit(1);
    }
    //create a new Node
    Node N = newNode(x);
    // Set the connections from the new inserted Node
    N-&gt;prevItem = L-&gt;cursor-&gt;prevItem;
    N-&gt;nextItem = L-&gt;cursor;
    // Set the connections from the to-be neighbors of the new inserted Node
    if (L-&gt;cursor-&gt;prevItem != NULL) L-&gt;cursor-&gt;prevItem-&gt;nextItem = N; // if prevItem is not null, set its nextItem to N
    else L-&gt;front = N;
    L-&gt;cursor-&gt;prevItem = N;
    // List is now one element longer
    (L-&gt;length)++;
    // Your cursor is now has one new element behind it. increment index
    incrementIndex(L);
}

// Insert new element after cursor. Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
#ifdef FUNCTION_CALLOUTS
    printf("insertAfter() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "insertAfter() received NULL arg\n");
        exit(1);
    }
    if (length(L) &lt;= 0) {
        fprintf(stderr, "insertAfter() received arg with length &lt;= 0");
        exit(1);
    }
    if (index(L) &lt; 0) {
        fprintf(stderr, "insertAfter() received arg with index &lt; 0");
        exit(1);
    }
    // Create a new Node
    Node N = newNode(x);
    // Set the connections from the new inserted Node
    N-&gt;nextItem = NULL;
    N-&gt;nextItem = L-&gt;cursor-&gt;nextItem;
    N-&gt;prevItem = L-&gt;cursor;
    // Set the connections from the to-be neighbors of the new inserted Node
    if (L-&gt;cursor-&gt;nextItem != NULL) L-&gt;cursor-&gt;nextItem-&gt;prevItem = N;
</font><a name="1"></a><font color="#00FF00"><a href="match1-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_18.gif"/></a>

    else L-&gt;back = N;
    L-&gt;cursor-&gt;nextItem = N;
    // increase length
    (L-&gt;length)++;
} 

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("deleteFront() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "deleteFront() received NULL arg\n");
        exit(1);
    }
    if (length(L) &lt;= 0) {
        fprintf(stderr, "deleteFront() received arg with length &lt;= 0\n");
        exit(1);
    }
    // if cursor pointing to front, set the cursor to undefined
    if (L-&gt;cursor == L-&gt;front) { // if cursor is under the back element
        L-&gt;cursor = NULL; // set cursor to NULL
        L-&gt;index = -1; // set index to -1
    }
    // if there is an item in front of the front element (if the length isn't 1), point its prevItem to NULL
    if (L-&gt;front-&gt;nextItem != NULL) L-&gt;front-&gt;nextItem-&gt;prevItem = NULL;
    else L-&gt;back = NULL;
    // store the second to front node, to become the new front node
    Node temp = L-&gt;front-&gt;nextItem;
    // free up the pointer on L-&gt;front
    free(L-&gt;front);
    // set the front of the list to be the former second to front
    L-&gt;front = temp;
    //update the length and index
    (L-&gt;length)--;
    if (L-&gt;index != -1) decrementIndex(L);
}

// Delete the back element. Pre: length()&gt;0
void deleteBack(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("deleteBack() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "deleteBack() received NULL arg\n");
        exit(1);
    }
    if (length(L) &lt;= 0) {
        fprintf(stderr, "deleteBack() received arg with length &lt;= 0\n");
        exit(1);
    }
    if (L-&gt;cursor == L-&gt;back) { // if cursor is under the back element
        L-&gt;cursor = NULL; // set cursor to NULL
        L-&gt;index = -1; // set index to -1
    }
    // if there is an item behind the back element (if the length isn't 1), point its nextItem to NULL
    if (L-&gt;back-&gt;prevItem != NULL) L-&gt;back-&gt;prevItem-&gt;nextItem = NULL;
    else L-&gt;front = NULL;
    // store the second to back node, to become the new back node
    Node temp = L-&gt;back-&gt;prevItem;
    // free up the pointer on L-&gt;back
    free(L-&gt;back);
    // set the back of the list to be the former second to back
    L-&gt;back = temp;
    // update the length
    (L-&gt;length)--;
}

// Delete cursor element, making cursor undefined. Pre: length()&gt;0, index()&gt;=0
void delete(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("delete() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "delete() received NULL arg\n");
        exit(1);
    }
    if (length(L) &lt;= 0) {
        fprintf(stderr, "delete() received arg with length &lt;= 0\n");
        exit(1);
    }
    if (index(L) &lt; 0) {
        fprintf(stderr, "delete() received arg with index &lt; 0");
        exit(1);
    }
    Node temp = L-&gt;cursor-&gt;prevItem;
    // if there's an item behind the cursor, connect it to the item in front of the cursor
    if (L-&gt;cursor-&gt;prevItem != NULL) L-&gt;cursor-&gt;prevItem-&gt;nextItem = L-&gt;cursor-&gt;nextItem;
</font><a name="2"></a><font color="#0000FF"><a href="match1-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

    else L-&gt;front = L-&gt;front-&gt;nextItem;
    // if there's an item in front of the cursor, connect it to the item behind the cursor
    if (L-&gt;cursor-&gt;nextItem != NULL) L-&gt;cursor-&gt;nextItem-&gt;prevItem = temp;
    else L-&gt;back = L-&gt;back-&gt;prevItem;
    // free up the pointer
    free(L-&gt;cursor);
    // length has decreased
    (L-&gt;length)--;
    // make cursor undefined
    L-&gt;index = -1;
    L-&gt;cursor = NULL;
}

// Other operations -----------------------------------------------------------

// Prints to the file pointed to by out, a string representation of L consisting of a space separated sequence of integers, with front on left.
void printList(FILE* out, List L) {
#ifdef FUNCTION_CALLOUTS
    printf("printList() CALLED\n");
#endif
    if (L == NULL) {
        fprintf(stderr, "printList() received NULL arg\n");
        exit(1);
    }
    // record current state of list
    Node cursorTemp = L-&gt;cursor;
    int indexTemp = index(L);
    // go to the front
    moveFront(L);
    // iterate through the list
    while (L-&gt;cursor != NULL) {
        fprintf(out, "%d ", get(L));
        moveNext(L);
    }
    // restore recorded data
    L-&gt;cursor = cursorTemp;
    L-&gt;index = indexTemp;

} 

// Returns a new List representing the same integer sequence as L. The cursor in the new list is undefined, regardless of the state of the cursor in L. The state of L is unchanged.
List copyList(List L) {
#ifdef FUNCTION_CALLOUTS
    printf("copyList() CALLED\n");
#endif

    if (L == NULL) {
        fprintf(stderr, "copyList() received NULL arg\n");
        exit(1);
    }
    Node cursorTemp = L-&gt;cursor;
    int indexTemp = index(L);
    List L2 = newList();
    moveFront(L);
    while (L-&gt;cursor != NULL) {
        append(L2, get(L));
        moveNext(L);
    }
    L-&gt;cursor = cursorTemp;
    L-&gt;index = indexTemp;
    L2-&gt;cursor = NULL;
    L2-&gt;index = -1;
</font>    return L2;
}

// Helper function for testing -----------------------------------------------------------</pre>
</body>
</html>
