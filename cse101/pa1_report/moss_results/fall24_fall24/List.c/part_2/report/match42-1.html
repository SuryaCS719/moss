<html>
<head>
<title>/fall24/kysrodri/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/kysrodri/pa1/List.c<p></p><pre>


/*********************************************************************************
 * * Kyara Rodriguez
 * * CSE101 PA1 Fall 2024
 * * List.c
 * * Functions needed for Lex.c with doubly linked lists here
 * *********************************************************************************/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include "List.h"

//private Node type
typedef struct NodeObj* Node;

//private NodeObj type
typedef struct NodeObj{
    int data;
    Node prev;
    Node next;
} NodeObj;

//private ListObj type
typedef struct ListObj{
    Node front; //index of the 1st word in the array
    Node back; //index of the last word in the array
    Node cursor;
    int index;
    int length;
<a name="2"></a><font color="#0000FF"><a href="match42-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

} ListObj;

//Constructors and Destructors
//newNode: Returns reference to new Node Object
//and Initializes next and data fields
Node newNode(int nodeData){
    Node N = malloc(sizeof(NodeObj));
    assert(N!=NULL);
    N-&gt;data = nodeData;
    N-&gt;next =N-&gt;prev;
    return(N);
}
//freeNode(): frees heap memory pointed to by *pN
//and sets *pN to NULL
void FreeNode(Node* pN){
    if(pN!=NULL &amp;&amp; *pN!=NULL){
        free(*pN);
        *pN = NULL;
    }
}

//newList
List newList(void){
</font>    List L = malloc(sizeof(ListObj));
    assert(L!=NULL);
    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length=0;
    return(L);
    }
//freeList
//frees all heap memory associated
void freeList(List* pL){
    if(pL!=NULL &amp;&amp; *pL!=NULL){
        clear(*pL);
        free(*pL);
        *pL = NULL;
    }
}
//Access functions--------------------------------
//length(): returns the number of elements in L
int length(List L){
    if(L == NULL){
        printf("List Error: Calling length() on Null List\n");
        exit(EXIT_FAILURE);
    }
    return(L-&gt;length);
}
//index(): returns index of cursor element if defined , -1 otherwise
int index(List L){
    if(L == NULL){
        printf("List Error: Calling index() on Null List \n");
        exit(EXIT_FAILURE);
        }
    return(L-&gt;index);
}
//front(): returns front element of L. Pre-cond: Length()&gt;0
int front(List L){
    if(L==NULL){
        printf("List Error: Calling front() on Null List\n");
        exit(EXIT_FAILURE);
        }
    if(length(L)&lt;=0){
        printf("List Error: Calling front() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    return (L-&gt;front-&gt;data);
}

//back(): returns back element of L. Pre-cond: Length()&gt;0
int back(List L){
    if(L==NULL){
        printf("List Error: Calling back() on Null List\n");
        exit(EXIT_FAILURE);
        }
    if(length(L)&lt;=0){
        printf("List Error: Calling back() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    return (L-&gt;back-&gt;data);
}

//get(): returns back element of L. Pre-cond: Length()&gt;0 index()&gt;=0
int get(List L){
    if(L==NULL){
        printf("List Error: Calling get() on Null List\n");
        exit(EXIT_FAILURE);
        }
    if(length(L)&lt;1){
        printf("List Error: Calling get() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L)&lt;0){
<a name="1"></a><font color="#00FF00"><a href="match42-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_13.gif"/></a>

        printf("List Error: Calling get() on undefined index\n");
        exit(EXIT_FAILURE);
    }
    return (L-&gt;cursor-&gt;data);
}

bool equals(List A, List B){
    if(A==NULL){
        printf("List Error: Calling equals() on Null List\n");
        exit(EXIT_FAILURE);
        }
    if(B==NULL){
        printf("List Error: Calling equals() on Null List\n");
        exit(EXIT_FAILURE);
        }
    if(A-&gt;length==B-&gt;length){
        Node temp_a = A-&gt;front;
        Node temp_b = B-&gt;front;
        while((temp_a!=NULL) &amp;&amp; (temp_b!= NULL)){
            if(temp_a-&gt;data!=temp_b-&gt;data){
                return 0;
            }
            temp_a = temp_a-&gt;next;
            temp_b=temp_b-&gt;next;
        }
        return 1;
    }
    return 0;
}

//manipulation procedures----------------------------------------

//clear(): resets L to its original empty state

void clear(List L){
    if(L==NULL){
        printf("List Error: Calling clear() on NULL list reference\n");
         exit(EXIT_FAILURE);
     }
     Node currentNode = L-&gt;front; //current node which starts at the front
     while(length(L)&gt;0){
         Node nextNode = currentNode-&gt;next; //stores the next node
         free(currentNode); //this frees the current node we're on
         currentNode = nextNode; //Move to the next node in list

         //we have to decrement the list every time to keep track
         L-&gt;length--;
     }
     L-&gt;front = NULL;
     L-&gt;back = NULL;
     L-&gt;cursor = NULL;
     L-&gt;index = -1;
     L-&gt;length = 0;
}
void set(List L, int x){
    if(L== NULL){
        printf("List Error: calling set() on NULL List \n");
        exit(EXIT_FAILURE);
    }
    if(length(L)==0){
        printf("List Error: calling set() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L)&lt;0){
        printf("List Error: set() index is undefined\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursor-&gt;data = x;
}
void moveFront(List L){
</font>    if(L==NULL){
        printf("List Error: calling moveFront() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)&gt;0){
        L-&gt;cursor = L-&gt;front;
        L-&gt;index = 0;
    }
}
void moveBack(List L){
    if(L==NULL){
        printf("List Error: calling moveBack() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if (length(L)&gt;0){
<a name="0"></a><font color="#FF0000"><a href="match42-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_58.gif"/></a>

        L-&gt;cursor = L-&gt;back;
        L-&gt;index = length(L)-1;
    }
}
void movePrev(List L){
    if(L==NULL){
        printf("List Error: calling movePrev() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L) == 0){
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
    }
    if(index(L)&gt;=0){
        L-&gt;cursor = L-&gt;cursor-&gt;prev;
        L-&gt;index--;
    }
}

void moveNext(List L){
    if(L==NULL){
        printf("List Error: calling moveNext() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L) == (length(L)-1)){
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
    }
    if(index(L)&gt;=0){
        L-&gt;cursor = L-&gt;cursor-&gt;next;
        L-&gt;index++;
    }
}

//Insert new element into L  If L is non-empty,insertion takes
//place before the front element
 void prepend(List L, int x){
     if(L == NULL){
         printf("List Error: Calling prepend() on NULL List\n");
         exit(EXIT_FAILURE);
     }
     //create a new temp node
     Node temp = newNode(x);

     if(length(L)==0){
         L-&gt;front = L-&gt;back = temp;
         temp-&gt;prev = NULL;
         temp-&gt;next = NULL;
     }
     else{
         temp-&gt;next = L-&gt;front;
         temp-&gt;prev = NULL;
         L-&gt;front-&gt;prev = temp;
         L-&gt;front = temp;

         if(L-&gt;cursor!= NULL){
             L-&gt;index++;
         }
     }
     L-&gt;length++;
 }
void append(List L, int x){
    if(L==NULL){
        printf("List Error: Calling append() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    Node temp = newNode(x);

    if(length(L)==0){
        //set both front and back to the new node
        L-&gt;front = L-&gt;back = temp;
        temp-&gt;prev = NULL;
        temp-&gt;next = NULL;
    }
    else{
        temp-&gt;prev = L-&gt;back;
        L-&gt;back-&gt;next = temp;
        L-&gt;back = temp;
    }

    L-&gt;length++;
}

//delete the front element pre-cond: length()&gt;0
void deleteFront(List L){
    if(L==NULL){
        printf("List Error: Calling deleteFront() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)&lt;=0){
        printf("List Error: Calling deleteFront() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)==1){
        Node temp = L-&gt; front;
        L-&gt;front = NULL;
        L-&gt;back = NULL;
        FreeNode(&amp;temp);
        temp = NULL;
        if(L-&gt;index&gt;=0){
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
        L-&gt;length--;
    }

    else if(length(L)&gt;1){
        Node temp = L-&gt;front;
        L-&gt;front = L-&gt;front-&gt;next;
        FreeNode(&amp;temp);
        temp = NULL;
        L-&gt;front-&gt;prev = NULL;
        if(index(L) == 0){
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
        else if(index(L)&gt;=1){
            L-&gt;index--;
        }
        L-&gt;length--;
    }
}

void deleteBack(List L){
    if(L==NULL){
        printf("List Error: Calling deleteBack() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)&lt;=0){
        printf("List Error: Calling deleteBacK() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if (length(L)==1){
        Node temp = L-&gt;back;
        L-&gt;back = NULL;
        L-&gt;front = NULL;
        FreeNode(&amp;temp);
        temp = NULL;
        if(L-&gt;index&gt;=0){
            L-&gt;cursor = NULL;
            L-&gt;index= -1;
        }
        
        L-&gt;length--;
    }
    else if(length(L)&gt;1){
        Node temp = L-&gt;back;
        L-&gt;back = L-&gt;back-&gt;prev;
        FreeNode(&amp;temp);
        temp = NULL;
        L-&gt;back-&gt;next = NULL;
        if(index(L)==(length(L)-1)){
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
        
        L-&gt;length--;
    }
}
void insertBefore(List L, int x){
    if(L==NULL){
        printf("List Error: Calling insertBefore() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)&lt;1){
        printf("List Error: Calling insertBefore() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L)&lt;0){
        printf("List Error: Calling insertBefore() on undefined index\n");
        exit(EXIT_FAILURE);
    }
    int current_index = index(L);
    if(current_index == 0){
        prepend(L, x);
    }
    if(current_index &gt; 0){
        Node temp = newNode(x);
        temp-&gt;next = L-&gt;cursor;
        L-&gt;cursor-&gt;prev-&gt;next = temp;
        temp-&gt;prev = L-&gt;cursor-&gt;prev;
        L-&gt;cursor-&gt;prev = temp;
        L-&gt;index++;
        L-&gt;length++;
    }
}
void insertAfter (List L, int x){
    if(L==NULL){
        printf("List Error: Calling insertAfter() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)&lt;1){
        printf("List Error: Calling insertAfter() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L)&lt;0){
        printf("List Error: Calling insertAfter() on undefined index\n");
        exit(EXIT_FAILURE);
        }
        int current_index = index(L);
        if(current_index == (L-&gt;length-1)){
            append(L, x);
        }
        else if((0&lt;=current_index) &amp;&amp; (current_index&lt;(L-&gt;length - 1))){
            Node temp = newNode(x);
            temp-&gt;next = L-&gt;cursor-&gt;next;
            L-&gt;cursor-&gt;next-&gt;prev = temp;
            L-&gt;cursor-&gt;next = temp;
            temp-&gt;prev = L-&gt;cursor;
            L-&gt;length++;
        }
}
void delete(List L){
    if(L==NULL){
        printf("List Error: Calling delete() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    if(length(L)&lt;1){
        printf("List Error: Calling delete() on Empty List\n");
        exit(EXIT_FAILURE);
    }
    if(index(L)&lt;0){
        printf("List Error: Calling delete() on undefined index\n");
        exit(EXIT_FAILURE);
        }
        int current_index = L-&gt;index;
        if(current_index == 0){
            deleteFront(L);
        }
        else if(current_index == (length(L) -1)){
            deleteBack(L);
        }
        else if((current_index&gt;0) &amp;&amp; (current_index&lt; (length(L)-1))){
            Node temp = L-&gt;cursor;
            temp-&gt;next-&gt;prev = temp-&gt;prev;
            temp-&gt;prev-&gt;next = temp-&gt;next;
            FreeNode(&amp;temp);
            L-&gt;length--;
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
}





//Other operations-------------------------------------------------------------------

void printList(FILE* out, List L){
</font>    if(L==NULL){
        printf("List Error: Calling printList() on NULL List\n");
        exit(EXIT_FAILURE);
    }
    Node temp = L-&gt;front;
    while(temp!=NULL){
<a name="3"></a><font color="#00FFFF"><a href="match42-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_3.gif"/></a>

        fprintf(out, "%d ", temp-&gt;data);
        temp=temp-&gt;next;
    }
}



List copyList(List L){
    List copy = newList();
    Node temp = L-&gt;front;
    if(length(L)&gt;0){
        while(temp!=NULL){
            append(copy, temp-&gt;data);
            temp = temp-&gt;next;
        }
    }
    return(copy);
</font>}
</pre>
</body>
</html>
