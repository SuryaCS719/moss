<html>
<head>
<title>/fall24/sskolach/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/sskolach/pa1/List.c<p></p><pre>
//-----------------------------------------------------------------------------
// Saranya Kolachana
// sskolach
// pa1
// List.c
// Implementation file for List ADT
//-----------------------------------------------------------------------------
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include "List.h"


// structs --------------------------------------------------------------------

// private Node type
<a name="6"></a><font color="#00FF00"><a href="match22-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

typedef struct NodeObj* Node;
typedef struct ListObj* List;

// private NodeObj type
typedef struct NodeObj{
   int data;
   Node next;
   Node previous;
} NodeObj;

// private ListObj type
typedef struct ListObj{
   Node front;
   Node back;
   Node cursor;
   int length;
</font>   int cursor_index;
} ListObj;


// Constructors-Destructors ---------------------------------------------------

// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(int data){
   Node N = malloc(sizeof(NodeObj));
   assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;previous = NULL;
   return(N);
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      free(*pN);
      *pN = NULL;
   }
}

// newList()
// Returns reference to new empty List object.
List newList(){
   List L;
<a name="5"></a><font color="#FF0000"><a href="match22-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

   L = malloc(sizeof(ListObj));
   assert( L!=NULL );
   L-&gt;front = L-&gt;back = NULL;
   L-&gt;length = 0;
   L-&gt;cursor = NULL;
   L-&gt;cursor_index = 0;
   return(L);
}

// freeList()
// Frees all heap memory associated with List *pL, and sets *pL to NULL.
void freeList(List* pL){
   if(pL!=NULL &amp;&amp; *pL!=NULL) { 
      while( length(*pL) != 0 ) { 
         clear(*pL); 
</font>      }
      free(*pL);
      *pL = NULL;
   }
}


// Access functions -----------------------------------------------------------
// length()
// Returns the length of L.
int length(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling length() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
<a name="4"></a><font color="#FF00FF"><a href="match22-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

   return(L-&gt;length);
}


// index()
// Returns index of cursor element in List L.
int index(List L) {
   if ( L==NULL ){
      fprintf(stderr, "List Error: calling index() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor != NULL) {
      return (L-&gt;cursor_index); 
   }
   return (-1);
}

// front()
// Returns the value at the front of L.
// Pre: List L is not empty (length() &gt; 0)
int front(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling front() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( length(L) ==0){
      fprintf(stderr, "List Error: calling length() on NULL List reference in function front()\n");
      exit(EXIT_FAILURE);
</font>   }
   return(L-&gt;front-&gt;data);
}

// back()
// Returns the value at the back of L.
// Pre: List L is not empty (length() &gt; 0)
int back(List L){
   if( L==NULL ){
      fprintf(stderr, "List Error: calling back() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if( length(L) ==0){
      fprintf(stderr, "List Error: calling length() on NULL List reference in func back()\n");
      exit(EXIT_FAILURE);
   }
<a name="3"></a><font color="#00FFFF"><a href="match22-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

   return(L-&gt;back-&gt;data);
}


// get()
// Returns the cursor element of L.
// Pre: length()&gt;0, index()&gt;=0
int get(List L) {
   if ( L==NULL ){
      fprintf(stderr, "List Error: calling get() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) &lt;=0 || L-&gt;cursor_index &lt;0) {
      fprintf(stderr, "either length(L) &lt;=0 or L-&gt;cursor_index &lt;0 in get() func\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor != NULL) {
      return (L-&gt;cursor-&gt;data); 
   }
   else{
       fprintf(stderr, "cursor not defined in function get()\n");
       exit(EXIT_FAILURE);
   }
}

// equals()
// Returns true iff Lists A and B contain the same sequence of elements.
bool equals(List A, List B) {
   if( A==NULL || B==NULL ){
      fprintf(stderr, "List Error: either list a or list b are null in equals() func\n");
      exit(EXIT_FAILURE);
   }

   bool eq;
</font>   Node N, M;

   eq = ( A-&gt;length == B-&gt;length );
   N = A-&gt;front;
   M = B-&gt;front;
   while( eq &amp;&amp; N!=NULL){
      eq = ( N-&gt;data==M-&gt;data );
      N = N-&gt;next;
<a name="1"></a><font color="#00FF00"><a href="match22-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_18.gif"/></a>

      M = M-&gt;next;
   }
   return eq;

}



// Manipulation procedures ----------------------------------------------------

// clear()
// Resets L to its original empty state.
void clear(List L) {
    if (L == NULL){
       fprintf(stderr, "List Error: L is null in clear() func\n");
      exit(EXIT_FAILURE);
    }  

    Node current = L-&gt;front;
    Node temp;
    
    while (current != NULL) {
        temp = current;
        current = current-&gt;next;
        freeNode(&amp;temp);
    }

    
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;cursor_index = -1;
}


// set()
// Overwrites the cursor elementâ€™s data with x.
// Pre: length()&gt;0, index()&gt;=0
void set(List L, ListElement x) {
   if( L==NULL ){
      fprintf(stderr, "List Error: L is null in set() func\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) &lt;= 0 || L-&gt;cursor_index &lt;0) {
      fprintf(stderr, "either length(L) &lt;=0 or L-&gt;cursor_index &lt;0 in set() func\n");
      exit(EXIT_FAILURE);
   }
   L-&gt;cursor-&gt;data = x;
} 

// moveFront()
// Sets cursor under the front element
void moveFront(List L) {
   if (L == NULL ) {
      fprintf(stderr, "L is null in moveFront() func\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) != 0) {
      L-&gt;cursor = L-&gt;front;
   }
   L-&gt;cursor_index = 0;

}

// moveBack()
// Sets cursor under the back element
void moveBack(List L) {
   if (L == NULL ) {
      fprintf(stderr, "L is null in moveBack() func\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) != 0) {
      L-&gt;cursor = L-&gt;back;
   }
   L-&gt;cursor_index = length(L)-1;
}

// movePrev()
// Move cursor one step toward the front of List L
void movePrev(List L) {
   if (L == NULL ) {
      fprintf(stderr, "L is null in movePrev() func\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) == 0) {
      fprintf(stderr, "length is 0 in movePrev() func\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor != NULL) {
      if(L-&gt; cursor != L-&gt;front) {
         L-&gt;cursor = L-&gt;cursor-&gt;previous;
         L-&gt;cursor_index--;
      }
      else {
         L-&gt;cursor = NULL;
      }
   }
}

// moveNext()
// Move cursor one step toward the back of List L
void moveNext(List L) {
    if (L == NULL ) {
      fprintf(stderr, "L is null in moveNext() func\n");
      exit(EXIT_FAILURE);
   }
   if (length(L) == 0) {
      fprintf(stderr, "length is 0 in moveNext() func\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;cursor != NULL) {
      if(L-&gt; cursor != L-&gt;back) {
         //L-&gt;cursor-&gt;next = L-&gt;cursor-&gt;next-&gt;next;
         //L-&gt;cursor-&gt;previous = L-&gt;cursor;
         L-&gt;cursor = L-&gt;cursor-&gt;next;
</font>         L-&gt;cursor_index++;
         //printf("the cursor index is: %d", L-&gt;cursor_index++);
      }
      else {
         L-&gt;cursor = NULL;
         L-&gt;cursor_index = -1;
      }
   }
   /*else{
      L-&gt;cursor = NULL;
      L-&gt;cursor_index = -1;
   }
*/
}

// prepend()
// Insert new element at front of List L
void prepend(List L, int x) {
     if (L == NULL ) {
<a name="7"></a><font color="#0000FF"><a href="match22-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

      fprintf(stderr, "L is null in prepend\n");
      exit(EXIT_FAILURE);
   }
   Node N = newNode(x);
   if (length(L) == 0) {
    L-&gt;front = L-&gt;back = N;
   }
   else {
    N-&gt;next = L-&gt;front;
</font>    L-&gt;front-&gt;previous = N;
    L-&gt;front = N;
   }
    
    L-&gt;length++; //increase length by one bc you added one
    L-&gt;cursor_index++;
   }
   
// append()
// Insert new element at back of List L
void append(List L, int x) {
   if (L == NULL ) {
<a name="2"></a><font color="#0000FF"><a href="match22-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

      fprintf(stderr, "L is null in append\n");
      exit(EXIT_FAILURE);
   }
   Node N = newNode(x);
   if (length(L) == 0) {
    L-&gt;front = L-&gt;back = N;
    N-&gt;next = NULL;
   N-&gt;previous = NULL;
   }
   else {
    N-&gt;previous = L-&gt;back;
    L-&gt;back-&gt;next = N;
    N-&gt;next = NULL;
    L-&gt;back = N;
   }

    
    L-&gt;length++; //increase length by one bc you added one
}
   
// insertBefore()
// Insert new element before cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
    if (L == NULL || L-&gt;cursor == NULL) {
      fprintf(stderr, "L is null or L-&gt;cursor == null in insertBefore()\n");
      exit(EXIT_FAILURE);
   }
   
  // if (index(L)&gt;=0 &amp;&amp; length(L) &gt; 0) {
      if (L-&gt;cursor-&gt;previous ==NULL) {
         prepend(L, x);
      }
      else {
         Node N = newNode(x);
            if (N == NULL) {
               fprintf(stderr, "Failed to create new node\n");
               exit(EXIT_FAILURE);
            }
      N-&gt;next = L-&gt;cursor;
      N-&gt;previous = L-&gt;cursor-&gt;previous;
      L-&gt;cursor-&gt;previous-&gt;next = N;
</font>      L-&gt;cursor-&gt;previous = N;
<a name="0"></a><font color="#FF0000"><a href="match22-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_38.gif"/></a>

      L-&gt;length++;
      
      L-&gt;cursor_index++;
      }
      
//freeNode(&amp;N);
  // }
}

// insertAfter()
// Insert new element after cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
    if (L == NULL || L-&gt;cursor == NULL) {
      fprintf(stderr, "L is null or L-&gt;cursor == null in insertAfter()\n");
      exit(EXIT_FAILURE);
   }
   
      if (L-&gt;cursor-&gt;next ==NULL) {
         append(L, x);
      }
      else {
      Node N = newNode(x);
   if (N == NULL) {
        fprintf(stderr, "Failed to create new node in insertAfter\n");
        exit(EXIT_FAILURE);
    }
         N-&gt;next = L-&gt;cursor-&gt;next;
      N-&gt;previous = L-&gt;cursor;
      L-&gt;cursor-&gt;next-&gt;previous = N;
      L-&gt;cursor-&gt;next = N;
      L-&gt;length++;
      //L-&gt;cursor_index++;
      }
      
}

// deleteFront()
// Delete the front element. 
// Pre: length()&gt;0
void deleteFront(List L){ 
   if (L == NULL || length(L)&lt;=0) {
      fprintf(stderr, "L is null or length &lt;= 0 in deletefront()\n");
      exit(EXIT_FAILURE);
   }
   
   //List only has 1 element
   if(L-&gt;back == L-&gt;front) {
      free(L-&gt;front);
      L-&gt;back = L-&gt;front = NULL;
      if (L-&gt;cursor !=NULL) {
         L-&gt;cursor =NULL;
         L-&gt;cursor_index = -1;
      }
   }
   else {
      Node oldFront = L-&gt;front;
      L-&gt;front = L-&gt;front-&gt;next; // Move front to the next node
      L-&gt;front-&gt;previous = NULL; // Update the new front node's previous pointer
      free(oldFront);
   }
   //if (L-&gt;cursor !=NULL) {
      //if (L-&gt;cursor == L-&gt;front) {
      if(L-&gt;cursor_index &lt;= 0){
         L-&gt;cursor = NULL;
         L-&gt;cursor_index = -1;
      }
      //}
      else if (L-&gt;cursor_index &gt; 0) {
         L-&gt;cursor_index--;
      }
   //}
   
   
 L-&gt;length--;
}

// deleteBack()
// Delete the back element. 
// Pre: length()&gt;0
void deleteBack(List L){
   if (L == NULL || length(L)&lt;=0) {
      fprintf(stderr, "L is null or length &lt;= 0 in deleteback()\n");
      exit(EXIT_FAILURE);
   }
   //List only has 1 element
   if(L-&gt;back == L-&gt;front) {
      free(L-&gt;back);
      L-&gt;back = L-&gt;front = NULL;
   }
   else {
      Node oldBack = L-&gt;back;
      L-&gt;back = L-&gt;back-&gt;previous; // Move front to the next node
      L-&gt;back-&gt;next = NULL; // Update the new front node's previous pointer
      free(oldBack);
   }

   if (L-&gt;cursor_index == L-&gt;length-1) {
         L-&gt;cursor = NULL;
         L-&gt;cursor_index = -1;
   }
   /*if (L-&gt;cursor !=NULL) {
      if (L-&gt;cursor == L-&gt;back) { //|| L-&gt;cursor_index == L-&gt;length-1) {
         L-&gt;cursor = NULL;
         L-&gt;cursor_index = -1;
      
      }
   }
   */
 L-&gt;length--;
}

// delete()
// Delete the cursor element
// Pre: length()&gt;0, index()&gt;=0
void delete(List L){ 
   if (L == NULL || length(L)&lt;=0 || index(L) &lt;0) {
      fprintf(stderr, "L is null or length &lt;= 0 or index &lt; 0 in delete()\n");
      exit(EXIT_FAILURE);
   }
   //if cursor is defined
   if (L-&gt;cursor !=NULL) {
   if (L-&gt;front == L-&gt;back) { //if there is only one element
      free(L-&gt;front); 
      L-&gt;front = L-&gt;back = NULL;
   }
   else {
     
         if (L-&gt;cursor == L-&gt;front) {
            deleteFront(L);
            return;
         }
         else if (L-&gt;cursor == L-&gt;back) {
            deleteBack(L);
            return;
         }
         else {
            L-&gt;cursor-&gt;previous-&gt;next = L-&gt;cursor-&gt;next;
            L-&gt;cursor-&gt;next-&gt;previous = L-&gt;cursor-&gt;previous;
         }
         free(L-&gt;cursor);
         
         
   }
      L-&gt;cursor = NULL;
      L-&gt;cursor_index = -1;
      L-&gt;length--;
   }




}



// Other Functions ------------------------------------------------------------

// printList()
// Prints a string representation of L consisting of a space separated list 
// of ints to stdout.
void printList(FILE* out, List L){


   if( L==NULL || out == NULL){
      fprintf(stderr, "L is null or file is null in printList()\n");
      exit(EXIT_FAILURE);
   }
   Node current = L-&gt;front;
   while (current != NULL ) {
      fprintf(out, "%d", current-&gt;data);
      current = current-&gt;next;
      if (current != NULL) {
         fprintf(out, " ");
      }
   }

}

// equals()
// Returns true if A is same int sequence as B, false otherwise.


// copyList()
// Returns a new List representing the same integer sequence as L
List copyList(List L) {
   if( L==NULL){
      fprintf(stderr, "L is null in copyList()\n");
      exit(EXIT_FAILURE);
   }
   List newL = newList();
   int start_index = L-&gt;cursor_index;
   Node N = L-&gt;cursor;
   moveFront(L);
   while( index(L)&gt;=0 ){
      int x = get(L);
      //N = newNode(x)
      append(newL, x);
      moveNext(L);
   }
   if (start_index &gt;= 0) {
      L-&gt;cursor_index = start_index;
      L-&gt;cursor = N;
      //freeNode(&amp;N);
   }
   /*L-&gt;cursor_index = start_index;
   L-&gt;cursor = N;
   freeNode(&amp;N);*/
return newL;
}

// concatList()
// Returns a new List which is the concatenation of A and B. 
List concatList(List A, List B) {
   if( A==NULL || B == NULL){
      fprintf(stderr, "A or B is null in concatList()\n");
      exit(EXIT_FAILURE);
   }
   List cList = copyList(A);
   moveFront(B);
   while( index(B)&gt;=0 ){
      int x = get(B);
      //N = newNode(x)
      append(cList, x);
      moveNext(B);
</font>   }
   return cList;
}</pre>
</body>
</html>
