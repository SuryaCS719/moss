<html>
<head>
<title>/fall24/jidy/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/jidy/pa1/List.c<p></p><pre>
//
// Name: John Francis Dy
// CruzID: jidy
// Assignment: pa1
//
//
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

#define MAX_LEN 300

<a name="3"></a><font color="#00FFFF"><a href="match78-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

typedef struct NodeObj* Node;

typedef struct ListObj* List;

typedef struct NodeObj{
   int data;
   Node prev;
   Node next;

} NodeObj;

typedef struct ListObj{
   Node front;
   Node back;
   Node cursor;
   int length;
   int cursorIndex;
} ListObj;
// Constructors-Destructors

Node newNode(int data)
{
   Node N = malloc(sizeof(NodeObj));
   assert ( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   return(N);
}

List newList(void)
{
   List L;
   L = malloc(sizeof(ListObj));
   assert( L!=NULL );
   L -&gt; front = NULL;
   L -&gt; back = NULL;
   L -&gt; cursor = NULL;
</font>   L -&gt; length = 0;
<a name="2"></a><font color="#0000FF"><a href="match78-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_13.gif"/></a>

   L -&gt; cursorIndex = -1;
   return(L);
}

void freeList(List* pL)
{
   if(pL!=NULL &amp;&amp; *pL!=NULL)
   {
       while( !(length(*pL) == 0) )
       {
           deleteFront(*pL);
       }
       free(*pL);
       *pL = NULL;
   }
}

void freeNode(Node* pN)
{
   if ( pN!=NULL &amp;&amp; *pN!=NULL )
   {
       free(*pN);
       *pN = NULL;
   }
}

// Access functions
int length(List L)
{
   if ( L == NULL )
   {
       printf("List Error: calling length() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }
   return L -&gt; length;
}

int index(List L)
{
   if ( L-&gt;cursor != NULL )
   {
       return L -&gt; cursorIndex;
   }
   return -1;
}

int front(List L)
{
   return L -&gt; front -&gt; data;
}

int back(List L)
{
   return L -&gt; back -&gt; data;
}

int get(List L)
{
   if ( L == NULL )
   {
       printf("List Error: calling get() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }
   if ( L-&gt;length &lt;= 0)
   {
       printf("List Error: calling get() on an empty list\n");
       exit(EXIT_FAILURE);
   }
   if ( L-&gt;cursorIndex &lt; 0 )
   {
       printf("List Error: calling get() on a List with a nonexistent cursor\n");
       exit(EXIT_FAILURE);
   }
	
   return L -&gt; cursor -&gt; data;
</font>}

bool equals(List A, List B)
{
   if ( A==NULL || B==NULL )
   {
       printf("Queue Error: calling equals() on NULL List Reference\n");
       exit(EXIT_FAILURE);
   }
   bool eq;
   Node N, M;

   eq = (A-&gt;length == B-&gt;length);
   N = A-&gt;front;
   M = B-&gt;front;
   while ( eq &amp;&amp; N!= NULL )
   {
<a name="1"></a><font color="#00FF00"><a href="match78-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

       eq = ( N-&gt;data==M-&gt;data );
       N = N-&gt;next;
       M = M-&gt;next;
   }

   return eq;
   
}


// Manipulation Procedures

void clear(List L)
{
   while (L -&gt; length &gt; 0)
   {
       deleteFront(L);
   }	   
   	
}

void set(List L, int x)
{
   L -&gt; cursor -&gt; data = x;
}

void moveFront(List L) // check that cursor and list aren't null
{
   L -&gt; cursor = L -&gt; front;
   L -&gt; cursorIndex = 0;
}

void moveBack(List L)
{
   L -&gt; cursor = L -&gt; back;
   L -&gt; cursorIndex = L -&gt; length - 1;
}

void movePrev(List L)
{
   L -&gt; cursor = L -&gt; cursor -&gt; prev;
   L -&gt; cursorIndex = L -&gt; cursorIndex - 1;
}

void moveNext(List L)
{
   L -&gt; cursor = L -&gt; cursor -&gt; next;

   if (L -&gt; cursor == NULL)
   {
       L -&gt; cursorIndex = -1;
   } else {
       L -&gt; cursorIndex = L -&gt; cursorIndex + 1;
   }
}

void prepend(List L, int x)
{

   if ( L==NULL )
   {
       printf("List Error: calling prepend() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }
   
   Node N = newNode(x);

   if (L -&gt; length == 0)
</font>   {
       L-&gt;front = L-&gt;back = N;
   } else {
       N-&gt;next = L-&gt;front;
       L-&gt;front-&gt;prev = N;
       L-&gt;front = N;
   }
<a name="4"></a><font color="#FF00FF"><a href="match78-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

   L-&gt;length++;
   if (L -&gt; cursorIndex &gt;= 0)
   {
	L -&gt; cursorIndex++;
   }

}

void append(List L, int x)
{
   Node N = newNode(x);
	
   if ( L==NULL )
   {
       printf("List Error: calling append() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }

   if (L -&gt; length == 0)
   {
       L-&gt;front = L-&gt;back = N;
   } else {
       L-&gt;back-&gt;next = N;
</font>       N -&gt; prev = L -&gt; back;
<a name="0"></a><font color="#FF0000"><a href="match78-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_45.gif"/></a>

       L-&gt;back = N;
   }
   L-&gt;length++;

}

void insertBefore(List L, int x)
{

   if ( L==NULL )
   {
       printf("List Error: calling insertBefore() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }

   if ( L -&gt; length == 0 )
   {
       printf("List Error: calling insertBefore() on List of length 0\n");
       exit(EXIT_FAILURE);
   }

   if ( L -&gt; cursorIndex &lt; 0 || L -&gt; cursor == NULL )
   {
       printf("List Error: calling insertBefore() on List with cursor index less than 0\n");
       exit(EXIT_FAILURE);
   }
   
   if (L-&gt;cursorIndex == 0)
   {
       prepend(L, x);
       return;
   }
   Node N = newNode(x);
   L-&gt;cursor-&gt;prev-&gt;next = N;
   N-&gt;prev = L-&gt;cursor-&gt;prev;
   N-&gt;next = L-&gt;cursor;
   L-&gt;cursor-&gt;prev = N;
   L-&gt;cursorIndex++;
   L-&gt;length++;
}

void insertAfter(List L, int x)
{
   if ( L==NULL )
   {
       printf("List Error: calling insertAfter() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }

   if ( L -&gt; length == 0 )
   {
       printf("List Error: calling insertAfter() on List of length 0\n");
       exit(EXIT_FAILURE);
   }

   if ( L -&gt; cursorIndex &lt; 0 )
   {
       printf("List Error: calling insertAfter() on List with cursor index less than 0\n");
       exit(EXIT_FAILURE);
   }
   if (L-&gt;cursorIndex == L-&gt;length - 1)
   {
       append(L, x);
       return;
   }

   Node N = newNode(x);

   N-&gt;next = L-&gt;cursor-&gt;next;
   L-&gt;cursor-&gt;next-&gt;prev = N;
   L-&gt;cursor-&gt;next = N;
   N -&gt; prev = L -&gt; cursor;
   L-&gt;length++;


}

void deleteFront(List L)
{

   if ( L==NULL )
   {
       printf("List Error: calling deleteFront() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }
   if ( L -&gt; length == 0 )
   {
       printf("List Error: calling deleteFront() on an empty List\n");
       exit(EXIT_FAILURE);
   }
   Node N = NULL; 
   N = L-&gt;front;
   L -&gt; front = N -&gt; next;
   

   if (L -&gt; front == NULL)
   {
       L-&gt;back = NULL;
       L -&gt; cursorIndex = -1;
       L-&gt;cursor = NULL;
   } else {
       L -&gt; front -&gt; prev = NULL;
   }   

   if (L -&gt; cursorIndex == 0)
   {
       L -&gt; cursorIndex = -1;
       L -&gt; cursor = NULL;
   } else {
       L -&gt; cursorIndex--;
   }
   L-&gt;length--;
   freeNode(&amp;N);
}

void deleteBack(List L)
{

   if ( L==NULL )
   {
       printf("List Error: calling deleteBack() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }
   if ( L -&gt; length == 0 )
   {
       printf("List Error: calling deleteBack() on an empty List\n");
       exit(EXIT_FAILURE);
   }
   
   Node N = NULL;
   N = L-&gt;back;
   if (length(L) &gt; 1)
   {
       L-&gt;back = L-&gt;back-&gt;prev;
       L-&gt;back-&gt;next = NULL;
   } else {
       L-&gt;front = L-&gt;back = NULL;
   }
   
   if (L -&gt; cursorIndex == L -&gt; length - 1)
   {
       L -&gt; cursorIndex = -1;
       L -&gt; cursor = NULL;
   }
   
   L-&gt;length--;
   freeNode(&amp;N);
   
}

void delete(List L)
{
   if ( L==NULL )
   {
       printf("List Error: calling deleteBack() on NULL List reference\n");
       exit(EXIT_FAILURE);
   }
   if ( L -&gt; length == 0 )
   {
       printf("List Error: calling deleteBack() on an empty List\n");
       exit(EXIT_FAILURE);
   }
   if ( L -&gt; cursorIndex &lt; 0 )
   {
       printf("List Error: calling delete() on a List with a NULL cursor reference\n");
       exit(EXIT_FAILURE);
   }
   
   if ( L -&gt; cursorIndex == 0) 
   {
       deleteFront(L);
       return;
   }
   if ( L -&gt; cursorIndex == L -&gt; length - 1)
   {
       deleteBack(L);
       return;
   }


   Node nodeToDelete = L -&gt; cursor;

   nodeToDelete -&gt; prev -&gt; next = nodeToDelete -&gt; next;
   nodeToDelete -&gt; next -&gt; prev = nodeToDelete -&gt; prev;
   L -&gt; cursorIndex = -1;
   L -&gt; length--;
   freeNode(&amp;(L-&gt;cursor));
   L = NULL;
}

// Other Operations

void printList(FILE* out, List L)
{
   Node curNode = L -&gt; front;

   while(curNode != NULL)
   {
       fprintf(out, "%d ", curNode -&gt; data);
</font>       curNode = curNode -&gt; next;
   }
}

List copyList(List L)
{
   List resultList = newList();

   Node curNode = L -&gt; front;
   while (curNode != NULL)
   {
       append(resultList, curNode -&gt; data);
       curNode = curNode -&gt; next;
   }
   return resultList;
}

//List concatList(List A, List B)

   //List firstListCopy = copyList(A);
   //List secondListCopy = copyList(B);

   //firstListCopy -&gt; back -&gt; next = secondListCopy -&gt; front;
   //secondListCopy -&gt; front -&gt; prev = firstListCopy -&gt; back;

   //return firstListCopy;

</pre>
</body>
</html>
