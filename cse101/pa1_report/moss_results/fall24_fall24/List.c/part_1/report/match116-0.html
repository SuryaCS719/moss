<html>
<head>
<title>/fall24/scaquino/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/scaquino/pa1/List.c<p></p><pre>
//-----------------------------------------------------------------------------
// List.c
// Implementation file for List ADT
//-----------------------------------------------------------------------------
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#include "List.h"

// define NodeObj

typedef struct NodeObj* Node;

typedef struct NodeObj {
	int data;
	Node next;
	Node back;
} NodeObj;

// ListObj struct
typedef struct ListObj {
	Node front;
	Node end;
	Node cursor;
	int len;
	int ind;
} ListObj;

// separate Node functions

// Creates new Nodes and returns data and NULL pointers
Node newNode(int data) {
	Node X = malloc(sizeof(NodeObj));
	X-&gt;data = data;
	X-&gt;next = NULL;
	X-&gt;back = NULL;

	return X;
}

// Frees memory from Node and sets it to NULL
void freeNode(Node* pN) {
<a name="1"></a><font color="#00FF00"><a href="match116-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

	if (pN != NULL &amp;&amp; *pN != NULL) {
		free(*pN);
		*pN = NULL;
	}
}

// Constructors-Destructors ---------------------------------------------------

// Creates and returns a new empty List.
List newList(void) {
	List L = malloc(sizeof(ListObj));
	L-&gt;front = NULL;
	L-&gt;end = NULL;
	L-&gt;cursor = NULL;
	L-&gt;len = 0;
	L-&gt;ind = -1;

	return L;
}

// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List* pL) {
	if (pL != NULL &amp;&amp; *pL != NULL) {
		while ((*pL)-&gt;front != NULL) {
			deleteFront(*pL);
		}
		free(*pL);
		*pL = NULL;
	}
}

// Access functions -----------------------------------------------------------
// Returns the number of elements in L.
int length(List L) {
	if (L == NULL) {
		fprintf(stderr, "Unable to get length of NULL list\n");
</font>		exit(EXIT_FAILURE);
	}
	return L-&gt;len;
}

// Returns index of cursor element if defined, -1 otherwise.
int index(List L) {
	if (L == NULL) {
		fprintf(stderr, "Unable to obtain index on NULL list\n");
		exit(EXIT_FAILURE);
	}
<a name="10"></a><font color="#FF0000"><a href="match116-1.html#10" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	return L-&gt;ind;
}

// Returns front element of L. Pre: length()&gt;0
int front(List L) {
	if (L == NULL) {
		fprintf(stderr, "Unable to get front on NULL list\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;len &lt;= 0) {
                fprintf(stderr, "Unable to get front on EMPTY list\n");
</font>                exit(EXIT_FAILURE);
        }
	return L-&gt;front-&gt;data;
}

int back(List L) {
       if (L == NULL) {
                fprintf(stderr, "Unable to get back on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;len &lt;= 0) {
                fprintf(stderr, "Unable to get back on EMPTY list\n");
                exit(EXIT_FAILURE);
        }
        return L-&gt;end-&gt;data;
}	

// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L) {
	if (L == NULL) {
                fprintf(stderr, "Unable to use GET on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;len &lt;= 0) {
                fprintf(stderr, "Unable to use GET on EMPTY list\n");
                exit(EXIT_FAILURE);
        }
	if (L-&gt;ind &lt; 0) {
                fprintf(stderr, "Unable to use GET on undefined pointer\n");
                exit(EXIT_FAILURE);
        }
        return L-&gt;cursor-&gt;data;
}

// Returns true iff Lists A and B contain the same sequence of elements, returns false otherwise.
bool equals(List A, List B) {
	if (A == NULL || B == NULL) {
                fprintf(stderr, "Unable to use EQUALS  on EMPTY list\n");
                exit(EXIT_FAILURE);
	}
	if (A-&gt;len != B-&gt;len) return false;
	Node X = A-&gt;front;
	Node Y = B-&gt;front;
	while (X != NULL) {
		if (X-&gt;data != Y-&gt;data) return false;
		X = X-&gt;next;
		Y = Y-&gt;next;
	}
	return true;
}

// Manipulation procedures ----------------------------------------------------

// Resets L to its original empty state.
<a name="2"></a><font color="#0000FF"><a href="match116-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

void clear(List L) {
	if (L == NULL) {
		fprintf(stderr, "Unable to CLEAR on NULL list\n");
		exit(EXIT_FAILURE);
	}
	while (length(L) &gt; 0) {
		deleteFront(L);
	}
	L-&gt;cursor = NULL;
	L-&gt;ind = -1;
}

// Overwrites the cursor elementâ€™s data with x. Pre: length()&gt;0, index()&gt;=0
void set(List L, int x) {
	if (L == NULL) {
		fprintf(stderr, "Unable to SET on NULL list\n");
		exit(EXIT_FAILURE);	
	}
	if (length(L) &lt;= 0) {
                fprintf(stderr, "Unable to SET on EMPTY list\n");
                exit(EXIT_FAILURE);
        }
	if (index(L) &lt; 0) {
                fprintf(stderr, "Unable to SET on EMPTY list\n");
                exit(EXIT_FAILURE);
        }
	L-&gt;cursor-&gt;data = x;
</font>}

// If L is non-empty, sets cursor under the front element, otherwise does nothing.
void moveFront(List L) {
	if (L == NULL) {
                fprintf(stderr, "Unable to MOVE on NULL list\n");
                exit(EXIT_FAILURE);
        }
	if (L-&gt;len &gt; 0) {
		L-&gt;cursor = L-&gt;front;
		L-&gt;ind = 0;
	}
}

// If L is non-empty, sets cursor under the back element, otherwise does nothing.
void moveBack(List L) {
        if (L == NULL) {
                fprintf(stderr, "Unable to MOVE on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;len &gt; 0) {
                L-&gt;cursor = L-&gt;end;
<a name="8"></a><font color="#00FFFF"><a href="match116-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

                L-&gt;ind = L-&gt;len - 1;
        }
} 

// If cursor is defined and not at front, move cursor one step toward the front of L; if cursor is defined and at
// front, cursor becomes undefined; if cursor is undefined do nothing
void movePrev(List L) {
        if (L == NULL) {
                fprintf(stderr, "Unable to MOVE on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;front) {
</font>                L-&gt;cursor = L-&gt;cursor-&gt;back;
                L-&gt;ind--;
<a name="6"></a><font color="#00FF00"><a href="match116-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        } else if (L-&gt;cursor == L-&gt;front) {
		L-&gt;cursor = NULL;
		L-&gt;ind = -1;
	}
}

// If cursor is defined and not at back, move cursor one step toward the back of L; if cursor is defined and at
// back, cursor becomes undefined; if cursor is undefined do nothing
void moveNext(List L) {
        if (L == NULL) {
                fprintf(stderr, "Unable to MOVE on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;cursor != NULL &amp;&amp; L-&gt;cursor != L-&gt;end) {
</font>                L-&gt;cursor = L-&gt;cursor-&gt;next;
                L-&gt;ind++;
<a name="11"></a><font color="#00FF00"><a href="match116-1.html#11" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

        } else if (L-&gt;cursor == L-&gt;end) {
                L-&gt;cursor = NULL;
                L-&gt;ind = -1;
        }       
}

// Insert new element into L. If L is non-empty, insertion takes place before front element.
void prepend(List L, int x) {
	if (L == NULL) {
                fprintf(stderr, "Unable to INSERT on NULL list\n");
</font>                exit(EXIT_FAILURE);
        }
	Node X = newNode(x);
	if (L-&gt;len == 0) {
		L-&gt;front = X;
		L-&gt;end = X;
	} else {
		X-&gt;next = L-&gt;front;
		L-&gt;front-&gt;back = X;
		L-&gt;front = X;
	}
	L-&gt;len++;
	if (L-&gt;ind != -1) {
		L-&gt;ind++;
	}
}

// Insert new element into L. If L is non-empty, insertion takes place after back element.
void append(List L, int x) {
	if (L == NULL) {
                fprintf(stderr, "Unable to INSERT on NULL list\n");
                exit(EXIT_FAILURE);
        }
	Node X = newNode(x);
        if (L-&gt;len == 0) {
                L-&gt;front = X;
                L-&gt;end = X;
        } else {
                X-&gt;back = L-&gt;end;
                L-&gt;end-&gt;next = X;
                L-&gt;end = X;
        }
<a name="4"></a><font color="#FF00FF"><a href="match116-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

        L-&gt;len++;
}

// Insert new element before cursor. Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
	if (L == NULL) {
                fprintf(stderr, "Unable to INSERT on NULL list\n");
                exit(EXIT_FAILURE);
        }
	if (L-&gt;len &lt;= 0 || L-&gt;ind &lt; 0) {
		fprintf(stderr, "Unable to INSERT on EMPTY list or UNDEFINED CURSOR\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;cursor == L-&gt;front) {
</font>		prepend(L, x);
	} else {
		Node X = newNode(x);
		X-&gt;next = L-&gt;cursor;
		X-&gt;back = L-&gt;cursor-&gt;back;
		L-&gt;cursor-&gt;back-&gt;next = X;
		L-&gt;cursor-&gt;back = X;
		L-&gt;len++;
<a name="5"></a><font color="#FF0000"><a href="match116-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

		L-&gt;ind++;
	}
}

// Insert new element after cursor.Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
        if (L == NULL) {
                fprintf(stderr, "Unable to INSERT on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;len &lt;= 0 || L-&gt;ind &lt; 0) {
                fprintf(stderr, "Unable to INSERT on EMPTY list or UNDEFINED CURSOR\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;cursor == L-&gt;end) {
</font>                append(L, x);
        } else {
                Node X = newNode(x);
                X-&gt;back = L-&gt;cursor;
                X-&gt;next = L-&gt;cursor-&gt;next;
                L-&gt;cursor-&gt;next-&gt;back = X;
                L-&gt;cursor-&gt;next = X;
                L-&gt;len++;
        }
}

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L) {
        if (L == NULL) {
                fprintf(stderr, "Unable to DELETE on NULL list\n");
                exit(EXIT_FAILURE);
        }
<a name="0"></a><font color="#FF0000"><a href="match116-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_9.gif"/></a>

        if (L-&gt;len &lt;= 0) {
                fprintf(stderr, "Unable to DELETE on EMPTY list\n");
                exit(EXIT_FAILURE);
        }
        Node X = L-&gt;front;
	if (L-&gt;len &gt; 1) {
		L-&gt;front = L-&gt;front-&gt;next;
		L-&gt;front-&gt;back = NULL;
	} else {
		L-&gt;front = NULL; 
		L-&gt;end = NULL;
	}
	if (L-&gt;cursor == X) {
		L-&gt;cursor = NULL;
		L-&gt;ind = -1;
	}
	freeNode(&amp;X);
	L-&gt;len--;
	if (L-&gt;ind != -1) {
		L-&gt;ind--;
	}
}

// Delete the back element. Pre: length()&gt;0
void deleteBack(List L) {
        if (L == NULL) {
                fprintf(stderr, "Unable to DELETE on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;len &lt;= 0) {
                fprintf(stderr, "Unable to DELETE on EMPTY list\n");
                exit(EXIT_FAILURE);
        }
        Node X = L-&gt;end;
        if (L-&gt;len &gt; 1) {
                L-&gt;end = L-&gt;end-&gt;back;
</font>                L-&gt;end-&gt;next = NULL;
        } else {
                L-&gt;front = L-&gt;end = NULL;
        }
        if (L-&gt;cursor == X) {
<a name="3"></a><font color="#00FFFF"><a href="match116-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

                L-&gt;cursor = NULL;
                L-&gt;ind = -1;
        }
        freeNode(&amp;X);
        L-&gt;len--;
}

// Delete cursor element, making cursor undefined.Pre: length()&gt;0, index()&gt;=0
void delete(List L) {
        if (L == NULL) {
                fprintf(stderr, "Unable to DELETE on NULL list\n");
                exit(EXIT_FAILURE);
        }
        if (L-&gt;len &lt;= 0 || L-&gt;ind &lt; 0) {
                fprintf(stderr, "Unable to DELETE on EMPTY list or UNDEFINED cursor\n");
                exit(EXIT_FAILURE);
        }
        Node X = L-&gt;cursor;
        if (X == L-&gt;front) {
                deleteFront(L);
</font>	} else if (X == L-&gt;end) {
		deleteBack(L);		
        } else {
<a name="7"></a><font color="#0000FF"><a href="match116-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

                X-&gt;back-&gt;next = X-&gt;next;
		X-&gt;next-&gt;back = X-&gt;back;
		freeNode(&amp;X);
		L-&gt;len--;
        }
        L-&gt;cursor = NULL;
	L-&gt;ind = -1;
}

// Other operations -----------------------------------------------------------

// Prints to the file pointed to by out, a string representation of L consisting
// of a space separated sequence of integers, with front on left.
void printList(FILE* out, List L) {
</font>	if (L == NULL) {
                fprintf(stderr, "Unable to PRINT on NULL list\n");
                exit(EXIT_FAILURE);
        }
	Node X = L-&gt;front;
	while (X != NULL) {
<a name="9"></a><font color="#FF00FF"><a href="match116-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

		fprintf(out, "%d ", X-&gt;data);
		X = X-&gt;next;
	}
	fprintf(out, "\n");
}

// Returns a new List representing the same integer sequence as L.
// The cursor in the new list is undefined, regardless of the state of the cursor in L. The state of L is unchanged.
List copyList(List L) {
	if (L == NULL) {
                fprintf(stderr, "Unable to COPY on NULL list\n");
                exit(EXIT_FAILURE);
        }
	List N = newList();
</font>	Node X = L-&gt;front;
	while (X != NULL) {
		append(N, X-&gt;data);
		X = X-&gt;next;
	}
	return N;
}


</pre>
</body>
</html>
