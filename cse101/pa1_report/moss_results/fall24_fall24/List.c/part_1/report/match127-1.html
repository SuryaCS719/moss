<html>
<head>
<title>/fall24/shan69/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/shan69/pa1/List.c<p></p><pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;stdbool.h&gt;

<a name="0"></a><font color="#FF0000"><a href="match127-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef struct NodeObj 
{
    int data;
    struct NodeObj* prev;
    struct NodeObj* next;
} NodeObj;
typedef NodeObj* Node;

Node newNode(int data) 
{
    Node N = (Node)malloc(sizeof(NodeObj));
    N -&gt; data = data;
    N -&gt; prev = N -&gt; next = NULL;
    return N;
}

void freeNode(Node* pN) 
{
    if (pN != NULL &amp;&amp; *pN != NULL) 
    {
        free(*pN);
        *pN = NULL;
    }
}

typedef struct ListObj 
{
    Node front;
    Node back;
    Node cursor;
    int length;
    int index;
} ListObj;
typedef ListObj* List;

// Other List operations would be implemented here
// For example: isEmpty(), length(), front(), back(), index(), get(), etc.

// Constructors-Destructors ---------------------------------------------------
List newList(void) // Creates and returns a new empty List.
{
    List L = (List)malloc(sizeof(ListObj));
    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
    return L;
}

void freeList(List* pL) // Frees all heap memory associated with *pL, and sets
{
    if (pL != NULL &amp;&amp; *pL != NULL) 
    {
        while ((*pL) -&gt; front != NULL) 
        {
            Node temp = (*pL) -&gt; front;
            (*pL) -&gt; front = (*pL) -&gt; front -&gt; next;
            freeNode(&amp;temp);
        }
        free(*pL);
        *pL = NULL;
    }
}

// *pL to NULL.
// Access functions -----------------------------------------------------------
int length(List L) // Returns the number of elements in L.
{
    if (L == NULL) 
    {
        fprintf(stderr, "List Error: calling length() on NULL List reference\n");
        exit(1);
    }
    return L-&gt;length;
}

int index(List L) // Returns index of cursor element if defined, -1 otherwise.
{
    if (L == NULL) 
    {
        fprintf(stderr, "List Error: calling index() on NULL List reference\n");
        exit(1);
    }
    return L -&gt; index;
}

int front(List L) // Returns front element of L. Pre: length()&gt;0
{
    if (L == NULL) 
    {
        fprintf(stderr, "List Error: calling front() on NULL List reference\n");
        exit(1);
    }

    if (L-&gt;length == 0) 
    {
        fprintf(stderr, "List Error: calling front() on an empty List\n");
        exit(1);
    }

    return L -&gt; front -&gt; data;
}

int back(List L) // Returns back element of L. Pre: length()&gt;0
{
    if (L == NULL) 
    {
        fprintf(stderr, "List Error: calling back() on NULL List reference\n");
        exit(1);
    }

    if (L-&gt;length == 0) 
    {
        fprintf(stderr, "List Error: calling back() on an empty List\n");
        exit(1);
    }

    return L -&gt; back -&gt; data;
}

int get(List L); // Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
bool equals(List A, List B); // Returns true iff Lists A and B contain the same
 // sequence of elements, returns false otherwise.
// Manipulation procedures ----------------------------------------------------
void clear(List L); // Resets L to its original empty state.
void set(List L, int x); // Overwrites the cursor elementâ€™s data with x.
 // Pre: length()&gt;0, index()&gt;=0
void moveFront(List L); // If L is non-empty, sets cursor under the front element,
 // otherwise does nothing.
void moveBack(List L); // If L is non-empty, sets cursor under the back element,
 // otherwise does nothing.
void movePrev(List L); // If cursor is defined and not at front, move cursor one
 // step toward the front of L; if cursor is defined and at
 // front, cursor becomes undefined; if cursor is undefined
 // do nothing
void moveNext(List L); // If cursor is defined and not at back, move cursor one
 // step toward the back of L; if cursor is defined and at
 // back, cursor becomes undefined; if cursor is undefined
 // do nothing
void prepend(List L, int x); // Insert new element into L. If L is non-empty,
 // insertion takes place before front element.
void append(List L, int x); // Insert new element into L. If L is non-empty,
 // insertion takes place after back element.
void insertBefore(List L, int x); // Insert new element before cursor.
 // Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x); // Insert new element after cursor.
 // Pre: length()&gt;0, index()&gt;=0

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L)
{
    if (L == NULL || length(L) &lt;= 0) 
    {
        fprintf(stderr, "List Error: calling deleteFront() on NULL List reference\n");
        exit(1);
    }

    Node tempNode = L -&gt; front;
    
    // If the cursor is on the front element
    if (L -&gt; cursor == L -&gt; front) 
    {
        L -&gt; cursor = NULL;
        L -&gt; index = -1;
    } 
    else if (L -&gt; cursor != NULL) // If cursor is not at the front but is defined
    {
        L -&gt; index--;
    }
    
    L -&gt; front = L -&gt; front -&gt; next;
    
    // If the list becomes empty after deletion
    if (L -&gt; front == NULL) 
    {
        L -&gt; back = NULL;
    } 
    else 
    {
        L -&gt; front -&gt; prev = NULL;
    }
    
    freeNode(&amp;tempNode);
    L -&gt; length--;
}

void deleteBack(List L) // Delete the back element. Pre: length()&gt;0
{
    if (L == NULL || L -&gt; length &lt;= 0) 
    {
        fprintf(stderr, "List Error: calling deleteBack() on NULL List reference or empty list\n");
        exit(1);
    }
    
    Node tempNode = L -&gt; back;
    
    // If the cursor is on the back element, make it undefined
    if (L -&gt; cursor == L -&gt; back) {
        L -&gt; cursor = NULL;
        L -&gt; index = -1;
    }
    
    L -&gt; back = L -&gt; back -&gt; prev;
    
    if (L -&gt; back == NULL) {
        L -&gt; front = NULL;
    } else {
        L -&gt; back -&gt; next = NULL;
    }
    
    freeNode(&amp;tempNode);
    
    L -&gt; length--;
}

void delete(List L) // Delete cursor element, making cursor undefined. Pre: length()&gt;0, index()&gt;=0
{}

// Other operations -----------------------------------------------------------
void printList(FILE* out, List L); // Prints to the file pointed to by out, a
</font> // string representation of L consisting
// of a space separated sequence of integers,
// with front on left.
List copyList(List L); // Returns a new List representing the same integer
 // sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.</pre>
</body>
</html>
