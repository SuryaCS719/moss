<html>
<head>
<title>/fall24/anfomitc/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/anfomitc/pa1/List.c<p></p><pre>
/***
* Anna Fomitchev
* anfomitc
* 2024 Fall CSE101 PA1
* List.c
* Contains all of the code for the initialization functions, constructors-destructors, and manipulation procedures of the List ADT. 
List ADT is a two directional queue that has a cursor to keep track of where we are in it. 
***/  
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"


// Constructors-Destructors ---------------------------------------------------

// Creates and returns a new empty List.
<a name="0"></a><font color="#FF0000"><a href="match46-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

List newList(void) {
    List l = (List)malloc(sizeof(ListObj));
    if (l == NULL) {
        return (List)NULL;
    }

    l-&gt;front = NULL;
    l-&gt;back = NULL;
    l-&gt;cursor = NULL;
    l-&gt;index = -1;
    l-&gt;length = 0;
    return l;
} 

// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List *pL) {
    // use same number of frees as we used mallocs
    
    // clear will take care of the individual data in the list
    clear(*pL);
    
    // one free for the one malloc in newList
    free(*pL);
    pL = NULL;
}


// Access functions -----------------------------------------------------------

 // Returns the number of elements in L.
int length(List L) {
    return L-&gt;length;
}


// Returns index of cursor element if defined, -1 otherwise.
int index(List L) {
    return L-&gt;index;
}


// Returns front element of L. Pre: length()&gt;0
int front(List L) {
    // assume to make -1 if front/back element is undefined
    if (L-&gt;length == 0) return -1;
    return L-&gt;front-&gt;data;
}

// Returns back element of L. Pre: length()&gt;0
int back(List L) {
    // precondition check
    if (L-&gt;length == 0) return -1;
    
    return L-&gt;back-&gt;data;
}

// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L) {
    // precondition check
    if (L-&gt;length == 0) return -1;
    if (L-&gt;index &lt; 0) return -1;
    
    return L-&gt;cursor-&gt;data;
}

// Returns true iff (if and only if) Lists A and B contain the same
 // sequence of elements, returns false otherwise.
bool equals(List A, List B) {
    //bool result = true;
    
    // special case of length 0
    if (A-&gt;length == 0 &amp;&amp; B-&gt;length == 0) return true;
    
    // both files should be of same length to be equal
    if (A-&gt;length != B-&gt;length) return false;
    
    Node currentA = A-&gt;front;
    Node currentB = B-&gt;front;
    for (; currentA != NULL &amp;&amp; currentB != NULL;) {
        if (currentA-&gt;data != currentB-&gt;data) return false;
        // iteration
        currentA = currentA-&gt;next;
        currentB = currentB-&gt;next;
    }
    return true;
}

 
 
 // Manipulation procedures ----------------------------------------------------

// Overwrites the cursor elementâ€™s data with x.
 // Pre: length()&gt;0, index()&gt;=0
void set(List L, int x) {
    // precondition check
    if (L-&gt;length == 0 || L-&gt;index == -1) return;
    
    L-&gt;cursor-&gt;data = x;
    return;
}

void moveFront(List L) {
    // precondition check
    if (L-&gt;length == 0) return;
    
    L-&gt;cursor = L-&gt;front;
    L-&gt;index = 0;
}

// If L is non-empty, sets cursor under the back element,
 // otherwise does nothing.
void moveBack(List L) {
    // precondition check
    if (L-&gt;length == 0) return;
    
    L-&gt;cursor = L-&gt;back;
    L-&gt;index = L-&gt;length - 1;
}

// If cursor is defined and not at front, move cursor one
 // step toward the front of L; if cursor is defined and at
 // front, cursor becomes undefined; if cursor is undefined
 // do nothing
void movePrev(List L) {
    // check if cursor is nto defined 
    if (L-&gt;index == -1) return;
    if (L-&gt;index == 0) {
        L-&gt;index = -1;
        L-&gt;cursor = NULL;
        return;
    }
    L-&gt;index --;
    L-&gt;cursor = L-&gt;cursor-&gt;prev;
    return;
}

 // If cursor is defined and not at back, move cursor one
 // step toward the back of L; if cursor is defined and at
 // back, cursor becomes undefined; if cursor is undefined
 // do nothing
void moveNext(List L) {
    if (L-&gt;index == -1) return;
    if (L-&gt;index == L-&gt;length - 1) {
        L-&gt;index = -1;
        L-&gt;cursor = NULL;
        return;
    }
    L-&gt;index ++;
    L-&gt;cursor = L-&gt;cursor-&gt;next;
    return;
}


 // Insert new element into L. If L is non-empty,
 // insertion takes place before front element.
void prepend(List L, int x) {
    // precondition check
    if (L == NULL) return; 
    //if (L-&gt;length == 0) return;
    Node newfront = (Node)malloc(sizeof(NodeObj));
    newfront-&gt;data = x;
    
    // special case for empty list where front and back is not defined 
    if (L-&gt;length == 0) {
        newfront-&gt;next = NULL;
        newfront-&gt;prev = NULL;
        L-&gt;back = newfront;
    }
    else {
        newfront-&gt;next = L-&gt;front;
        newfront-&gt;prev = NULL;
        L-&gt;front-&gt;prev = newfront;
    }
    L-&gt;front = newfront;
    L-&gt;length ++;

    // adjust index 
    if (L-&gt;cursor != NULL) {
        L-&gt;index ++;
    }
}


// Insert new element into L. If L is non-empty,
 // insertion takes place after back element.
void append(List L, int x) {
    // precondition check
    if (L == NULL) return; 
    //if (L-&gt;length == 0) return;
    Node newback = (Node)malloc(sizeof(NodeObj));
    newback-&gt;data = x;
    
    // special case for empty list where front and back is not defined 
    if (L-&gt;length == 0) {
        newback-&gt;next = NULL;
        newback-&gt;prev = NULL;
        L-&gt;front = newback;
    }
    else {
        newback-&gt;next = NULL;
        newback-&gt;prev = L-&gt;back;
        L-&gt;back-&gt;next = newback;
    }

    L-&gt;back = newback;
    L-&gt;length ++;
}

// Insert new element before cursor.
 // Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
    // precondition check
    if (L-&gt;length == 0 || L-&gt;index &lt; 0) return; 
    
    // create new node 
    Node newnode = (Node)malloc(sizeof(NodeObj));
    newnode-&gt;data = x;
    newnode-&gt;prev = L-&gt;cursor-&gt;prev;
    newnode-&gt;next = L-&gt;cursor;


    // update node to the left 
    Node left = L-&gt;cursor-&gt;prev;
    if (left != NULL) {
        left-&gt;next = newnode;
    }

    // update cursor
    L-&gt;cursor-&gt;prev = newnode;
    
    // special case if cursor is front
    if (L-&gt;index == 0) L-&gt;front = newnode;
    L-&gt;index ++;
    L-&gt;length ++;
}

// Insert new element after cursor.
 // Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
    // precondition check
    if (L-&gt;length == 0 || L-&gt;index &lt; 0) return; 

    // create new node
    Node newnode = (Node)malloc(sizeof(NodeObj));
    newnode-&gt;data = x;
    newnode-&gt;prev = L-&gt;cursor;
    newnode-&gt;next = L-&gt;cursor-&gt;next;

    // update node to the right
    Node right = L-&gt;cursor-&gt;next;
    if (right != NULL) right-&gt;prev = newnode;

    // update cursor 
    L-&gt;cursor-&gt;next = newnode;

    // special case if cursor is back
    if (L-&gt;index == L-&gt;length - 1) L-&gt;back = newnode;

    L-&gt;length ++;

    // no need to update index
}


// Delete the front element. Pre: length()&gt;0
void deleteFront(List L) {
    // precondition check
    if (L-&gt;length== 0) return; 
    
    Node oldfront = L-&gt;front;
    L-&gt;front = oldfront-&gt;next; 
    if (oldfront-&gt;next != NULL) oldfront-&gt;next-&gt;prev = NULL;
    free(oldfront);
    L-&gt;length --;
    
    // check cursor 
    if (L-&gt;index == -1) return; 
    if (L-&gt;index == 0) {
        L-&gt;index = -1;
        L-&gt;cursor = NULL;
        return;
    }
    L-&gt;index --;
}

// Delete the back element. Pre: length()&gt;0
void deleteBack(List L) {
    // precondition check
    if (L-&gt;length == 0) return;
    Node oldback = L-&gt;back;
    L-&gt;back = oldback-&gt;prev;
    if (oldback-&gt;prev != NULL) oldback-&gt;prev-&gt;next = NULL;
    free(oldback);
    L-&gt;length --;

    // check cursor/index
    if (L-&gt;index == -1) return;
    if (L-&gt;index == L-&gt;length ) {
        L-&gt;index = -1;
        L-&gt;cursor = NULL;
        return;
    }
    // no change to index aside from special case
}

// Delete cursor element, making cursor undefined.
 // Pre: length()&gt;0, index()&gt;=0
void delete(List L) {
    // precodnition check 
    if (L-&gt;length == 0 || L-&gt;index == -1) return;
    Node left = L-&gt;cursor-&gt;prev;
    Node right = L-&gt;cursor-&gt;next;
    if (left != NULL) left-&gt;next = right;
    if (right != NULL) right-&gt;prev = left;

    // update front'back if needed
    if (L-&gt;front == L-&gt;cursor) L-&gt;front = right;
    if (L-&gt;back == L-&gt;cursor) L-&gt;back = left;
    
    
    // free and reset the cursor and edit length
    free(L-&gt;cursor);
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length --;
}

// Resets L to its original empty state.
void clear(List L) {
    for (Node current = L-&gt;front; current != NULL ;) {
        Node next = current-&gt;next;
        free(current);
        current = next; 
    }

    //clean up 
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length = 0;
}


// Other operations -----------------------------------------------------------

// Prints to the file pointed to by out, a
 // string representation of L consisting
// of a space separated sequence of integers,
// with front on left.
void printList(FILE* out, List L) {
    // special case for empty list 
    if (L-&gt;length == 0) {
        //printf("list is empty");
        return;
    }
    else {
        //printf("list is not empty");
        for (Node current = L-&gt;front; current != NULL ;current = current-&gt;next) {
            fprintf(out,"%d ",current-&gt;data);
        }
    }

}

// Returns a new List representing the same integer
 // sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.
List copyList(List L) {
    List copy = newList();
    
    // loop trhough old list and append each element 
    for (Node current = L-&gt;front; current != NULL ;current = current-&gt;next) {
        append(copy,current-&gt;data);
</font>    }

    return copy;
}
</pre>
</body>
</html>
