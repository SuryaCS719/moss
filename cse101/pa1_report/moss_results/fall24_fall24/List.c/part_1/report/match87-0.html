<html>
<head>
<title>/fall24/gahrens/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/gahrens/pa1/List.c<p></p><pre>
// Name: Gabe Ahrens
// CruzID: gahrens
// Assignment: pa1
#include "List.h"

#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct NodeObj* Node;

<a name="2"></a><font color="#0000FF"><a href="match87-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

typedef struct NodeObj
{
    int data;
    Node next;
    Node prev;
} NodeObj;

typedef struct ListObj
{
    Node front;
    Node back;
    Node cursor;
    int length;
    int cursorIdx;
} ListObj;

// Constructors-Destructors - - - - - - - - - - - - -
Node newNode(ListElement data)
{
    Node N = malloc(sizeof(NodeObj));
    assert( N!=NULL );
    N-&gt;data = data;
    N-&gt;next = N-&gt;prev = NULL;
</font>    return(N);
}

void freeNode(Node* pN)
{
    if ( pN!=NULL &amp;&amp; *pN!=NULL)
    {
        free(*pN);
        *pN = NULL;
    }
}

List newList()
{
    List L;
    L = malloc(sizeof(ListObj));
    assert( L!=NULL );
    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;cursorIdx = -1;
    return(L);
}

<a name="3"></a><font color="#00FFFF"><a href="match87-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

void freeList(List* pL)
{
    if (pL!=NULL &amp;&amp; *pL!=NULL)
    {
        clear(*pL);

        // free the list itself
        free(*pL);
        *pL = NULL;
    }

    return;
}

// Access Funtions - - - - - - - - - - - - -
int length(List L)
{
    return (L-&gt;length);
}

int index(List L)
{
    return (L-&gt;cursorIdx);
}

int front(List L)
</font>{
    return (L-&gt;front-&gt;data);
}

int back(List L)
{
<a name="4"></a><font color="#FF00FF"><a href="match87-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

    return (L-&gt;back-&gt;data);
}

int get(List L)
{
    return (L-&gt;cursor-&gt;data);
}

bool equals(List A, List B)
{
    if( A==NULL || B==NULL )
    {
          printf("List Error: calling equals() on NULL List reference\n");
</font>          exit(EXIT_FAILURE);
    }

    bool eq;
    Node N, M;

    eq = ( A-&gt;length == B-&gt;length );
    N = A-&gt;front;
    M = B-&gt;front;
    while( eq &amp;&amp; N!=NULL){
<a name="0"></a><font color="#FF0000"><a href="match87-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_39.gif"/></a>

        eq = ( N-&gt;data==M-&gt;data );
        N = N-&gt;next;
        M = M-&gt;next;
    }
    return eq;
}

// Manipulation procedures - - - - - - - - - - - - - - -
void clear(List L)
{

    // deletes all elements of list
    while( L-&gt;length &gt; 0 ){

        deleteBack(L);
        //L-&gt;cursorIdx--;
    }

    // resets the fields of L
    L-&gt;back = L-&gt;front = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;cursorIdx = -1;

    return;

}

void set(List L, int x)
{
    L-&gt;cursor-&gt;data = x;

    return;
}

void moveFront(List L)
{
    if (L-&gt;length &gt; 0)
    {
        // idx 0 is the front of the list
        L-&gt;cursorIdx = 0;

        // update the cursor to be the Front Node
        L-&gt;cursor = L-&gt;front;
    }

    return;
}

void moveBack(List L)
{
    if (L-&gt;length &gt; 0)
    {
        // idx length-1 is the back of the list
        L-&gt;cursorIdx = L-&gt;length - 1;

        // update the cursor to be the back Node
        L-&gt;cursor = L-&gt;back;
    }

    return;
}

void movePrev(List L)
{
    // cursor is defined
    if (L-&gt;cursor != NULL)
    {
        // cursor not at front
        if (L-&gt;cursorIdx != 0)
        {
            // move cursor one step towards front
            L-&gt;cursor = L-&gt;cursor-&gt;prev;
            L-&gt;cursorIdx--;
        }
        else // cursor at front
        {
            // make cursor undefined
            L-&gt;cursor = NULL;
            L-&gt;cursorIdx = -1;
        }
    }

    // cursor undefined so do nothing
    return;
}

void moveNext(List L)
{
    // cursor is defined
    if (L-&gt;cursor != NULL)
    {
        // cursor not at back
        if (L-&gt;cursorIdx != (L-&gt;length - 1))
        {
            // move cursor one step towards back
            L-&gt;cursor = L-&gt;cursor-&gt;next;
            L-&gt;cursorIdx++;
        }
        else // cursor at back
        {
            // make cursor undefined
            L-&gt;cursor = NULL;
            L-&gt;cursorIdx = -1;
        }
    }

    return;
}

void prepend(List L, int x)
{
    Node newEle = newNode(x);

    // empty list case
    if (L-&gt;length == 0)
    {
        // the only element in the list is newEle
        // so it is front and back
        L-&gt;front = newEle;
        L-&gt;back = newEle;
    }
    else // non-empty list case
    {
        newEle-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = newEle;
        L-&gt;front = newEle;
    }

    L-&gt;length++;

    return;
}

void append(List L, int x)
{
    Node newEle = newNode(x);

    // empty list case
    if (L-&gt;length == 0)
    {
        // the only element in the list is newEle
        // so it is front and back
        L-&gt;front = newEle;
        L-&gt;back = newEle;
    }
    else // non-empty list case
    {
        newEle-&gt;prev = L-&gt;back;
        L-&gt;back-&gt;next = newEle;
        L-&gt;back = newEle;
    }

    L-&gt;length++;

    return;
}

void insertBefore(List L, int x)
{
    Node newEle = newNode(x);

    newEle-&gt;prev = L-&gt;cursor-&gt;prev;
    newEle-&gt;next = L-&gt;cursor;

    if (L-&gt;cursor-&gt;prev != NULL)
    {
        L-&gt;cursor-&gt;prev-&gt;next = newEle;
    }
    else
    {
        // is new front
        L-&gt;front = newEle;
    }

    L-&gt;cursor-&gt;prev = newEle;

    L-&gt;length++;

    return;
}

void insertAfter(List L, int x)
{
    Node newEle = newNode(x);

    newEle-&gt;prev = L-&gt;cursor;
    newEle-&gt;next = L-&gt;cursor-&gt;next;
</font>
    if (L-&gt;cursor-&gt;next != NULL)
    {

<a name="1"></a><font color="#00FF00"><a href="match87-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_34.gif"/></a>

        L-&gt;cursor-&gt;next-&gt;prev = newEle;

    }
    else
    {
        // is new back
        L-&gt;back = newEle;
    }

    L-&gt;cursor-&gt;next = newEle;

    L-&gt;length++;

    return;
}

void deleteFront(List L)
{
    if( L==NULL )
    {
        printf("List Error: calling deleteFront() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if( L-&gt;length == 0 )
    {
        printf("List Error: calling deleteFront() on an empty List\n");
        exit(EXIT_FAILURE);
    }

    Node oldFront = L-&gt;front;

    L-&gt;front = L-&gt;front-&gt;next;

    if (L-&gt;length != 1)
    {
        L-&gt;front-&gt;prev = NULL;
    }

    freeNode(&amp;oldFront);

    // undefined cursor case
    if (L-&gt;cursorIdx == 0)
    {
        L-&gt;cursorIdx = -1;
    }

    L-&gt;length--;

    return;
}

void deleteBack(List L)
{
    if( L==NULL )
    {
        printf("List Error: calling deleteBack() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if( L-&gt;length == 0 )
    {
        printf("List Error: calling deleteBack() on an empty List\n");
        exit(EXIT_FAILURE);
    }

    Node oldBack = L-&gt;back;

    L-&gt;back = L-&gt;back-&gt;prev;

    if (L-&gt;length != 1)
    {
        L-&gt;back-&gt;next = NULL;
    }

    freeNode(&amp;oldBack);

    // undefined cursor case
    if (L-&gt;cursorIdx == (L-&gt;length - 1))
    {
        L-&gt;cursorIdx = -1;
    }

    L-&gt;length--;

    return;
}

void delete(List L)
{
    L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
    L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;

    freeNode(&amp;L-&gt;cursor);

    L-&gt;cursor = NULL;
    L-&gt;cursorIdx = -1;

    L-&gt;length--;

    return;
}

// Other Operations - - - - - - - - - - - - -
void printList(FILE* out, List L)
{
//    moveFront(L);
//    while( index(L)&gt;=0 ){
//        int x = get(L);
//        fprintf(out, "%d ", x);
//        moveNext(L);
//    }

    Node N = NULL;

       if( L==NULL ){
          printf("List Error: calling printList() on NULL List reference\n");
          exit(EXIT_FAILURE);
       }

       for(N = L-&gt;front; N != NULL; N = N-&gt;next){
          fprintf(out, "%d ", N-&gt;data);
       }
       //printf("\n");

    return;
}

List copyList(List L)
{
    List newL = newList();

    Node tempCursor = L-&gt;cursor;
    int tempCursorIdx = L-&gt;cursorIdx;

    moveFront(L);
    while( index(L)&gt;=0 ){
        int x = get(L);

        append(newL, x);

        moveNext(L);
    }

    // return L to its starting state
    L-&gt;cursor = tempCursor;
    L-&gt;cursorIdx = tempCursorIdx;

    return (newL);
}

// Optional Operations - - - - - - - - - - - - -
List concatList(List A, List B)
{
    List newL = newList();

    // add A to new list
    moveFront(A);
    while( index(A)&gt;=0 ){
        int x = get(A);

        append(newL, x);

        moveNext(A);
    }

    // add B to new list
    moveFront(B);
    while( index(B)&gt;=0 ){
        int y = get(B);

        append(newL, y);

        moveNext(B);
</font>    }

    return (newL);
}
</pre>
</body>
</html>
