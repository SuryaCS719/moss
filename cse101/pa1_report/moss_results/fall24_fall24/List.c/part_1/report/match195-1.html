<html>
<head>
<title>/fall24/pjha2/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/sramach5/pa1/List.c<p></p><pre>
// List.c
// Author: Sriya Ramachandruni
// CruzID: sramach5
// Assignment: pa1



//Standard Includes
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

//Include the List header file
#include "List.h"

//Define the Node structure
typedef struct NodeObj{
  int data;

  //Pointers to the next and previous nodes
  struct NodeObj* next;   //null if at the end of the list
  struct NodeObj* prev;   //null if at the beginning of the list
} NodeObj;

//Define the Node type (Not necessary, but makes the code more readable)
typedef NodeObj* Node;

//Define the List structure
typedef struct ListObj{
  //Pointers to the front and back of the list
  Node front;
  Node back;

  //Pointer to the cursor node and its index (cursorIndex goes from 0 to length-1 and is -1 if the cursor is undefined)
  Node cursor;
  int cursorIndex;

  //Length of the list
  int length;
} ListObj;

//Define the List type (Also not necessary, but makes the code more readable)
typedef ListObj* List;



// Constructors-Destructors ---------------------------------------------------
//Create a new empty List
List newList(void){
  //Allocate memory for the new list
  List list = malloc(sizeof(ListObj));

  //Set the front, back, and cursor nodes to null
  list-&gt;front = NULL;
  list-&gt;back = NULL;
  list-&gt;cursor = NULL;

  //Set the cursor index to -1 and the length to 0
  list-&gt;cursorIndex = -1;
  list-&gt;length = 0;

  //Return the new list
  return list;
}

//Free all heap memory associated with the list and set the pointer to null
void freeList(List* pL){
  //Make sure the list exists
  if(pL != NULL &amp;&amp; *pL != NULL){
    //Make sure list is empty (if not clear the list)
    if((*pL)-&gt;length &gt; 0){
      clear(*pL);
    }

    //Free pointer
    free(*pL);
    *pL = NULL;
    pL = NULL;
  }
}

//New Node
Node newNode(int x){
  //Allocate memory
  Node node = malloc(sizeof(NodeObj));
  
  //Set data
  node-&gt;data = x;

  //Set side things to NULL
  node-&gt;prev = NULL;
  node-&gt;next = NULL;

  //Return Node
  return node;
}

//Free node
void freeNode(Node* node_pointer){
  if(node_pointer != NULL &amp;&amp; *node_pointer != NULL){
    //Free pointer
    free(*node_pointer);
    *node_pointer = NULL;
    node_pointer = NULL;
  }
}

// Access-Functions -----------------------------------------------------------
//Return the length of the list
int length(List L){
  //Make sure the list exists
  if(L == NULL){
    return -1;
  }

  //Return the length of the list
  return L-&gt;length;
}

//Return the index of the cursor element if defined, -1 otherwise
int index(List L){
  //Make sure the list exists
  if(L == NULL){
    return -1;
  }

  //Return the index of the cursor
  return L-&gt;cursorIndex;
}

//Return the front element of the list
int front(List L){
  //Make sure the list exists and is not empty
  if(L == NULL || L-&gt;length == 0){
    return -1;
  }

  //Return the data of the front node
  return L-&gt;front-&gt;data;
}

//Return the back element of the list
int back(List L){
  //Make sure the list exists and is not empty
  if(L == NULL || L-&gt;length == 0){
    return -1;
  }

  //Return the data of the back node
  return L-&gt;back-&gt;data;
}

//Return the data of the cursor node
int get(List L){
  //Make sure the list exists and is not empty
  if(L == NULL || L-&gt;length == 0){
    return -1;
  }

  //Make sure the cursor is defined
  if(L-&gt;cursorIndex == -1){
    return -1;
  }

  //Return the data of the cursor node
  return L-&gt;cursor-&gt;data;
}

//Return true if the lists contain the same sequence of elements, false otherwise
bool equals(List A, List B){
  //Make sure they exist
  if(!A || !B){
    return false;
  }

  //Check if they are the same length
  if(A-&gt;length != B-&gt;length){
    return false;
  }

  //Check if they are both empty
  if(A-&gt;length == 0 &amp;&amp; B-&gt;length == 0){
    return(true);
  }

  //Move to front
  moveFront(A);
  moveFront(B);

  //Go through each element
  for(int i = 0; i &lt; A-&gt;length; i++){
    if(get(A) != get(B)){
      return false;
    }
    moveNext(A);
    moveNext(B);
  }

  //If not all that, return true
  return true;
}


//Manipulation-Procedures ----------------------------------------------------
//Clear the list
void clear(List L){
  //Make sure the list exists
  if(L == NULL){
    return;
  }

  //Make sure the list is not empty
  if(L-&gt;length == 0){
    return;
  }

  //Free each node
  Node temp_node;
  Node node = L-&gt;front;

  //Go through each node
  while(node != L-&gt;back){
    temp_node = node-&gt;next;
    freeNode(&amp;node);
    node = temp_node;
  }

  //Free the last node
  free(L-&gt;back);
  L-&gt;front = NULL;
  L-&gt;back = NULL;
<a name="2"></a><font color="#0000FF"><a href="match195-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

  L-&gt;cursor = NULL;
  L-&gt;length = 0;
  L-&gt;cursorIndex = -1;
}

//Set the data of the cursor node
void set(List L, int x){
  //Set the data
  L-&gt;cursor-&gt;data = x;
}

//Move the cursor to the front of the list
void moveFront(List L){
  //Make sure the list exists
  if(L == NULL || L-&gt;length == 0){
</font>    return;
  }

  //Set the cursor to the front of the list
  L-&gt;cursor = L-&gt;front;
  L-&gt;cursorIndex = 0;
}

//Move the cursor to the back of the list
void moveBack(List L){
  //Make sure the list exists
  if(L == NULL || L-&gt;length == 0){
    return;
  }

  //Set the cursor to the back of the list
  L-&gt;cursor = L-&gt;back;
  L-&gt;cursorIndex = L-&gt;length - 1;
}

//Move the cursor to the previous node
void movePrev(List L){
  //Make sure the list exists
  if(L == NULL){
    return;
  }

  //If the cursor is defined and not at the front, move it one step toward the front
  if(L-&gt;cursor != NULL){
<a name="1"></a><font color="#00FF00"><a href="match195-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

    if(L-&gt;cursor != L-&gt;front){
      L-&gt;cursorIndex -= 1;
      L-&gt;cursor = L-&gt;cursor-&gt;prev;
    }else{
      L-&gt;cursor = NULL;
      L-&gt;cursorIndex = -1;
    }
  }
}

//Move the cursor to the next node
void moveNext(List L){
  //Make sure it do exist
  if(L == NULL){
    return;
</font>  }

  //If the cursor is at the end, we have to set it to NULL and index to -1
  if(L-&gt;cursor != NULL){
    if(L-&gt;cursor != L-&gt;back){
      L-&gt;cursorIndex += 1;
      L-&gt;cursor = L-&gt;cursor-&gt;next;
    }else{
      L-&gt;cursor = NULL;
      L-&gt;cursorIndex = -1;
    }
  }
}

//Add a new node to the front of the list
void prepend(List L, int x){
  //Allocate memory for the new node
  Node node = newNode(x);

  //If the list is not empty, add it to the front
  if(L-&gt;length &gt; 0){
    node-&gt;next = L-&gt;front;
    L-&gt;front-&gt;prev = node;
    L-&gt;front = node;
    //Increase cursor index if defined
    if(L-&gt;cursorIndex != -1){
      L-&gt;cursorIndex += 1;
    }
  } else {
    L-&gt;front = L-&gt;back = node;
  }

  //Increase nums
  L-&gt;length+=1;
}

//Append to the end (&lt;haha it rhymes)
void append(List L, int x){
  //Make sure it do exist
  if(L == NULL){
    return;
  }

  //Allocate memory for the new node
  Node node = newNode(x);

  //If empty, just and add it to the front
  if(L-&gt;length == 0){
    L-&gt;front = node;
    L-&gt;back = node;
  } else {
    node-&gt;prev = L-&gt;back;
<a name="0"></a><font color="#FF0000"><a href="match195-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

    L-&gt;back-&gt;next = node;
    L-&gt;back = node;
  }

  //Increase nums
  L-&gt;length+=1;
}


//Insert before the cursor
void insertBefore(List L, int x){
  //If the cursor is at the front, just prepend
  if(L-&gt;cursor == L-&gt;front){
    prepend(L, x);
    return;
  }

  //Allocate memory for the new node
  Node node = newNode(x);

  //Do the stuff
  Node node_before_cursor = L-&gt;cursor-&gt;prev;
  node-&gt;next = L-&gt;cursor;
  node-&gt;prev = node_before_cursor;
  L-&gt;cursor-&gt;prev = node;
  node_before_cursor-&gt;next = node;

  //Increase the nums
  L-&gt;length += 1;
  L-&gt;cursorIndex += 1;
}


//Insert after the cursor
void insertAfter(List L, int x){
</font>  //Make sure it does exist and is long enough
  if(L == NULL || L-&gt;length &lt; 0){
    return;
  }

  //If the cursor is in the back, just append
<a name="5"></a><font color="#FF0000"><a href="match195-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

  if(L-&gt;cursor == L-&gt;back){
    append(L, x);
    return;
  }

  //Allocate memory for the new node
  Node node = newNode(x);

  //If empty, just and add it to the front
  Node node_after_cursor = L-&gt;cursor-&gt;next;
  node-&gt;prev = L-&gt;cursor;
  node-&gt;next = node_after_cursor;
</font>  L-&gt;cursor-&gt;next = node;
  node_after_cursor-&gt;prev = node;

  //Increase the nums
  L-&gt;length+=1;
  L-&gt;cursorIndex+=1;
}


void deleteFront(List L){
   if(L-&gt;length == 1){
      clear(L);
      return;
   }
   if(index(L) &gt;= 0){
      L-&gt;cursorIndex -= 1;
   }
   if(L-&gt;cursor == L-&gt;front){
      L-&gt;cursor = NULL;
   }
   Node oldFront = L-&gt;front;
   L-&gt;front = oldFront-&gt;next;
   freeNode(&amp;oldFront);
   L-&gt;length -= 1;
}

void deleteBack(List L){
   if(L-&gt;length == 1){
      clear(L);
      return;
   }
   if(L-&gt;cursor == L-&gt;back){
      L-&gt;cursor = NULL;
      L-&gt;cursorIndex = -1;
   }
   Node back = L-&gt;back;
   L-&gt;back = NULL;
   L-&gt;back = back-&gt;prev;
   freeNode(&amp;back);
   L-&gt;length -= 1;
}

/*
//Delete the cursor element
void delete(List L){
  //Make sure it does exist and is long enough
  if(L == NULL &amp;&amp; L-&gt;length &gt; 0){
    return;
  }

  //If the cursor is defined
  if(L-&gt;cursorIndex &gt;= 0){
    //If the cursor is at the front
    if(L-&gt;cursorIndex == 0){
      deleteFront(L);
    } else if(L-&gt;cursorIndex == (L-&gt;length - 1)){
      deleteBack(L);
    } else {
      //Create in front of cursor
      Node inFront = L-&gt;cursor-&gt;next;
      Node inBack = L-&gt;cursor-&gt;prev;

      //Free cursor
      freeNode(&amp;(L-&gt;cursor));
      inFront-&gt;prev = inBack;
      inBack-&gt;next = inFront;

      //Set cursor to NULL
      L-&gt;cursor = NULL;
      L-&gt;cursorIndex = -1;
      L-&gt;length--;
    }
  }
}
*/

<a name="3"></a><font color="#00FFFF"><a href="match195-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

void delete(List L){
   if(L-&gt;cursor == L-&gt;front){
      deleteFront(L);
      return;
   }
   if(L-&gt;cursor == L-&gt;back){
      deleteBack(L);
      return;
   }
   Node cursor = L-&gt;cursor;
</font>   Node node_before_cursor = cursor-&gt;prev;
<a name="4"></a><font color="#FF00FF"><a href="match195-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

   Node node_after_cursor = cursor-&gt;next;
   if(node_before_cursor) node_before_cursor-&gt;next = node_after_cursor;
   if(node_after_cursor) node_after_cursor-&gt;prev = node_before_cursor;
   L-&gt;cursor = NULL;
   L-&gt;cursorIndex = -1;
   freeNode(&amp;cursor);
</font>   L-&gt;length -= 1;
}

//Other operations -----------------------------------------------------------
//Print the list
void printList(FILE* out, List L){
  //Make sure it exists
  if(L == NULL){
    return;
  }

  //Move to front
  moveFront(L);

  //Print each element
  for(int i = 0; i &lt; L-&gt;length; i++){
    fprintf(out, "%d ", get(L));
    moveNext(L);
  }
}

//Copy the list
List copyList(List L){
  //Create a new list
  List new_list = newList();

  //Remember the cursor index
  int cursor_index = L-&gt;cursorIndex;

  //Move to front
  moveFront(L);

  //Copy each element
  while(index(L) &gt;= 0){
    append(new_list, get(L));
    moveNext(L);
  }

  //Move the cursor back to where it was in the original list
  moveFront(L);
  while (index(L) != cursor_index){
    moveNext(L);
  }

  //Return the new list
  return new_list;
}

</pre>
</body>
</html>
