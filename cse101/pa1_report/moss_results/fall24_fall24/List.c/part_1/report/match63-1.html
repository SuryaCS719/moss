<html>
<head>
<title>/fall24/mkestelo/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/mkestelo/pa1/List.c<p></p><pre>
/****************************************************************************************
*  Name: Milo Kesteloot
*  CruzID: 2051985
*  Assignment Name: pa1
*****************************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "List.h"


<a name="1"></a><font color="#00FF00"><a href="match63-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

typedef struct NodeObj* Node;

typedef struct NodeObj {
    Node nextNode;
    Node prevNode;
    int value;
} NodeObj;

typedef struct ListObj {
    Node frontNode;
    Node backNode;
    Node cursorNode;
    int cursor;
    int length;
} ListObj;


// Constructors-Destructors ---------------------------------------------------

List newList(void) {
    List list = malloc(sizeof(ListObj));
    
    list-&gt;frontNode = NULL;
    list-&gt;backNode = NULL;
    list-&gt;cursorNode = NULL;
    list-&gt;cursor = -1;
    list-&gt;length = 0;
    
    return list;
}

// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List* pL) {
    NodeObj* node = (*pL)-&gt;frontNode;
    while (node != NULL) {
        NodeObj* nextNode = node-&gt;nextNode;
        free(node);
        node = nextNode;
    }
    free(*pL);
    *pL = NULL;
}


// Access functions -----------------------------------------------------------

// Returns the number of elements in L.
int length(List L) { return L-&gt;length; }

// Returns index of cursor element if defined, -1 otherwise.
int index(List L) { return L-&gt;cursor; }
</font>
// Returns front element of L. Pre: length()&gt;0
int front(List L) { return L-&gt;frontNode-&gt;value; }

// Returns back element of L. Pre: length()&gt;0
<a name="0"></a><font color="#FF0000"><a href="match63-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_86.gif"/></a>

int back(List L) { return L-&gt;backNode-&gt;value; }

// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L) { return L-&gt;cursorNode-&gt;value; }

// Returns true if Lists A and B contain the same sequence of elements, returns false otherwise.
bool equals(List A, List B) {
    if (A-&gt;length != B-&gt;length) return false;
    NodeObj* a = A-&gt;frontNode;
    NodeObj* b = B-&gt;frontNode;
    while (a != NULL) {
        if (a-&gt;value != b-&gt;value) return false;
        a = a-&gt;nextNode;
        b = b-&gt;nextNode;
    }
    return true;
}


// Manipulation procedures ----------------------------------------------------

// Resets L to its original empty state.
void clear(List L) {
    NodeObj* node = L-&gt;frontNode;
    while (node != NULL) {
        NodeObj* nextNode = node-&gt;nextNode;
        free(node);
        node = nextNode;
    }
    L-&gt;frontNode = NULL;
    L-&gt;backNode = NULL;
    L-&gt;cursorNode = NULL;
    L-&gt;length = 0;
    L-&gt;cursor = -1;
}
 
// Overwrites the cursor elementâ€™s data with x. Pre: length()&gt;0, index()&gt;=0
void set(List L, int x) { L-&gt;cursorNode-&gt;value = x; }

// If L is non-empty, sets cursor under the front element, otherwise does nothing.
void moveFront(List L) {
    if (L-&gt;length == 0) return;
    L-&gt;cursor = 0;
    L-&gt;cursorNode = L-&gt;frontNode;
}

// If L is non-empty, sets cursor under the back element, otherwise does nothing.
void moveBack(List L) {
    if (L-&gt;length == 0) return;
    L-&gt;cursor = L-&gt;length - 1;
    L-&gt;cursorNode = L-&gt;backNode;
}

// If cursor is defined and not at front, move cursor one step toward the front of L;
// if cursor is defined and at front, cursor becomes undefined;
// if cursor is undefined do nothing
void movePrev(List L) {
    if (L-&gt;cursor == -1) return;
    L-&gt;cursor -= 1;
    L-&gt;cursorNode = L-&gt;cursorNode-&gt;prevNode;
}

// If cursor is defined and not at back, move cursor one step toward the back of L;
// if cursor is defined and at back, cursor becomes undefined; if cursor is undefined do nothing
void moveNext(List L) {
    if (L-&gt;cursor == -1) return;
    if (L-&gt;cursor == L-&gt;length-1) L-&gt;cursor = -1;
    else L-&gt;cursor += 1;
    L-&gt;cursorNode = L-&gt;cursorNode-&gt;nextNode;
}

// Get NodeObj at index L
// (Custom function)
NodeObj* getNodeObjAt(List L, int x) {
    if (L-&gt;length == 0 || x &gt;= L-&gt;length || x &lt; 0) return NULL;
    NodeObj* node = L-&gt;frontNode;
    for (int i = 0; i &lt; x; i++) {
        node = node-&gt;nextNode;
    }
    return node;
}

// Insert new element into L before element index.
// (Custom function)
void insertAt(List L, int x, int index) {
    L-&gt;length += 1;

    if (L-&gt;cursor != -1 &amp;&amp; index &lt;= L-&gt;cursor) {
        L-&gt;cursor += 1;
    }

    NodeObj* newNode = calloc(1, sizeof(NodeObj));
    newNode-&gt;nextNode = NULL;
    newNode-&gt;prevNode = NULL;
    newNode-&gt;value = x;

    if (L-&gt;length == 1) {
        L-&gt;frontNode = newNode;
        L-&gt;backNode = newNode;
        return;
    }

    if (index == 0) {
        L-&gt;frontNode-&gt;prevNode = newNode;
        newNode-&gt;nextNode = L-&gt;frontNode;
        L-&gt;frontNode = newNode;
        return;
    }

    if (index == L-&gt;length - 1) {
        L-&gt;backNode-&gt;nextNode = newNode;
        newNode-&gt;prevNode = L-&gt;backNode;
        L-&gt;backNode = newNode;
        return;
    }

    NodeObj* nodeAfter = getNodeObjAt(L, index);
    NodeObj* nodeBefore = nodeAfter-&gt;prevNode;
    nodeBefore-&gt;nextNode = newNode;
    nodeAfter-&gt;prevNode = newNode;
    newNode-&gt;nextNode = nodeAfter;
    newNode-&gt;prevNode = nodeBefore;
}

// Insert new element into L. If L is non-empty, insertion takes place before front element.
void prepend(List L, int x) {
    insertAt(L, x, 0);
}

// Insert new element into L. If L is non-empty, insertion takes place after back element.
void append(List L, int x) {
    insertAt(L, x, L-&gt;length);
}

// Insert new element before cursor. Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
    insertAt(L, x, L-&gt;cursor);
}

// Insert new element after cursor. Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
    insertAt(L, x, L-&gt;cursor + 1);
}

// Delete element at index
// (Custom function)
void deleteItem(List L, int index) {
    NodeObj* clearingNode = getNodeObjAt(L, index);

    L-&gt;length -= 1;
   
    if (L-&gt;length == 0) {
        L-&gt;frontNode = NULL;
        L-&gt;backNode = NULL;
        L-&gt;cursorNode = NULL;
        L-&gt;cursor = -1;
        free(clearingNode);
        return;
    }

    if (L-&gt;cursor == index) {
        L-&gt;cursor = -1;
        L-&gt;cursorNode = NULL;
    }

    if (L-&gt;cursor &gt; index) {
        L-&gt;cursor -= 1;
    }

    if (index == 0) {
        printList(stdout, L);
        L-&gt;frontNode-&gt;nextNode-&gt;prevNode = NULL;
        L-&gt;frontNode = L-&gt;frontNode-&gt;nextNode;
        printList(stdout, L);
        free(clearingNode);
        return;
    }
    if (index == L-&gt;length) {
        L-&gt;backNode-&gt;prevNode-&gt;nextNode = NULL;
        L-&gt;backNode = L-&gt;backNode-&gt;prevNode;
        free(clearingNode);
        return;
    }

    clearingNode-&gt;prevNode-&gt;nextNode = clearingNode-&gt;nextNode;
    clearingNode-&gt;nextNode-&gt;prevNode = clearingNode-&gt;prevNode;
    free(clearingNode);

    if (index == L-&gt;cursor) {
        L-&gt;cursor = -1;
        L-&gt;cursorNode = NULL;
    }
}

// Delete the front element. Pre: length()&gt;0
void deleteFront(List L) {
    deleteItem(L, 0);
}

// Delete the back element. Pre: length()&gt;0 
void deleteBack(List L) {
    deleteItem(L, L-&gt;length - 1);
}

// Delete cursor element, making cursor undefined. Pre: length()&gt;0, index()&gt;=0
void delete(List L) {
    deleteItem(L, L-&gt;cursor);
}


// Other operations -----------------------------------------------------------

// Prints to the file pointed to by out, a string representation of L consisting of a space separated sequence of integers, with front on left.
void printList(FILE* out, List L) {
    NodeObj* node = L-&gt;frontNode;
    bool first = true;
    while(node != NULL) {
        if (!first) {
            fprintf(out, " ");
        } else {
            first = false;
        }
        fprintf(out, "%d", node-&gt;value);
        node = node-&gt;nextNode;
    }
}

// Returns a new List representing the same integer sequence as L.
// The cursor in the new list is undefined, regardless of the state of the cursor in L. The state of L is unchanged.
List copyList(List L) {
    List L2 = newList();

    NodeObj* node = L-&gt;frontNode;
    while (node != NULL) {
        append(L2, node-&gt;value);
        node = node-&gt;nextNode;
    }
    L2-&gt;length = L-&gt;length;

    return L2;
}

// Extra functions ------------------------------------------------------------


// Returns a new List which is the concatenation of A and B.
// The cursor in the new List is undefined, regardless of the states of the cursors in A and B.
// The states of A and B are unchanged.
List concatList(List A, List B) {
    List C = newList();

    NodeObj* node = A-&gt;frontNode;
    while (node != NULL) {
        append(C, node-&gt;value);
        node = node-&gt;nextNode;
    }
    node = B-&gt;frontNode;
    while (node != NULL) {
        append(C, node-&gt;value);
        node = node-&gt;nextNode;
    }

    C-&gt;length = A-&gt;length + B-&gt;length;
</font>    return C;
}
</pre>
</body>
</html>
