<html>
<head>
<title>/fall24/nrliu/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/nrliu/pa1/List.c<p></p><pre>
//-----------------------------------------------------------------------------
// List.c
// Implementation file for Queue ADT
//-----------------------------------------------------------------------------
/***
* Nathan Liu // First and Last Name
* nrliu // UCSC UserID
* 2024 Fall CSE101 PA1 // Replace ID with assignment number
* List.c // FileName
* List ADT Implementation // Description
***/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include "List.h"
#define COLOR_BOLD  "\e[1m"
#define COLOR_OFF   "\e[m"

//structs
typedef struct NodeObj* Node;

//private NodeObj type
<a name="0"></a><font color="#FF0000"><a href="match74-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_83.gif"/></a>

typedef struct NodeObj {
	ListElement data;
	Node next;
	Node prev;
} NodeObj;

typedef struct ListObj {
	Node front;
	Node back;
	Node cur;
	int index;
	int length;
} ListObj;
//
// Constructors-Destructors ---------------------------------------------------
//List newList(void); // Creates and returns a new empty List.
List newList (void) {
	List L;
	L = malloc(sizeof(ListObj));
	assert(L != NULL);
	L-&gt;front = NULL;
	L-&gt;back = NULL;
	L-&gt;cur = NULL;
	L-&gt;length = 0;
	L-&gt;index = -1;
	return L;
}

Node newNode(int x) {
	Node N;
	N = malloc(sizeof(NodeObj));
	assert(N != NULL);
	N-&gt;next = NULL;
	N-&gt;data = x;
	N-&gt;prev = NULL;
	return N;
}

//void freeList(List* pL); // Frees all heap memory associated with *pL, and sets pL to null.
void freeList(List* pL) {
	clear(*pL);
	free(*pL);
	pL = NULL;
}

// Access functions -----------------------------------------------------------
//int length(List L); // Returns the number of elements in L.
int length(List L) {
	return L-&gt;length;
}
//int index(List L); // Returns index of cursor element if defined, -1 otherwise.
int index(List L) {
	return L-&gt;index;
}

//int front(List L); // Returns front element of L. Pre: length()&gt;0
int front(List L) {
	if (length(L) &lt;= 0) {
		printf("tried to return the front element but the list was empty");
		exit(EXIT_FAILURE);
	}
	return L-&gt;front-&gt;data;
}
//int back(List L); // Returns back element of L. Pre: length()&gt;0
int back(List L) {
	if (L-&gt;length &lt;= 0) {
		printf("tried to return the back element but the list was empty");
		exit(EXIT_FAILURE);
	}
	return L-&gt;back-&gt;data;
}
//int get(List L); // Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List L) {
	if (length(L) &lt;= 0) {
		printf("tried to return the cursor but the list was empty.");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("tried to return the cursor but the position wasn't in the array");
		exit(EXIT_FAILURE);
	}
	return L-&gt;cur-&gt;data;
}

//bool equals(List A, List B); // Returns true iff Lists A and B contain the same
// sequence of elements, returns false otherwise.
bool equals(List A, List B) {
	Node A_ptr = A-&gt;front;
	Node B_ptr = B-&gt;front;
	while (A_ptr != NULL || B_ptr != NULL) {
		if ((A_ptr == NULL) != (B_ptr == NULL)) {
			return false;
		}
		if (A_ptr-&gt;data != B_ptr-&gt;data) {
			return false;
		}
		A_ptr = A_ptr-&gt;next;
		B_ptr = B_ptr-&gt;next;
	}
	return true;
}
// Manipulation procedures ----------------------------------------------------
//void clear(List L); // Resets L to its original empty state.
void clear (List L) {
	while(length(L) &gt; 0) {
		deleteFront(L);
	}
	L-&gt;front = NULL;
	L-&gt;back = NULL;
	L-&gt;cur = NULL;
	L-&gt;length = 0;
	L-&gt;index = -1;
}

//void set(List L, int x); // Overwrites the cursor elementâ€™s data with x.
void set(List L, int x) {
	L-&gt;cur-&gt;data = x;
}
// Pre: length()&gt;0, index()&gt;=0
//void moveFront(List L); // If L is non-empty, sets cursor under the front element,
void moveFront(List L) {
	L-&gt;cur = L-&gt;front;
	L-&gt;index = 0;
}
// otherwise does nothing.
//void moveBack(List L); // If L is non-empty, sets cursor under the back element,

// otherwise does nothing.
void moveBack(List L) {
	L-&gt;cur = L-&gt;back;
	L-&gt;index = L-&gt;length - 1;
}
//void movePrev(List L); // If cursor is defined and not at front, move cursor one
// step toward the front of L; if cursor is defined and at
// front, cursor becomes undefined; if cursor is undefined
// do nothing
void movePrev(List L) {
	if (index(L) &lt; 0) {
		return;
	}
	L-&gt;cur = L-&gt;cur-&gt;prev;
	if (L-&gt;cur == NULL) {
		L-&gt;index = -1;
	}else{
		L-&gt;index--;
	}
}
//void moveNext(List L); // If cursor is defined and not at back, move cursor one
// step toward the back of L; if cursor is defined and at
// back, cursor becomes undefined; if cursor is undefined
// do nothing
void moveNext(List L) {
	if (index(L) &lt; 0) {
		return;
	}
	L-&gt;cur = L-&gt;cur-&gt;next;
	if (L-&gt;cur == NULL) {
		L-&gt;index = -1;
	}else{
		L-&gt;index++;
	}
}
//void prepend(List L, int x); // Insert new element into L. If L is non-empty,
// insertion takes place before front element.

void firstNode(List L, int x) {
	Node N = newNode(x);
	L-&gt;length = 1;
	L-&gt;front = N;
	L-&gt;back = N;
}

void prepend(List L, int x) {
	if (length(L) &lt;= 0) {
		firstNode(L, x);
		return;
	}
	Node N = newNode(x);
	N-&gt;next = L-&gt;front;
	L-&gt;front-&gt;prev = N;
	L-&gt;length++;
	L-&gt;front = N;
	if (L-&gt;index &gt;= 0) {
		L-&gt;index++;
	}
}

//void append(List L, int x); // Insert new element into L. If L is non-empty,
// insertion takes place after back element.
void append(List L, int x) {
	if (length(L) &lt;= 0) {
		firstNode(L, x);
		return;
	}
	Node N = newNode(x);
	N-&gt;prev = L-&gt;back;
	L-&gt;back-&gt;next = N;
	L-&gt;length++;
	L-&gt;back = N;
}
//void insertBefore(List L, int x); // Insert new element before cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
	if (length(L) &lt;= 0) {
		printf("tried to insert before but the length was 0");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("tried to insert before but the index was less than 0");
		exit(EXIT_FAILURE);
	}
	Node N = newNode(x);
	Node before = L-&gt;cur-&gt;prev;
	L-&gt;index++;
	N-&gt;next = L-&gt;cur;
	N-&gt;prev = before;
	L-&gt;cur-&gt;prev = N;
	if (before != NULL) {
		before-&gt;next = N;
	}else{
		L-&gt;front = N;
	}
	L-&gt;length++;
	
}
//void insertAfter(List L, int x); // Insert new element after cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
	if (length(L) &lt;= 0) {
		printf("tried to insert after cursor but list was empty");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("tried to insert after cursor but cursor was undefined");
		exit(EXIT_FAILURE);
	}
	Node N = newNode(x);
	Node after = L-&gt;cur-&gt;next;
	L-&gt;cur-&gt;next = N;
	N-&gt;prev = L-&gt;cur;
	N-&gt;next = after;
	if (after != NULL) {
		after-&gt;prev = N;
	}else{
		L-&gt;back = N;
	}
	N-&gt;next = after;
	L-&gt;length++;
}
//void deleteFront(List L); // Delete the front element. Pre: length()&gt;0
void deleteFront(List L) {
	if (length(L) &lt;= 0) {
		printf("tried to delete front element but list was empty");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;front == L-&gt;cur) {
		L-&gt;cur = NULL;
		L-&gt;index = -1;
	}
	Node tmp = NULL;
	if (length(L) &gt; 1){
		L-&gt;front-&gt;next-&gt;prev = NULL;
	}
	if (index(L) &gt;= 0) {
		L-&gt;index--;
	}
	tmp = L-&gt;front;
	L-&gt;front = tmp-&gt;next;
	free(tmp);
	tmp = NULL;
	L-&gt;length--;
}
//void deleteBack(List L); // Delete the back element. Pre: length()&gt;0
void deleteBack(List L) {
	if (length(L) &lt;= 0) {
		printf("tried to delete back element but list was empty");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;cur == L-&gt;back) {
		L-&gt;cur = NULL;
		L-&gt;index = -1;
	}
	Node tmp = NULL;
	if (length(L) &gt; 1) {
		L-&gt;back-&gt;prev-&gt;next = NULL;
	}
	tmp = L-&gt;back;
	L-&gt;back = tmp-&gt;prev;
	free(tmp);
	L-&gt;length--;
}
//void delete(List L); // Delete cursor element, making cursor undefined.
// Pre: length()&gt;0, index()&gt;=0
void delete(List L) {
	if (length(L) &lt;= 0) {
		printf("tried to delete but list was empty");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("tried to delete but index was undefined");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;cur-&gt;prev != NULL) {
		L-&gt;cur-&gt;prev-&gt;next = L-&gt;cur-&gt;next;
	}else{
		//if cur-&gt;prev is null, we are at the front.
		L-&gt;front = L-&gt;cur-&gt;next;
</font>	}
<a name="1"></a><font color="#00FF00"><a href="match74-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

	if (L-&gt;cur-&gt;next != NULL) {
		L-&gt;cur-&gt;next-&gt;prev = L-&gt;cur-&gt;prev;
	}else{
		//if cur-&gt;next is null, we are at the back.
		L-&gt;back = L-&gt;cur-&gt;prev;
	}
	Node tmp = L-&gt;cur;
	L-&gt;cur = NULL;
	free(tmp);
	tmp = NULL;
	L-&gt;index = -1;
	L-&gt;length--;
}
// Other operations -----------------------------------------------------------
//void printList(FILE* out, List L); // Prints to the file pointed to by out, a
// string representation of L consisting
// of a space separated sequence of integers,
// with front on left.
void printList(FILE* out, List L) { 
</font>	Node curr = L-&gt;front;
	while (curr != NULL) {
		fprintf(out, "%d ", curr-&gt;data);
		curr = curr-&gt;next;
	}
	fprintf(out, "\n");
}
//List copyList(List L); // Returns a new List representing the same integer
// sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.
List copyList(List L) {
	List res = newList();
	Node curr = L-&gt;front;
	while (curr != NULL) {
		append(res, curr-&gt;data);
		curr = curr-&gt;next;
	}
	return res;
}
//List concatList(List A, List B); // Returns a new List which is the concatenation of
// A and B. The cursor in the new List is undefined,
// regardless of the states of the cursors in A and B.
// The states of A and B are unchanged.
List concatList(List A, List B) {
	List res = copyList(A);
	Node curr = B-&gt;front;
	while (curr != NULL) {
		append(res, curr-&gt;data);
		curr = curr-&gt;next;
	}
	return res;
}
</pre>
</body>
</html>
