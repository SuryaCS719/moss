<html>
<head>
<title>/fall24/lharnist/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/lharnist/pa1/List.c<p></p><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "list.h"

<a name="0"></a><font color="#FF0000"><a href="match85-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef struct NodeObj* Node;

typedef struct NodeObj{
   ListObj data;
   Node next;
   Node prev;
} NodeObj;

typedef struct ListObj{
   *ListObj item;       // list of nodes
   int length;          // number of items in this Queue
   int front;           // index of front element
   int back;            // index of back element
   int cursor;          // index of cursor
} ListObj;

// Constructors-Destructors ---------------------------------------------------

List newList(){
	List L;
	L = malloc(sizeof(ListObj));
	assert(L!=Null);
	L-&gt;item = calloc(1, sizeof(ListObj));
	assert(L-&gt;item!=NULL);
	L-&gt;length = 0;
	L-&gt;front = 0;
	L-&gt;back = -1;
	L-&gt;cursor = -1;
	return(L);

}

void freeList(List* pL){
   if(pL!=NULL &amp;&amp; *pL!=NULL) {
      free((*pL)-&gt;item);
      free(*pL);
      *pL = NULL;
   }
}

// Access functions -----------------------------------------------------------

int length(List L){
	return L-&gt;length;
}

int index(List L){
	return L-&gt;cursor;
}

int front(List L){
	if(length(L) &gt; 0){
		return L-&gt;front; // look at dis later
	}
	else{
		fprintf(stderr, "List error: calling front() on undefined length (length &lt; 0)\n");
	}
}

int back(List L){
	if(length(L) &gt; 0){
                return L-&gt;back; // look at dis later
        }
        else{
                fprintf(stderr, "List error: calling back() on undefined length (length &lt; 0)\n");
        }
}

int get(List L){
	if((length(L) &gt; 0) &amp;&amp; (L-&gt;cursor &gt;= 0)){
                return L-&gt;cursor; // look at dis later
        }
        else{
                fprintf(stderr, "List error: calling get() on undefined length of L or cursor is -1\n");
        }
}

bool equals(List A, List B){
	return A == B;
}

// Manipulation procedures ----------------------------------------------------

void clear(List L){
	L-&gt;length = InitialSize;
	L-&gt;front = 0;
	L-&gt;back = -1;
	L-&gt;cursor = -1;
}

void set(List L, int x){
	L-&gt;cursor = x;
}

void moveFront(List L){
	L-&gt;cursor = L-&gt;front; 
}

void moveBack(List L){
	L-&gt;cursor = L-&gt;back;
}

void movePrev(List L){
	if(L-&gt;cursor == -1){
		L-&gt;cursor = -1;
	}
	else if(L-&gt;cursor == L-&gt;front){
		L-&gt;cursor = -1;
	}
	else{
		L-&gt;cursor -= 1; 
	}
}


void moveNext(List L){
	if(L-&gt;cursor == -1){
                L-&gt;cursor = -1;
        }
        else if(L-&gt;cursor == L-&gt;back){
                L-&gt;cursor = -1;
        }
        else{
                L-&gt;cursor += 1;
        }
}

void prepend(List L, int x){
	if(L-&gt;length == 0){
		Node* newNode = malloc(sizeof(Node));
		newNode-&gt;data = x;
		L-&gt;item[0] = newNode;
	}
	else{
		Node* newNode = malloc(sizeof(Node));
		newNode-&gt;data = x;
		L-&gt;item[0]-&gt;prev = newNode;
		newNode-&gt;next = L-&gt;item[0];
	}
	L-&gt;length += 1;
	L-&gt;back += 1;
}

void append(List L, int x){
	if(L-&gt;length == 0){
		Node* newNode = malloc(sizeof(Node));
		newNode-&gt;data = x
                L-&gt;item[0] = newNode;
        }
        else{
                Node* newNode = malloc(sizeof(Node));
                newNode-&gt;data = x;
                L-&gt;item[L-&gt;back]-&gt;next = newNode;
		newNode-&gt;prev = L-&gt;item[L-&gt;back];

        }
	L-&gt;back += 1;
	L-&gt;length += 1;
}

void insertBefore(List L, int x){
	L-&gt;length += 1;
	if ((length(L) &lt;= 0) || (L-&gt;cursor &lt; 0)) {
		fprintf(stderr, "List error: calling insertBefore() on empty list or undefined cursor\n");
		return;
	}
	else if ((length(L) &gt; 0) &amp;&amp; (L-&gt;cursor &gt;= 0)) {
		Node* newNode = malloc(sizeof(Node));
		newNode-&gt;data = x;
		L-&gt;item[L-&gt;cursor]-&gt;prev-&gt;next = newNode;
		newNode-&gt;next = L-&gt;item[L-&gt;cursor];
	}
	L-&gt;back += 1;
}

void insertAfter(List L, int x){
        
        if ((length(L) &lt;= 0) || (L-&gt;cursor &lt; 0)) {
                fprintf(stderr, "List error: calling insertAfter() on empty list or undefined cursor\n");
                return;
        }
        else if ((length(L) &gt; 0) &amp;&amp; (L-&gt;cursor &gt;= 0)) {
                Node* newNode = malloc(sizeof(Node));
                newNode-&gt;data = x;
		L-&gt;item[L-&gt;cursor]-&gt;next-&gt;prev = newNode;
                L-&gt;item[L-&gt;cursor]-&gt;next = newNode;
		newNode-&gt;next = L-&gt;item[L-&gt;cursor+1]-&gt;next;
		newNode-&gt;prev = L-&gt;item[L-&gt;cursor];	
        }
        L-&gt;back += 1;
	L-&gt;length -= 1;
}


void deleteFront(List L){
	if((length(L) &lt;= 0)){
		fprintf(stderr, "List error: calling deleteFront() on empty list\n")
	}
	else{
		L-&gt;length -= 1;
		L-&gt;item[L-&gt;front]-&gt;next-&gt;prev = NULL;
		L-&gt;item[L-&gt;front]-&gt;next = NULL;
		free(L-&gt;item[front]);
	}
}

void deleteBack(List L){
        if((length(L) &lt;= 0)){
                fprintf(stderr, "List error: calling deleteBack() on empty list\n")
        }
	else{
		L-&gt;length -= 1;
		L-&gt;item[back]-&gt;prev = NULL;
		L-&gt;item[back]-&gt;prev-&gt;next = NULL;
		free(L-&gt;item[back]);


	}
}

void delete(List L){
	if((length(L) &lt;= 0 || L-&gt;item[L-&gt;cursor] &lt; 0)){
                fprintf(stderr, "List error: calling delete() on empty list\n")
        }
	else if((L-&gt;cursor != L-&gt;front) &amp;&amp; (L-&gt;cursor != L-&gt;back)){
		L-&gt;item[L-&gt;cursor - 1]-&gt;next = L-&gt;item[L-&gt;cursor+1];
		L-&gt;item[L-&gt;cursor + 1]-&gt;prev = L-&gt;item[L-&gt;cursor-1];
	}
	else if(L-&gt;cursor == L-&gt;front){
		deleteFront(L);
	}
	else{
		deleteBack(L);
</font>	}
}

</pre>
</body>
</html>
