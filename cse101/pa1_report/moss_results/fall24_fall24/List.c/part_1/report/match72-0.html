<html>
<head>
<title>/fall24/ndistefa/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/ndistefa/pa1/List.c<p></p><pre>
// Niko DiStefano
// 2019667
// PA1

#include "List.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

<a name="0"></a><font color="#FF0000"><a href="match72-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef struct NodeObj* Node;

typedef struct NodeObj {
    Node next;
    Node prev;
    int value;
} NodeObj;

typedef struct ListObj {
    Node first;
    Node last;
    size_t cursor;
    int len;
} ListObj;

#define RED "\033[0;31m"

List newList() {
    List l = malloc(sizeof(struct ListObj));
    l-&gt;first = NULL;
    l-&gt;last = NULL;
    l-&gt;cursor = -1;
    l-&gt;len = 0;
    return l;
}

void freeList(List* l) {
    List list = *l;
    if (list-&gt;first != NULL) {
        for (Node n = list-&gt;first-&gt;next; n != NULL; n = n-&gt;next) {
            free(n-&gt;prev);
        }
        if (list-&gt;last != NULL) {
            free(list-&gt;last);
        }
    }
    free(list);
}

int get(List l) {
    size_t i = 0;
    for (Node n = l-&gt;first; n != NULL; n = n-&gt;next) {
        if (i == l-&gt;cursor) {
            return n-&gt;value;
        }
        i++;
    }
    fprintf(stderr, "%sError: Tried to get element at cursor undefined\n", RED);
    exit(1);
    return 0;
}

void set(List l, int value) {
    size_t i = 0;
    for (Node n = l-&gt;first; n != NULL; n = n-&gt;next) {
        if (i == l-&gt;cursor) {
            n-&gt;value = value;
            return;
        }
        i++;
    }
    fprintf(stderr, "%sError: Cannot call \"set()\" when cursor is undefined\n", RED);
    exit(1);
}

int length(List l) { return l-&gt;len; }

int index(List l) { return l-&gt;cursor; }

int front(List l) {
    if (l-&gt;first != NULL) {
        return l-&gt;first-&gt;value;
    }
    fprintf(stderr, "%sError: Cannot get front of empty list\n", RED);
    exit(1);
    return 0;
}

int back(List l) {
    if (l-&gt;last != NULL) {
        return l-&gt;last-&gt;value;
    }
    fprintf(stderr, "%sError: Cannot get back of empty list\n", RED);
    exit(1);
    return 0;
}

bool equals(List l1, List l2) {
    if (l1-&gt;len != l2-&gt;len) {
        return false;
    }
    Node n1 = l1-&gt;first;
    Node n2 = l2-&gt;first;
    for (size_t i = 0; i &lt; l1-&gt;len; i++) {
        if (n1-&gt;value == n2-&gt;value) {
            n1 = n1-&gt;next;
            n2 = n2-&gt;next;
            continue;
        }
        return false;
    }
    return true;
}

void clear(List l) {
    Node n = l-&gt;first;
    while (n != NULL) {
        Node next = n-&gt;next;
        free(n);
        n = next;
    }
    l-&gt;first = NULL;
    l-&gt;last = NULL;
    l-&gt;len = 0;
    l-&gt;cursor = -1;
}

void moveFront(List l) {
    if (l-&gt;len &lt;= 0) return;
    l-&gt;cursor = 0;
}

void moveBack(List l) {
    if (l-&gt;len &lt;= 0) return;
    l-&gt;cursor = l-&gt;len-1;
}

void movePrev(List l) {
    if (l-&gt;cursor &lt; 0) return;
    l-&gt;cursor--;
}

void moveNext(List l) {
    if (l-&gt;cursor == -1) return;
    l-&gt;cursor++;
    if (l-&gt;cursor &gt;= l-&gt;len) {
        l-&gt;cursor = -1;
    }
}

// Private
void putManual(List l, size_t index, int value) {
    if (index &lt; 0 || index &gt; l-&gt;len) {
        fprintf(stderr, "%sError: Cannot insert element, index out of bounds\n", RED);
        exit(1);
        return;
    }

    Node new = calloc(1, sizeof(NodeObj));
    new-&gt;prev = NULL;
    new-&gt;next = NULL;
    new-&gt;value = value;

    if (index == l-&gt;len) {
        if (l-&gt;last != NULL) {
            l-&gt;last-&gt;next = new;
        } else {
            l-&gt;first = new;
        }
        new-&gt;prev = l-&gt;last;
        l-&gt;last = new;
    } else {
        size_t i = 0;
        for (Node n = l-&gt;first; n != NULL; n = n-&gt;next) {
            if (i == index) {
                new-&gt;prev = n-&gt;prev;
                if (n-&gt;prev) {
                    n-&gt;prev-&gt;next = new;
                }
                new-&gt;next = n;
                n-&gt;prev = new;
                break;
            }
            i++;
        }
        if (new-&gt;prev == NULL) {
            l-&gt;first = new;
        }
        if (new-&gt;next == NULL) {
            l-&gt;last = new;
        }
    }

    l-&gt;len++;

    // DEBUG
    // int front = -999;
    // int back = -999;
    // if (l-&gt;first != NULL) front = l-&gt;first-&gt;value;
    // if (l-&gt;last != NULL) back = l-&gt;last-&gt;value;
    // printf("Added \"%i\" at index %lu, New length: %i, New front: %i, New back: %i. === ", value, index, l-&gt;len, front, back);
    // printf("New list: { ");
    // printList(stdout, l);
    // printf("}\n");
}

// Private
void deleteManual(List l, size_t index) {
    if (index &lt; 0 || index &gt;= l-&gt;len) {
        fprintf(stderr, "Error: Cannot delete element, index out of bounds\n");
        exit(1);
        return;
    }
    l-&gt;len--;
    size_t i = 0;
    for (Node n = l-&gt;first; n != NULL; n = n-&gt;next) {
        if (i == index) {
            if (n == l-&gt;first) {
                l-&gt;first = n-&gt;next;
            } else {
                n-&gt;prev-&gt;next = n-&gt;next;
            }
            if (n == l-&gt;last) {
                l-&gt;last = n-&gt;prev;
            } else {
                n-&gt;next-&gt;prev = n-&gt;prev;
            }
            free(n);
            return;
        }
        i++;
    }
}

void prepend(List l, int value) {
    putManual(l, 0, value);
    if (l-&gt;cursor &gt;= 0) {
        l-&gt;cursor++;
    }
}

void append(List l, int value) {
    putManual(l, l-&gt;len, value);
}

void insertBefore(List l, int value) {
    putManual(l, l-&gt;cursor, value);
    moveNext(l);
}

void insertAfter(List l, int value) {
    putManual(l, l-&gt;cursor+1, value);
}

void deleteFront(List l) {
    deleteManual(l, 0);
    if (l-&gt;cursor &gt;= 0) {
        l-&gt;cursor--;
    }
}

void deleteBack(List l) {
    deleteManual(l, l-&gt;len-1);
    if (l-&gt;cursor &gt;= l-&gt;len) {
        l-&gt;cursor = -1;
    }
}

void delete(List l) {
    deleteManual(l, l-&gt;cursor);
    l-&gt;cursor = -1;
}

void printList(FILE* out, List l) {
    for (Node n = l-&gt;first; n != NULL; n = n-&gt;next) {
        fprintf(out, "%i ", n-&gt;value);
    }
}

List copyList(List l) {
    List copy = newList();
    for (Node n = l-&gt;first; n != NULL; n = n-&gt;next) {
        append(copy, n-&gt;value);
    }
    return copy;
}

List concatList(List l1, List l2) {
    List concat = copyList(l1);
    for (Node n = l2-&gt;first; n != NULL; n = n-&gt;next) {
        append(concat, n-&gt;value);
</font>    }
    return concat;
}
</pre>
</body>
</html>
