<html>
<head>
<title>/fall24/echen89/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/echen89/pa1/List.c<p></p><pre>
// List.c
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include "list.h"

<a name="1"></a><font color="#00FF00"><a href="match37-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

typedef struct NodeObj* Node;

void freeNode(Node* pN);
// private NodeObj struct constructor-deconstructor
typedef struct NodeObj {
	int data;
    Node previousNode;
	Node nextNode;
} NodeObj;

Node newNode(int data) { // Creates and returns a new empty node
    Node N = malloc(sizeof(Node));
    N-&gt;previousNode = NULL;
    N-&gt;nextNode = NULL;
    N-&gt;data = data;
    return (N);
}
void freeNode(Node* pN) { // Frees all heap memory associated with *pN, and sets *pN to NULL
    if (pN != NULL &amp;&amp; *pN != NULL) {
        free(*pN);
        *pN == NULL;
    }
}
// private ListObj struct, constructor-deconstructor
typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int length;
    int cursorIndex;
} ListObj;

List newList(void) {
    List p = malloc(sizeof(List));
    p-&gt;front = p-&gt;back = p-&gt;cursor = NULL;
</font>    p-&gt;length = 0;
    p-&gt;cursorIndex = -1;
    return(p);
}
void freeList(List* pL) { // frees all heap memory associated with *pL, and sets *pL to NULL
    if (pL != NULL &amp;&amp; *pL != NULL) {
<a name="0"></a><font color="#FF0000"><a href="match37-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_87.gif"/></a>

        while (length(*pL) &gt; 0) {
            deleteFront(*pL);
        }
        free(*pL);
        *pL = NULL;
    }
}

// Access functions -----------------------------------------------------------
int length(List L) { // Returns the number of elements in L.
    return L-&gt;length;
}
int indexList(List L) { // Returns index of cursor element if defined, -1 otherwise.
    int indexList = L-&gt;cursorIndex;
    return indexList;
}
int front(List L) { // Returns front element of L. Pre: length()&gt;0
    if (L-&gt;length &gt; 0) {
        return L-&gt;front-&gt;data;
    }
    else {
        printf("List Error: calling front() on NULL List reference.\n");
        exit(EXIT_FAILURE);
        // return NULL;
    }
}
int back(List L) { // Returns back element of L. Pre: length()&gt;0
    if (L-&gt;length &gt; 0) {
        Node backNode = L-&gt;back;
        int backData = backNode-&gt;data;
        return backData;
    }
    else {
        printf("List Error: calling back() on NULL List reference.\n");
        exit(EXIT_FAILURE);
        // return NULL;
    }
}
int get(List L) { // Returns cursor element of L. Pre: length&gt;0, indexList()&gt;=0
    if ((length(L) &gt; 0) &amp;&amp; (L-&gt;cursorIndex &gt;= 0)) {
        return L-&gt;cursor-&gt;data;
    }
    else {
        printf("List Error: calling get() on NULL List reference.\n");
        exit(EXIT_FAILURE);
        // return NULL;
    }
}
bool equals(List A, List B) { // Returns true if Lists A and B contain the same sequence of elements, returns false otherwise.
    if (length(A) == 0 &amp;&amp; length(B) == 0) {
        return true;
    }
    else if (length(A) != length(B) || front(A) != front(B) || back(A) != back(B)) {
        return false;
    } 
    Node travellerA = A-&gt;back;
    Node travellerB = B-&gt;back;
    while (travellerA-&gt;previousNode != NULL) {
        if (travellerA-&gt;data != travellerB-&gt;data) {
            return false;
        }
        travellerA = travellerA-&gt;previousNode;
        travellerB = travellerB-&gt;previousNode;
    }
    return true;
}

// Manipulation procedures ----------------------------------------------------
void clear(List L) { // Resets L to its original empty state. NOTE: Nodes remain, but will no longer be attached to a list.
    L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;cursorIndex = -1;
}
void set(List L, int x) { // Overwrites the cursor element's data with x. Pre: length()&gt;0, index()&gt;=0
    if ((length(L) &gt; 0) &amp;&amp; (indexList(L) &gt;= 0)) {
        Node inserter = L-&gt;cursor;
        inserter-&gt;data = x;
    }
    else {
        printf("List Error: calling set() on NULL List reference.");
        exit(EXIT_FAILURE);
        // return NULL;
    }
}
void moveFront(List L) { // If L is non-empty, sets cursor under the front element, otherwise does nothing.
    L-&gt;cursor = L-&gt;front;
    L-&gt;cursorIndex = 0;
}
void moveBack(List L) { // If L is non-empty, sets cursor under the back element, otherwise does nothing.
    L-&gt;cursor = L-&gt;back;
    L-&gt;cursorIndex = (length(L) - 1);
}
void movePrev(List L) { // If cursor is defined and not at front, move cursor one step toward the front of L; if cursor is defined and at
                            // front, cursor becomes undefined; if cursor is undefined, do nothing
    if (L-&gt;cursor == L-&gt;front) {
        L-&gt;cursorIndex = -1;
        L-&gt;cursor = NULL;
    }
    else if (L-&gt;cursorIndex != -1) {
        Node inserter = L-&gt;cursor;
        L-&gt;cursor = inserter-&gt;previousNode;
        L-&gt;cursorIndex--;
    }
    else if (L-&gt;cursorIndex == -1) {
        printf("List Error: calling movePrev() with undefined cursor");
    }
}
void moveNext(List L) { // If cursor is defined and not at back, move cursor one step toward the back of L; if cursor is defined and at
                        // back, cursor becomes undefined; if cursor is undefined do nothing
    if ((L-&gt;cursorIndex != -1) &amp;&amp; (L-&gt;cursor != L-&gt;back)) {
        Node inserter = L-&gt;cursor;
        L-&gt;cursor = inserter-&gt;nextNode;
        L-&gt;cursorIndex++;
    }
    else if (L-&gt;cursor == L-&gt;back) {
        L-&gt;cursorIndex = -1;
        L-&gt;cursor = NULL;
    }
    else if (L-&gt;cursorIndex == -1) {
        printf("List Error: calling moveNext() with undefined cursor");
    }
}
void prepend(List L, int x) { // Insert new element into L. If L is non-empty, insertion takes place before front element.
    Node prepender = newNode(x);
    if (length(L) &gt; 0) { // if the list isn't empty, modify the front of the list to insert the prepender 
        prepender-&gt;nextNode = L-&gt;front;
        L-&gt;front-&gt;previousNode = prepender;
        L-&gt;front = prepender;
    }
    else { // otherwise, make the prepender the first element in the list.
        L-&gt;front = L-&gt;back = prepender;
    }
    L-&gt;length++;
}
void append(List L, int x) { // Insert new element into L. If L is non-empty, insertion takes place after back element.  
    Node appender = newNode(x);
    if (length(L) &gt; 0) {
        appender-&gt;previousNode = L-&gt;back;
        L-&gt;back-&gt;nextNode = appender;
        L-&gt;back = appender;
    }
    else {
        L-&gt;front = L-&gt;back = appender;
    }
    L-&gt;length++;
}
void insertBefore(List L, int x) {  // Insert new element before cursor. Pre: length()&gt;0, index()&gt;=0
    if (length(L) &gt; 0 &amp;&amp; indexList(L) &gt;= 0) {
        Node beforer = newNode(x);
        beforer-&gt;previousNode = L-&gt;cursor-&gt;previousNode;
        beforer-&gt;nextNode = L-&gt;cursor;
        L-&gt;cursor-&gt;previousNode = beforer;
        if (L-&gt;front == L-&gt;cursor) {
            L-&gt;front = beforer;
        }
        else {
            L-&gt;cursor-&gt;previousNode-&gt;previousNode-&gt;nextNode = beforer;
        }
        L-&gt;length++;
        L-&gt;cursorIndex++;
    }
    else {
        printf("List Error: calling insertBefore() with undefined cursor");
        exit(EXIT_FAILURE);
    }
}
void insertAfter(List L, int x) {  // Insert new element After cursor. Pre: length()&gt;0, index()&gt;=0
    if (length(L) &gt; 0 &amp;&amp; indexList(L) &gt;= 0) {
        Node afterer = newNode(x);
        afterer-&gt;previousNode = L-&gt;cursor;
        afterer-&gt;nextNode = L-&gt;cursor-&gt;nextNode;
        L-&gt;cursor-&gt;nextNode = afterer;
        if (L-&gt;back == L-&gt;cursor) {
            L-&gt;back = afterer;
        }
        else {
            L-&gt;cursor-&gt;nextNode-&gt;nextNode-&gt;previousNode = afterer;
        }
        L-&gt;length++;
    }
    else {
        printf("List Error: calling insertAfter() with undefined cursor");
        exit(EXIT_FAILURE);
    }
}
void deleteFront(List L) { // Delete the front element. Pre: length()&gt;0
    if (length(L) &gt; 0) {
        L-&gt;front = L-&gt;front-&gt;nextNode;
        freeNode(&amp;L-&gt;front-&gt;previousNode);
        L-&gt;front-&gt;previousNode = NULL;
        L-&gt;length--;
        if (L-&gt;cursorIndex &gt; 0) {
            L-&gt;cursorIndex--;
        }
    }
    else {
        printf("List Error: calling deleteFront() on empty list");
        exit(EXIT_FAILURE);
    }
}
void deleteBack(List L) { // Delete the back element. Pre: length()&gt;0
    if (length(L) &gt; 0) {
        L-&gt;back = L-&gt;back-&gt;previousNode;
        freeNode(&amp;L-&gt;back-&gt;nextNode);
        L-&gt;back-&gt;nextNode = NULL;
        L-&gt;length--;
        if (L-&gt;cursorIndex &gt; -1) {
            L-&gt;cursorIndex--;
        }
    }
    else {
        printf("List Error: calling deleteBack() on empty list");
        exit(EXIT_FAILURE);
    }
}
void delete(List L) { // Delete cursor element, making cursor undefined.
    if (length(L) &gt; 0 &amp;&amp; indexList(L) &gt;=0) { 
        if (L-&gt;cursor == L-&gt;front) {
            L-&gt;front = L-&gt;front-&gt;nextNode;
            L-&gt;front-&gt;previousNode = NULL; 
        }
        if (L-&gt;cursor == L-&gt;back) {
            L-&gt;back = L-&gt;back-&gt;previousNode;
            L-&gt;back-&gt;nextNode = NULL;
        }
        if ((L-&gt;cursor != L-&gt;front) &amp;&amp; (L-&gt;cursor != L-&gt;back)) {
            L-&gt;cursor-&gt;nextNode-&gt;previousNode = L-&gt;cursor-&gt;previousNode;
            L-&gt;cursor-&gt;previousNode-&gt;nextNode = L-&gt;cursor-&gt;nextNode;
        }
        L-&gt;length--;
        freeNode(&amp;L-&gt;cursor);
        L-&gt;cursor-&gt;nextNode = NULL;
        L-&gt;cursor-&gt;previousNode = NULL;
        L-&gt;cursorIndex = -1;
    }
}
List concatList(List A, List B){
    return A; // TO BE FINISHED AT A LATER DATE
}

// Other operations -----------------------------------------------------------
void printList(FILE* out, List L) { // Prints to the file pointed to by out, a string representation of L consisting                                
    if (L-&gt;length == 0) {           // of a space separated sequence of integers, with front on left.
        printf("List Error: calling printList() on empty list");
        exit(EXIT_FAILURE);
    }
    out = fopen("out.txt", "w");
    moveFront(L);
    // const char *listItem = L-&gt;cursor-&gt;data; 
    int listItem = L-&gt;cursor-&gt;data;
    int oldCurse = L-&gt;cursorIndex;

    fprintf(out, "%d", listItem);
    while (L-&gt;cursorIndex != (L-&gt;length-1)) {
        moveNext(L);
        listItem = L-&gt;cursor-&gt;data;
        fprintf(out, ", %d", listItem);
    }
    fclose(out);
}

List copyList(List L) { 
    List out = newList();
    int oldCurse = L-&gt;cursorIndex;
    int prepender;
    moveBack(L);
    while(out-&gt;length != L-&gt;length) {
        prepender = get(L);
        prepend(out, prepender);
        if (L-&gt;cursorIndex != -1) {
            movePrev(L);
        }
    }
    moveFront(L);
    while (L-&gt;cursorIndex != oldCurse) {
</font>        moveNext(L);
    }
    return out;
}</pre>
</body>
</html>
