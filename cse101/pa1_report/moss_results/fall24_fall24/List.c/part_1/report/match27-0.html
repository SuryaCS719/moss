<html>
<head>
<title>/fall24/bwalderm/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/bwalderm/pa1/List.c<p></p><pre>
/***
* Ben Walderman 
* bwalderm
* 2024 Fall CSE101 PA1
* List.c
* Implementation File for List ADT
***/ 

#include &lt;assert.h&gt;
#include "List.h"

<a name="0"></a><font color="#FF0000"><a href="match27-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_48.gif"/></a>

typedef struct NodeObj* Node;

typedef struct NodeObj {
    Node next;
    Node prev;
    int data;
} NodeObj;

typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int index;
    int length;
} ListObj;

Node createNode(int data) {
    Node n = (Node)malloc(sizeof(NodeObj));
    assert(n);
    n-&gt;data = data;
    n-&gt;prev = NULL;
    n-&gt;next = NULL;
    return n;
}

List newList(void) {
    List L = (List)malloc(sizeof(ListObj));
    assert(L);
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length = 0;
    return L;
}

void freeList(List* pL) {
    if(pL == NULL || *pL == NULL) {
        fprintf(stderr, "Error: Attempting to call freeList() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }

    List L = *pL;
    
    // Free all nodes in the list
    while(length(L) &gt; 0) {
        deleteFront(L);
    }
    
    // Free the List struct itself
    free(L);
    *pL = NULL;
}

int length(List L) {
    return L-&gt;length;
}

int index(List L) {
    return L-&gt;index;
}

bool isEmpty(List L) {
    if(L-&gt;length &lt; 1) return true;
    return false;
}

int front(List L) {
    if(!L) {
        fprintf(stderr, "Error: Attempting to call front() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if(isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call front() on empty list\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;front-&gt;data;
}

int back(List L) {
    if(!L) {
        fprintf(stderr, "Error: Attempting to call back() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if(isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call back() on empty list\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;back-&gt;data;
}

int get(List L) {
    if(!L) {
        fprintf(stderr, "Error: Attempting to call get() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if(isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call get() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if(L-&gt;index &lt; 0) {
        fprintf(stderr, "Error: Attempting to call get() on list with undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;cursor-&gt;data;
}

bool equals(List A, List B) {
    if( !(A &amp;&amp; B) &amp;&amp; (A || B) ) return false;
    if( (isEmpty(A) || isEmpty(B)) &amp;&amp; !(isEmpty(A) &amp;&amp; isEmpty(B)) ) return false;
    moveFront(A);
    moveFront(B);
    while(A-&gt;cursor || B-&gt;cursor) {
        if( !(A-&gt;cursor) || !(B-&gt;cursor) ) return false;
        if(get(A) != get(B)) return false;
        moveNext(A);
        moveNext(B);
    }
    return true;
}

void clear(List L) {
    if(!L) return;
    while(length(L) &gt; 0) {
        deleteFront(L);
    }
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length = 0;
}

void set(List L, int x) {
    if(!L) {
        fprintf(stderr, "Error: Attempting to call set() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if(isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call set() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if(L-&gt;index &lt; 0) {
        fprintf(stderr, "Error: Attempting to call set() on list with undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursor-&gt;data = x;
}

void moveFront(List L) {
    if(isEmpty(L)) return;
    L-&gt;cursor = L-&gt;front;
    L-&gt;index = 0;
}

void moveBack(List L) {
    if(isEmpty(L)) return;
    L-&gt;cursor = L-&gt;back;
    L-&gt;index = L-&gt;length - 1;
}

void movePrev(List L) {
    if( !(L-&gt;cursor) ) return;
    if(L-&gt;cursor == L-&gt;front) {
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
        return;
    }
    L-&gt;cursor = L-&gt;cursor-&gt;prev;
    L-&gt;index--;
}

void moveNext(List L) {
    if( !(L-&gt;cursor) ) return;
    if(L-&gt;cursor == L-&gt;back) {
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
        return;
    }
    L-&gt;cursor = L-&gt;cursor-&gt;next;
    L-&gt;index++;
}

void prepend(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: Attempting to call prepend() using NULL list\n");
        return;
    }

    Node n = createNode(x);
    if (isEmpty(L)) {
        L-&gt;front = L-&gt;back = n;
    } else {
        L-&gt;front-&gt;prev = n;
        n-&gt;next = L-&gt;front;
        L-&gt;front = n;
    }
    L-&gt;length++;
    if(L-&gt;cursor) L-&gt;index++;
}

void append(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: Attempting to call append() using NULL list\n");
        return;
    }

    Node n = createNode(x);
    if (isEmpty(L)) {
        L-&gt;front = L-&gt;back = n;
    } else {
        L-&gt;back-&gt;next = n;
        n-&gt;prev = L-&gt;back;
</font>        L-&gt;back = n;
    }
    L-&gt;length++; 
}

<a name="5"></a><font color="#FF0000"><a href="match27-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

void insertBefore(List L, int x) {
    if (L == NULL) {
        fprintf(stderr, "Error: Attempting to call insertBefore() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if (isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call insertBefore() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;index &lt; 0) {
        fprintf(stderr, "Error: Attempting to call insertBefore() on list with undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    Node n = createNode(x);
</font>
    if (L-&gt;cursor == L-&gt;front) {  // case: inserting at the front
        n-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = n;
        L-&gt;front = n;
    } else {
        n-&gt;prev = L-&gt;cursor-&gt;prev;
        n-&gt;next = L-&gt;cursor;
<a name="1"></a><font color="#00FF00"><a href="match27-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

        L-&gt;cursor-&gt;prev-&gt;next = n;
        L-&gt;cursor-&gt;prev = n;
    }
    L-&gt;length++;
    L-&gt;index++;
}

void insertAfter(List L, int x) {
    if(!L) {
        fprintf(stderr, "Error: Attempting to call insertAfter() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if(isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call insertAfter() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if(L-&gt;index &lt; 0) {
        fprintf(stderr, "Error: Attempting to call insertAfter() on list with undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    Node n = createNode(x);
    if(L-&gt;index == L-&gt;length - 1) {
        n-&gt;prev = L-&gt;cursor;
        L-&gt;cursor-&gt;next = n;
        L-&gt;back = n; 
    } else {
        n-&gt;prev = L-&gt;cursor;
        n-&gt;next = L-&gt;cursor-&gt;next;
        n-&gt;prev-&gt;next = n;
        n-&gt;next-&gt;prev = n;
    }
    L-&gt;length++;
}

void freeNode(Node* pN){
   if( pN != NULL &amp;&amp; *pN != NULL ) {
      free(*pN);
      *pN = NULL;
   }
}

void deleteFront(List L) {
    if (!L) {
        fprintf(stderr, "Error: Attempting to call deleteFront() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if (isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call deleteFront() on empty list\n");
        exit(EXIT_FAILURE);
    }
    Node tmp = L-&gt;front;
    if (L-&gt;length == 1) {
        L-&gt;front = L-&gt;back = NULL;
        L-&gt;cursor = NULL;
</font>        L-&gt;index = -1;
    } else {
        L-&gt;front = L-&gt;front-&gt;next;
        L-&gt;front-&gt;prev = NULL;
<a name="3"></a><font color="#00FFFF"><a href="match27-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

        if (L-&gt;cursor == tmp) {
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
    }
    freeNode(&amp;tmp);
    L-&gt;length--;
    if(L-&gt;cursor) L-&gt;index--;
}

void deleteBack(List L) {
    if(!L) {
        fprintf(stderr, "Error: Attempting to call deleteBack() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if(isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call deleteBack() on empty list\n");
        exit(EXIT_FAILURE);
    }
    Node tmp = L-&gt;back;
    if(L-&gt;length == 1) {
        L-&gt;front = L-&gt;back = NULL;
        L-&gt;cursor = NULL;
</font>        L-&gt;index = -1;
    } else {
        L-&gt;back = L-&gt;back-&gt;prev;
        L-&gt;back-&gt;next = NULL;
<a name="4"></a><font color="#FF00FF"><a href="match27-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

        if (L-&gt;cursor == tmp) {
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        }
    }
    freeNode(&amp;tmp);
    L-&gt;length--;
}

void delete(List L) {
    if (!L) {
        fprintf(stderr, "Error: Attempting to call delete() using NULL pointer\n");
        exit(EXIT_FAILURE);
    }
    if (isEmpty(L)) {
        fprintf(stderr, "Error: Attempting to call delete() on empty list\n");
        exit(EXIT_FAILURE);
    }
    if (L-&gt;index &lt; 0) {
        fprintf(stderr, "Error: Attempting to call delete() on list with undefined cursor\n");
        exit(EXIT_FAILURE);
    }

    Node tmp = L-&gt;cursor;
    if (L-&gt;cursor == L-&gt;front) {
        deleteFront(L);  // This already frees the front node
    } else if (L-&gt;cursor == L-&gt;back) {
</font>        deleteBack(L);   // This already frees the back node
    } else {
<a name="2"></a><font color="#0000FF"><a href="match27-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

        L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
        L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
        L-&gt;length--;
        freeNode(&amp;tmp);  // Only free the node here if it's not front or back
    }
    
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
}

void printList(FILE* out, List L) {
    if (L == NULL) {
        fprintf(stderr, "List is NULL.\n");
        return;
    }
    if (isEmpty(L)) {
        fprintf(out, "List is empty.\n");
        return;
    }
    Node tmp = L-&gt;front;
    while (tmp != NULL) {
        fprintf(out, "%d ", tmp-&gt;data);
        tmp = tmp-&gt;next;
    }
    //fprintf(out, "\n");
}

List copyList(List L) {
    List J = newList();
    Node tmp = L-&gt;front;
    while(tmp) {
        append(J, tmp-&gt;data);
        tmp = tmp-&gt;next;
    }
    return J;
}

List concatList(List A, List B) {
    List J = copyList(A);
    Node tmp = B-&gt;front;
    while(tmp) {
        append(J, tmp-&gt;data);
        tmp = tmp-&gt;next;
</font>    }
    return J;
}
</pre>
</body>
</html>
