<html>
<head>
<title>/fall24/kpadhya/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/kpadhya/pa1/List.c<p></p><pre>
/***
* Kanei Padhya                                                                  * kpadhya
* 2024 Fall CSE101 PA{1} // Replace ID with assignment number
* List.c
* file for list implementation                                                  ***/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

// structs --------------------------------------------------------------------
typedef struct NodeObj* Node;
typedef struct NodeObj{
	ListElement data;
	Node next;	
	Node prev;	
} NodeObj;

typedef struct ListObj {
	Node cursor;
	Node front;
	Node back;
	int length;
	int index;
} ListObj;

// Constructors-Destructors ---------------------------------------------------
Node newNode(ListElement data){
	Node N = malloc(sizeof(NodeObj));
	assert(N!=NULL);
	N-&gt;data = data;
	N-&gt;next = NULL;
	return(N);
}

void freeNode(Node* pN){
	if(pN!=NULL &amp;&amp; *pN!=NULL){
		free(*pN);
		*pN = NULL;
	}
}

List newList(void){  // Creates and returns a new empty List.
	List L;
	L = malloc(sizeof(ListObj));
<a name="0"></a><font color="#FF0000"><a href="match93-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_48.gif"/></a>

	assert(L!=NULL);
	L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
	L-&gt;length = 0;
	L-&gt;index = 0;
	return(L);
}

void freeList(List* pL){ // Frees all heap memory associated with *pL, and sets
	 if(pL!=NULL &amp;&amp; *pL!=NULL){                               // *pL to NULL.
	 	while((*pL)-&gt;front != NULL){
	 		deleteFront(*pL);
	 	}
	 	free(*pL);
	 	*pL = NULL;
	}
}

// Access functions -----------------------------------------------------------
int length(List L){  // Returns the number of elements in L.
	if(L==NULL){
		exit(EXIT_FAILURE);
	}
	return(L-&gt;length);
}

int index(List L){ // Returns index of cursor element if defined, -1 otherwise.
	if(L==NULL){
		return(-1);
	}
	return(L-&gt;index);
}

int front(List L){ // Returns front element of L. Pre: length()&gt;0
	if(length(L)&gt;0){
		return(L-&gt;front-&gt;data);
	}
	else{
		exit(EXIT_FAILURE);
	}
}

int back(List L){ // Returns back element of L. Pre: length()&gt;0
	if(length(L)&gt;0){
		return(L-&gt;back-&gt;data);
	}
	else{
		exit(EXIT_FAILURE);
	}
}

int get(List L){ // Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
	if(length(L)&gt;0 &amp;&amp; index(L)&gt;=0){
		return(L-&gt;cursor-&gt;data);
	}
	else{
		exit(EXIT_FAILURE);
	}
}

bool equals(List A, List B){ // Returns true iff Lists A and B contain the same
	if(A==NULL || B==NULL){ // sequence of elements, returns false 
		exit(EXIT_FAILURE);		         // otherwise.
	}
	bool eq;
	Node N, M;
	eq = (A-&gt;length == B-&gt;length);
	N = A-&gt;front;
	M = B-&gt;front;
	while(eq &amp;&amp; N!=NULL){
		eq = (N-&gt;data==M-&gt;data);
		N = N-&gt;next;
		M = M-&gt;next;
	}
	return eq;
}

bool isEmpty(List L){
	if(L==NULL){
		exit(EXIT_FAILURE);
	}
	return(L-&gt;length==0);
}
 
 // Manipulation procedures ----------------------------------------------------
void clear(List L){ // Resets L to its original empty state.
	while(!isEmpty(L)){
		deleteFront(L);
	}
}

void set(List L, int x){ // Overwrites the cursor elementâ€™s data with x.
	if(length(L)&gt;0 &amp;&amp; index(L)&gt;=0){ // Pre: length()&gt;0, index()&gt;=0
		L-&gt;cursor-&gt;data = x;
	}
}
void moveFront(List L){  // If L is non-empty, sets cursor under the front element,
 // otherwise does nothing.
	if(length(L)&gt;0){
		L-&gt;cursor = L-&gt;front;
	}
}
void moveBack(List L){ // If L is non-empty, sets cursor under the back element,
 // otherwise does nothing.
	if(length(L)&gt;0){
		L-&gt;cursor = L-&gt;back;
	}
}
void movePrev(List L){ // If cursor is defined and not at front, move cursor one
 // step toward the front of L; if cursor is defined and at
 // front, cursor becomes undefined; if cursor is undefined
 // do nothing
	if(length(L)&gt;0 &amp;&amp; index(L)&gt;0){
		L-&gt;cursor = L-&gt;cursor-&gt;prev;
	}
}
	
void moveNext(List L){ // If cursor is defined and not at back, move cursor one
 // step toward the back of L; if cursor is defined and at
 // back, cursor becomes undefined; if cursor is undefined
 // do nothing
	if(index(L) &gt;= 0 &amp;&amp; index(L) &lt; length(L)){
		L-&gt;cursor = L-&gt;cursor-&gt;next;
	}
}
void prepend(List L, int x){ // Insert new element into L. If L is non-empty,
 // insertion takes place before front element.
	Node N = newNode(x);

	if(L==NULL){
		exit(EXIT_FAILURE);
	}
	
	if(isEmpty(L)){
		L-&gt;front = L-&gt;back = N;
	}
	else{
		L-&gt;front-&gt;prev = N;
		N-&gt;next = L-&gt;front;
		L-&gt;front = N;
	}

	L-&gt;length++;
}
void append(List L, int x){ // Insert new element into L. If L is non-empty,
 // insertion takes place after back element.
	Node N = newNode(x);

	if(L==NULL){
		exit(EXIT_FAILURE);
	}
	
	if(isEmpty(L)){
		L-&gt;front = L-&gt;back = N;
	}
	else{
		L-&gt;back-&gt;next = N;
		N-&gt;prev = L-&gt;back;
		L-&gt;back = N;
	}

	L-&gt;length++;
}

void insertBefore(List L, int x) { // Insert new element before cursor.
 // Pre: length()&gt;0, index()&gt;=0
	if(length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0){
		Node N = newNode(x);
		N-&gt;next = L-&gt;cursor;
		N-&gt;prev = L-&gt;cursor-&gt;prev;
		if(L-&gt;cursor-&gt;prev != NULL){
</font><a name="3"></a><font color="#00FFFF"><a href="match93-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

			L-&gt;cursor-&gt;prev-&gt;next = N;
		} else {
			L-&gt;front = N;
		}
		L-&gt;cursor-&gt;prev = N;
		L-&gt;length++;
	}
}
void insertAfter(List L, int x){ // Insert new element after cursor.
 // Pre: length()&gt;0, index()&gt;=0
	if(length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0){
		Node N = newNode(x);
		N-&gt;prev = L-&gt;cursor;
		N-&gt;next = L-&gt;cursor-&gt;next;
		if(L-&gt;cursor-&gt;next != NULL){
</font><a name="1"></a><font color="#00FF00"><a href="match93-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_20.gif"/></a>

			L-&gt;cursor-&gt;next-&gt;prev = N;
		} else {
			L-&gt;back = N;
		}
		L-&gt;cursor-&gt;next = N;
		L-&gt;length++;
	}
}
void deleteFront(List L){ // Delete the front element. Pre: length()&gt;0
	if (length(L) &gt; 0) {
        //Node temp = L-&gt;front;
        
        if (L-&gt;cursor == L-&gt;front) {
            L-&gt;cursor = NULL;
	    L-&gt;index = -1;
        }
	Node N = L-&gt;front;
        L-&gt;front = L-&gt;front-&gt;next;
        if (L-&gt;front != NULL) {
            L-&gt;front-&gt;prev = NULL;
        }

        //nodeDelete(&amp;temp);
        L-&gt;length--;
	free(N);

       if (L-&gt;cursor != NULL) {
            L-&gt;index--;
    	}
            
        } else {
        printf("List Error: no elements in list\n");
        exit(EXIT_FAILURE);
    }
}

void deleteBack(List L){ // Delete the back element. Pre: length()&gt;0
	if (length(L) &gt; 0) {
        //Node temp = L-&gt;front;
        
        if (L-&gt;cursor == L-&gt;back) {
            L-&gt;cursor = NULL;
	    L-&gt;index = -1;
        }
	Node N = L-&gt;back;
        L-&gt;back = L-&gt;back-&gt;prev;
        if (L-&gt;back != NULL) {
            L-&gt;back-&gt;next = NULL;
        }

        //nodeDelete(&amp;temp);
        L-&gt;length--;
	free(N);
	
       	if (L-&gt;cursor != NULL) {
            L-&gt;index--;
    	}
            
    } else {
        printf("List Error: no elements in list\n");
        exit(EXIT_FAILURE);
    }
}

void delete(List L){ // Delete cursor element, making cursor undefined.
 // Pre: length()&gt;0, index()&gt;=0
	if((length(L) &gt; 0) &amp;&amp; (index(L) &gt;= 0)){
		if (L-&gt;cursor == L-&gt;front) {
        		deleteFront(L);
    		} else if (L-&gt;cursor == L-&gt;back) {
        		deleteBack(L);
    		} else {
</font>			 Node N = L-&gt;cursor;
       			 L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
<a name="2"></a><font color="#0000FF"><a href="match93-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

        		L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
        		L-&gt;cursor = NULL;
        		L-&gt;index = -1;
        		L-&gt;length--;
        		free(N);
		}
	}	
	
}
// Other operations -----------------------------------------------------------
void printList(FILE* out, List L){ // Prints to the file pointed to by out, a
 // string representation of L consisting
// of a space separted sequence of integers,
// with front on left.
	Node curr;
	for (int i = 0; i &lt; length(L); i++) {
		if (i == 0) {
			curr = L-&gt;front;
		} else {
			curr = curr-&gt;next;
		}
		fprintf(out, "%d ", curr-&gt;data);
	}
	fprintf(out, "\n");
}
List copyList(List L){
	List K = newList();
	Node curr = L-&gt;front;
	for(int p = 0; p &lt; length(L); p++){
</font>		append(K, curr-&gt;data);
		curr = curr-&gt;next;
	}
	return K;
}
</pre>
</body>
</html>
