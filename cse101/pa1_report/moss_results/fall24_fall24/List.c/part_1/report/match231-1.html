<html>
<head>
<title>/fall24/aarient/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/sapottab/pa1/List.c<p></p><pre>
//-----------------------------------------------------------------------------
// Saish Pottabathula
// 2068265
// PA1
// List.c
//-----------------------------------------------------------------------------
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
#include "List.h"


// structs --------------------------------------------------------------------

// private Node type
// Node is a pointer type referring to a NodeObj structure.
typedef struct NodeObj* Node; 

// private NodeObj type
typedef struct NodeObj{
   int data;
   struct NodeObj* next;
   struct NodeObj* prev;
} NodeObj;

// private QueueObj type
typedef struct ListObj{
   Node front;
   Node back;
   Node cursor;
   int length;
   int index;
} ListObj;


// Constructors-Destructors ---------------------------------------------------

// newNode()
// Returns reference to new Node object. Initializes next and data fields.
Node newNode(int data){
   Node N = malloc(sizeof(NodeObj));
   assert( N!=NULL );
   N-&gt;data = data;
   N-&gt;next = NULL;
   N-&gt;prev = NULL;
   return(N);
}

// freeNode()
// Frees heap memory pointed to by *pN, sets *pN to NULL.
void freeNode(Node* pN){
   if( pN!=NULL &amp;&amp; *pN!=NULL ){
      free(*pN);
      *pN = NULL;
   }
}

// newList()
// Returns reference to new empty List object.
List newList(){
   List L = malloc(sizeof(ListObj));
   assert( L!=NULL );
   L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
   L-&gt;length = 0;
   L-&gt;index = -1;
   return(L);
}


// freeList() WIP
// Frees all heap memory associated with List *pL, and sets *pL to NULL.
void freeList(List* pL){
<a name="5"></a><font color="#FF0000"><a href="match231-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

   if(pL!=NULL &amp;&amp; *pL!=NULL) { 
      while( !isEmpty(*pL) ) { 
         deleteFront(*pL);
      }
      free(*pL);
      *pL = NULL;
   }
}


// Access functions -----------------------------------------------------------
int length(List L) {
   //list not initialized
   if (L == NULL) {
      printf("List Error: calling length() on NULL List reference\n");
      exit(EXIT_FAILURE);
</font>   }

   return L-&gt;length;
}
int index(List L) {
   //list not initialized
<a name="4"></a><font color="#FF00FF"><a href="match231-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

   if (L == NULL) {
      printf("List Error: calling index() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return L-&gt;index;
}
int front(List L){
   //list not initialized
   if (L == NULL) {
      printf("List Error: calling front() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   //empty list
   if(isEmpty(L)) {
      printf("list does not contain a front");
      exit(EXIT_FAILURE);
   }

   return L-&gt;front-&gt;data;
</font>}
int back(List L){
   //list not initialized
   if (L == NULL) {
      printf("List Error: calling back() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   //empty list
   if(isEmpty(L)) {
      printf("list does not contain a front");
      exit(EXIT_FAILURE);
   }

<a name="0"></a><font color="#FF0000"><a href="match231-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_2.gif"/></a>

   return L-&gt;back-&gt;data;
}

int get(List L){
   //list not initialized
   if (L == NULL) {
      printf("List Error: calling length() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   //empty list
   if (isEmpty(L)) {
      printf("list is empty");
      exit(EXIT_FAILURE);
   }

   //index not valid
   if (L-&gt;index &lt; 0) {
      printf("invalid cursor position");
      exit(EXIT_FAILURE);
   }

   return L-&gt;cursor-&gt;data;
}

//bool equals(List A, List B)

// isEmpty()
// Returns true if L is empty, otherwise returns false.
bool isEmpty(List L){
</font><a name="1"></a><font color="#00FF00"><a href="match231-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

   if( L==NULL ){
      printf("List Error: calling isEmpty() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   return(L-&gt;length == 0);
}


// Manipulation procedures ----------------------------------------------------

void clear(List L) {
   if (L == NULL) {
      printf("List Error: calling clear() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }


   while (!isEmpty(L)) {
      deleteFront(L); //delete front already clears memory
</font>   }


   L-&gt;front = NULL;
   L-&gt;back = NULL;
   L-&gt;cursor = NULL;
   L-&gt;length = 0;
   L-&gt;index = -1;
}

void set(List L, int x) {
   if( L==NULL ){
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   if( (length(L) &gt; 0) &amp;&amp; (index(L) &gt;= 0) ) {
      L-&gt;cursor-&gt;data = x;
   } else {
      printf("list is not of valid size or index position of cursor is bad");
      exit(EXIT_FAILURE);
   }

}

void moveFront(List L) {
   if( L==NULL ){
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (!isEmpty(L)) {
      L-&gt;index = 0;
      L-&gt;cursor = L-&gt;front;
   } else {
      printf("list is empty");
      exit(EXIT_FAILURE);
   }
}

void moveBack(List L) {
   if( L==NULL ){
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   if (!isEmpty(L)) {
      L-&gt;index = L-&gt;length - 1;
      L-&gt;cursor = L-&gt;back;
   } else {
      printf("list is empty");
      exit(EXIT_FAILURE);
   }
}

void movePrev(List L) {
   if( L==NULL ){
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   //cursor defined and not at front move cursor back
   if (L-&gt;cursor != NULL &amp;&amp; L-&gt;index &gt; 0) {
      L-&gt;index -= 1;
      L-&gt;cursor = L-&gt;cursor-&gt;prev;
   } else if (L-&gt;cursor != NULL &amp;&amp; L-&gt;index == 0) {
      L-&gt;index = -1;
      L-&gt;cursor = NULL;
   } 
}

void moveNext(List L) {
   if( L==NULL ){
      printf("List Error: calling set() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   //cursor defined and not at front move cursor back
   if (L-&gt;cursor != NULL &amp;&amp; L-&gt;index &lt; (L-&gt;length - 1)) {
      L-&gt;index += 1;
      L-&gt;cursor = L-&gt;cursor-&gt;next;
   } else if (L-&gt;cursor != NULL &amp;&amp; L-&gt;index == (L-&gt;length - 1)) {
      L-&gt;index = -1;
      L-&gt;cursor = NULL;
   } 

}
// Places new data at the back of L.
void append(List L, int data)
{
   Node N = newNode(data);

   if( L==NULL ){
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if(isEmpty(L) ) { 
      L-&gt;front = L-&gt;back = N; 
   }else{ 
      //og back node gets set to new Node, new back node needs prev to be set
      N-&gt;prev = L-&gt;back; //sets new back to node's prev to List's current back node
      L-&gt;back-&gt;next = N; //sets lists og back node to point to new node
<a name="6"></a><font color="#00FF00"><a href="match231-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

      L-&gt;back = N; //sets new node to back of the list
   }
   L-&gt;length++;
}

void prepend(List L, int data)
{
   Node N = newNode(data);

   if( L==NULL ){
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if(isEmpty(L) ) { 
</font>      L-&gt;front = L-&gt;back = N; 
   }else{ 
      //new node next points to og node
      //og nodes back points to new node
      //set List front to new node
      N-&gt;next = L-&gt;front; //sets new back to node's prev to List's current back node
<a name="2"></a><font color="#0000FF"><a href="match231-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

      L-&gt;front-&gt;prev = N; //sets lists og back node to point to new node
      L-&gt;front = N; //sets new node to back of the list
   }
   if (L-&gt;index &gt;= 0) {
      L-&gt;index++;
   }
   L-&gt;length++;
}

void insertBefore(List L, int x) {
   Node N = newNode(x);

   if( L==NULL ){
</font>      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index == 0) {
      Node cursorNode = L-&gt;cursor;
      cursorNode-&gt;prev = N;
      N-&gt;next = cursorNode;
      L-&gt;front = N;
      L-&gt;length++;
   } else if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) {
      Node previous = L-&gt;cursor-&gt;prev;
      Node cursorNode = L-&gt;cursor;
      previous-&gt;next = N; //prev node next to new node
      N-&gt;prev = previous; //new node prev set to back node
      N-&gt;next = cursorNode; //sets new node's next to curr node
      cursorNode-&gt;prev = N; //sets curr node's previous to new node
      L-&gt;length++;
   }
   if (L-&gt;index &gt;= 0) {
      L-&gt;index++;
   }
}

void insertAfter(List L, int x) {
   Node N = newNode(x);

   if( L==NULL ){
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   //last index
   if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index == L-&gt;length - 1) {
      Node cursorNode = L-&gt;cursor;
      cursorNode-&gt;next = N;
      N-&gt;prev = cursorNode;
      L-&gt;back = N;
      L-&gt;length++;
   } else if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) {
      Node nxt = L-&gt;cursor-&gt;next;
      Node cursorNode = L-&gt;cursor;
      cursorNode-&gt;next = N; //prev node next to new node
      N-&gt;prev = cursorNode; //new node prev set to back node
      N-&gt;next = nxt; //sets new node's next to curr node
      nxt-&gt;prev = N; //sets curr node's previous to new node
      L-&gt;length++;
   }
}

void deleteFront(List L) {
   if (L == NULL) {
      printf("List Error: calling deleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0) {
      printf("List Error: calling deleteFront() on an empty List\n");
      exit(EXIT_FAILURE);
   }

   Node temp = L-&gt;front;

   // If there is only one element in the list
   if (L-&gt;length == 1) {
      L-&gt;front = L-&gt;back = NULL;
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   } else {
      L-&gt;front = L-&gt;front-&gt;next;
      L-&gt;front-&gt;prev = NULL;
      if (L-&gt;cursor == temp) { // If the cursor was at the front
         L-&gt;cursor = NULL;
         L-&gt;index = -1;
      }
   }
   if (L-&gt;index &gt;= 0) {
      L-&gt;index--;
   }
   freeNode(&amp;temp);
   L-&gt;length--;
}

void deleteBack(List L) {
   if (L == NULL) {
      printf("List Error: calling deleteFront() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   if (L-&gt;length == 0) {
      printf("List Error: calling deleteFront() on an empty List\n");
      exit(EXIT_FAILURE);
   }

   Node temp = L-&gt;back;

   // If there is only one element in the list
   if (L-&gt;length == 1) {
      L-&gt;front = L-&gt;back = NULL;
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   } else {
      L-&gt;back = L-&gt;back-&gt;prev;
      L-&gt;back-&gt;next = NULL;
      if (L-&gt;cursor == temp) { // If the cursor was at the front
         L-&gt;cursor = NULL;
         L-&gt;index = -1;
      }
   }

   freeNode(&amp;temp);
   L-&gt;length--;
}
void delete(List L) {
   if( L==NULL ){
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }
   
   if (L-&gt;length == 1) { //length = 1
      freeNode(&amp;(L-&gt;cursor));
      L-&gt;front = L-&gt;back = L-&gt;cursor = NULL;
      L-&gt;index = -1;
      L-&gt;length -= 1;
   } else if(L-&gt;length &gt; 0 &amp;&amp; L-&gt;index == 0) { //first in list
      Node newFront = L-&gt;cursor-&gt;next;
      newFront-&gt;prev = NULL;
      freeNode(&amp;(L-&gt;cursor));
      L-&gt;front = newFront;
      L-&gt;length--;
      L-&gt;cursor = NULL;
      L-&gt;index = -1;
   } else if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index == L-&gt;length - 1) { //last in list
      Node newBack = L-&gt;cursor-&gt;prev;
      newBack-&gt;next = NULL;
      freeNode(&amp;(L-&gt;cursor));
      L-&gt;back = newBack;
      L-&gt;length--;
      L-&gt;index = -1;
      L-&gt;cursor = NULL;
   } else if (L-&gt;length &gt; 0 &amp;&amp; L-&gt;index &gt;= 0) {//midle of list
      Node newPrev = L-&gt;cursor-&gt;prev;
      Node newNext = L-&gt;cursor-&gt;next;
      freeNode(&amp;(L-&gt;cursor));
      newPrev-&gt;next = newNext;
      newNext-&gt;prev = newPrev;
      L-&gt;length--;
      L-&gt;index = -1;
      L-&gt;cursor = NULL;
   }
}
// Other operations ----------------------------------------------------------- 
void pList(List L) {
   if( L==NULL ){
      printf("List Error: calling append() on NULL List reference\n");
      exit(EXIT_FAILURE);
   }

   if (isEmpty(L)) {
      printf("list is empty");
   } else {
      Node N = L-&gt;front;
      while (N-&gt;next != NULL) {
         printf("%d ", N-&gt;data);
         N = N-&gt;next;
      }
      printf("%d \n", N-&gt;data);
   }
}



// Other Functions ------------------------------------------------------------

List copyList(List L) {
   if (L == NULL) {
      printf("NULL List\n");
      exit(EXIT_FAILURE);
   }

   List newL = newList();

   if (isEmpty(L)) {
      return newL;
   } else {
      Node N = L-&gt;front;
      while (N-&gt;next != NULL) {
         append(newL, N-&gt;data);
<a name="3"></a><font color="#00FFFF"><a href="match231-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

         N = N-&gt;next;
      }
      append(newL, N-&gt;data);
   }

   return newL;

}
// equals()
// Returns true if A is same int sequence as B, false otherwise.
bool equals(List A, List B){
   if( A==NULL || B==NULL ){
      printf("Queue Error: calling equals() on NULL Queue reference\n");
      exit(EXIT_FAILURE);
   }

   bool eq;
</font>   Node N, M;

   eq = ( A-&gt;length == B-&gt;length );
   N = A-&gt;front;
   M = B-&gt;front;
   while( eq &amp;&amp; N!=NULL){
      eq = ( N-&gt;data==M-&gt;data );
      N = N-&gt;next;
      M = M-&gt;next;
   }
   return eq;
}

void printList(FILE* out, List L) {
    if (L == NULL) {
        printf("List Error: calling printList() on NULL List reference\n");
        exit(EXIT_FAILURE);
    }
    if (out == NULL) {
        printf("File Error: calling printList() with NULL file reference\n");
        exit(EXIT_FAILURE);
    }

    // Start from the front of the list
    Node current = L-&gt;front;

    // Traverse through the list and print each element's data
    while (current != NULL) {
        fprintf(out, "%d", current-&gt;data);  // Print the data of the node to the file
        current = current-&gt;next;  // Move to the next node
        if (current != NULL) {
            fprintf(out, " ");  // Add a space between numbers (no trailing space at the end)
        }
    }
    //fprintf(out, "\n");  // Add a newline at the end of the output
}
</pre>
</body>
</html>
