<html>
<head>
<title>/fall24/cceerla/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/cceerla/pa1/List.c<p></p><pre>
/* pa1
 * Clara Ceerla
 * cceerla
 * 1890948
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;
#include "List.h"

// NOTE TO GRADERS, IF YOU'RE READING THIS
// i apologize for the crazy and disorganized comments.
// i want my assignments to be a self-contained reference
// for my future self, so the comments are kind of over-
// the-top and also describing thought process.
// these aren't professional comments and if need
// be i will happily put my notes elsewhere if asked.
// it's just more convenient for me haha

// we have clarity at this altitude

// TODO LECTURE NOTE:
// ERROR HANDLING ALWAYS COMES FIRST!!
// never do if(good) -&gt; do thing, else -&gt; error
// do if (error) -&gt; error and return, then normal code execution

// &amp;: address_of
// *: value_at
// oh that makes so much sense

<a name="3"></a><font color="#00FFFF"><a href="match8-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

typedef struct NodeObj* Node;

typedef struct NodeObj {
    int data;
    // as it turns out, using "struct NodeObj*" here would work
    // NodeObj itself won't because the renaming of struct NO to 
    // just NO hasn't happened yet! whoa mama c compiler
    Node prev;
    Node next;
} NodeObj;

typedef struct ListObj* List;

typedef struct ListObj {
      Node front;
      Node back;
      Node cursor;
      int length;
      int index;
} ListObj;

// Constructors-Destructors --------

Node newNode(int data){
    Node N = malloc(sizeof(NodeObj));
</font>    assert(N != NULL);
    N-&gt;data = data;
    N-&gt;next = NULL;
    N-&gt;prev = NULL;
    return N;
}

void freeNode(Node* victim){
    if (victim != NULL &amp;&amp; *victim != NULL){
<a name="5"></a><font color="#FF0000"><a href="match8-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

	free(*victim);
	*victim = NULL;
    }
}

// Creates and returns a new empty List.
List newList(){
      // needs to:
      // create new list pointer
      // malloc heap memory for the pointer
      List L = malloc(sizeof(ListObj));
      assert(L != NULL);
      // return pointer
      L-&gt;front = NULL;
      L-&gt;back = NULL;
</font>      L-&gt;cursor = NULL;
      L-&gt;length = 0;
      L-&gt;index = -1;
      return L;
}	 

// Frees all heap memory associated with *pL, and sets
// *pL to NULL.
void freeList(List* victim){
    if (victim != NULL &amp;&amp; *victim != NULL){
	clear(*victim);
	free(*victim);
	*victim = NULL;
    }
}
				    
// Access functions ----------------

// Returns the number of elements in L.
int length(List list){
    if (list == NULL) {
	printf("List Error: Calling length() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    return list-&gt;length;
}	    
      
// Returns index of cursor element if defined, -1 otherwise.
int index(List list){
<a name="4"></a><font color="#FF00FF"><a href="match8-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

    if (list == NULL) {
	printf("List Error: Calling index() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    return list-&gt;index;
}
      
// Returns front element of L. Pre: length()&gt;0
int front(List list){
    // lecture: if precond violated, print error message and crash.
    // error message must include:
    // - which adt
    // - what function has the error
    // - which precondition was violated
    // format: [ADT] Error: calling [FN] [PRE] \n
    if (list == NULL) {
	printf("List Error: Calling front() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length &lt; 1){
	printf("List Error: Calling front() on empty list.\n");
	exit(EXIT_FAILURE);
</font>    }
     return list-&gt;front-&gt;data;
}
      
// Returns back element of L. Pre: length()&gt;0
int back(List list){
    if (list == NULL) {
	printf("List Error: Calling back() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length &lt; 1){
	printf("List Error: Calling back() on empty list.\n");
	exit(EXIT_FAILURE);
    }
    
<a name="0"></a><font color="#FF0000"><a href="match8-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_40.gif"/></a>

    return list-&gt;back-&gt;data;
}  
      
// Returns cursor element of L. Pre: length()&gt;0, index()&gt;=0
int get(List list){
    if (list == NULL) {
	printf("List Error: Calling get() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length &lt;= 0) {
	printf("List Error: Calling get() on empty list.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;index &lt; 0) {
	printf("List Error: Calling get() with invalid cursor.\n");
	exit(EXIT_FAILURE);
    }

    return list-&gt;cursor-&gt;data;
}	    
      
// Returns true iff Lists A and B contain the same
// sequence of elements, returns false otherwise.
bool equals(List listA, List listB){
    if (listA == NULL || listB == NULL) {
	printf("List Error: Calling equals() on one or more null List references.\n");
	exit(EXIT_FAILURE);
    }
    int indexA = listA-&gt;index;
    int indexB = listB-&gt;index;
    Node cursorA = listA-&gt;cursor;
    Node cursorB = listB-&gt;cursor;
    if (listA-&gt;length == listB-&gt;length) {
	moveFront(listA);
	moveFront(listB);
	bool match = true;
	while (listA-&gt;index &gt;= 0){
	    // if a's data != b's data, return false
	if (listA-&gt;length &gt; 0){
	   // printf("%d : %d (%d)\n", get(listA), get(listB), listA-&gt;index);
	}
	    if (get(listA) != get(listB)) {
		match = false;
		printf("match found to be false\n");
		break;
	    }
	    moveNext(listA);
	    moveNext(listB);
	}
	// got thru the whole loop without a mismatch, so they must match!
	listA-&gt;index = indexA;
	listB-&gt;index = indexB;
	listA-&gt;cursor = cursorA;
	listB-&gt;cursor = cursorB;
	return match;
    } else {
       	return false; }
    listA-&gt;index = indexA;
    listB-&gt;index = indexB;
    listA-&gt;cursor = cursorA;
    listB-&gt;cursor = cursorB;
    return false;
}
				    
// Manipulation procedures ---------
      
// Resets L to its original empty state.
void clear(List list){
    if (list == NULL) {
	printf("List Error: Calling clear() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length == 0){
	return;
    }
   // variables
    int i;
    Node victim;
    Node next;
    victim = list-&gt;front;
    while (victim != NULL){
	next = victim-&gt;next;
	freeNode(&amp;victim);
	victim = next;	
    }
    list-&gt;front = NULL;
    list-&gt;back = NULL;
    list-&gt;cursor = NULL;
    list-&gt;index = -1;
    list-&gt;length = 0;
} 
      
// Overwrites the cursor elementâ€™s data with x.
// Pre: length()&gt;0, index()&gt;=0
void set(List list, int x){
    if (list == NULL) {
	printf("List Error: Calling set() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;cursor == NULL || list-&gt;index &lt; 0) {
	printf("List Error: Calling set() on invalid cursor.\n");
	exit(EXIT_FAILURE);
    }
	list-&gt;cursor-&gt;data = x;
} 
				    
      
// If L is non-empty, sets cursor under the front element,
// otherwise does nothing.
void moveFront(List list){
    if (list == NULL) {
	printf("List Error: Calling front() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    list-&gt;cursor = list-&gt;front;
    if (list-&gt;length &gt; 0){
	list-&gt;index = 0;
    } else {
	list-&gt;index = -1;
    }
    //printf("set index as %d\n", list-&gt;index);
}
      
// If L is non-empty, sets cursor under the back element,
// otherwise does nothing.
void moveBack(List list){
    if (list == NULL) {
	printf("List Error: Calling front() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
      // same but now back
    list-&gt;cursor = list-&gt;back;
    if (list-&gt;length &gt; 0){
	list-&gt;index = list-&gt;length - 1;
    } else {
	list-&gt;index = -1;
    }
} 

// If cursor is defined and not at front, move cursor one
// step toward the front of L; if cursor is defined and at
// front, cursor becomes undefined; if cursor is undefined
// do nothing
void movePrev(List list){
    if (list == NULL) {
	printf("List Error: Calling movePrev() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;index &gt;= 0){
	list-&gt;cursor = list-&gt;cursor-&gt;prev;
	list-&gt;index -= 1;
	if (list-&gt;cursor == NULL){
	    list-&gt;index = -1;
	}
    }
}   
      
// If cursor is defined and not at back, move cursor one
// step toward the back of L; if cursor is defined and at
// back, cursor becomes undefined; if cursor is undefined
// do nothing
void moveNext(List list){
    if (list == NULL) {
	printf("List Error: Calling moveNext() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;index &gt;= 0){
	list-&gt;cursor = list-&gt;cursor-&gt;next;
	list-&gt;index += 1;
	if (list-&gt;cursor == NULL) {
	    list-&gt;index = -1;
	}
    }
}
      
// Insert new element into L. If L is non-empty,
// insertion takes place before front element.
void prepend(List list, int x){
    if (list == NULL) {
	fprintf(stderr, "List Error: Calling prepend() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    Node newFront = newNode(x);
    
    // if list is not empty, adjust the old back
    if (list-&gt;front != NULL){
	list-&gt;front-&gt;prev = newFront;
	newFront-&gt;next = list-&gt;front;
	list-&gt;front = newFront;
    } else {
	// if list is empty, set front and front to new node
	list-&gt;back = newFront;
	list-&gt;front = newFront;
    }
    // change list-&gt;front
    list-&gt;front = newFront;
    list-&gt;length++;
    if (list-&gt;index != -1){
	list-&gt;index++;
    }
}
      
// Insert new element into L. If L is non-empty,
// insertion takes place after back element.
void append(List list, int x){
    if (list == NULL) {
	fprintf(stderr, "List Error: Calling append() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    Node newBack = newNode(x);
    
    // if list is not empty, adjust the old back
    if (list-&gt;back != NULL){
	list-&gt;back-&gt;next = newBack;
	newBack-&gt;prev = list-&gt;back;
	list-&gt;back = newBack;
    } else {
	// if list is empty, set front and back to new node
	list-&gt;back = newBack;
	list-&gt;front = newBack;
    }
    // change list-&gt;back
    list-&gt;back = newBack;
    list-&gt;length++;
}
      
// Insert new element before cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertBefore(List list, int x){
</font>    if (list == NULL) {
	fprintf(stderr, "List Error: Calling insertBefore() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
<a name="2"></a><font color="#0000FF"><a href="match8-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    if (list-&gt;length &lt; 1) {
	fprintf(stderr, "List Error: Calling insertBefore() on empty List.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;index &lt; 0) {
	fprintf(stderr, "List Error: Calling insertBefore() with invalid cursor.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;cursor == list-&gt;front || list-&gt;length &lt; 1){
	prepend(list, x);
    } else {
	Node inserted = newNode(x);
	// change before and after to include it
	inserted-&gt;prev = list-&gt;cursor-&gt;prev;
	inserted-&gt;next = list-&gt;cursor;
	list-&gt;cursor-&gt;prev-&gt;next = inserted;
	list-&gt;cursor-&gt;prev = inserted;
	// increase length by 1
	list-&gt;length++;
	// move index one to the right (insertBefore ONLY)
        if (list-&gt;index != -1){
	    list-&gt;index++;
	}
    }
}
      
// Insert new element after cursor.
// Pre: length()&gt;0, index()&gt;=0
void insertAfter(List list, int x){
</font>    if (list == NULL) {
	fprintf(stderr, "List Error: Calling insertAfter() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
<a name="1"></a><font color="#00FF00"><a href="match8-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_35.gif"/></a>

    if (list-&gt;length &lt; 1) {
	fprintf(stderr, "List Error: Calling insertAfter() on empty List.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;index &lt; 0) {
	fprintf(stderr, "List Error: Calling insertAfter() with invalid cursor.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;cursor == list-&gt;back || list-&gt;length &lt; 1){
	append(list, x);
    } else {
	Node inserted = newNode(x);
	// change before and after to include it
	inserted-&gt;prev = list-&gt;cursor-&gt;next-&gt;prev;
	inserted-&gt;next = list-&gt;cursor-&gt;next;
	list-&gt;cursor-&gt;next-&gt;prev = inserted;
	list-&gt;cursor-&gt;next = inserted;
	// increase length by 1
	list-&gt;length++;
    }
}
      
// Delete the front element. Pre: length()&gt;0
void deleteFront(List list){
    if (list == NULL) {
	printf("List Error: Calling deleteFront() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length &lt; 1) {
	printf("List Error: Calling deleteFront() on empty List.\n");
	exit(EXIT_FAILURE);
    }
    int index = list-&gt;index;
    Node cursor = list-&gt;cursor;
    moveFront(list);
    delete(list);
    list-&gt;index = index - 1;
    list-&gt;cursor = cursor;
}	    
      
// Delete the back element. Pre: length()&gt;0
void deleteBack(List list){
    if (list == NULL) {
	printf("List Error: Calling deleteBack() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length &lt; 1) {
	printf("List Error: Calling deleteBack() on empty List.\n");
	exit(EXIT_FAILURE);
    }
    
    int index = list-&gt;index;
    int wasBack = false;
    if (list-&gt;cursor == list-&gt;back){
	wasBack = true;
    }
    Node cursor = list-&gt;cursor;
    moveBack(list);
    delete(list);
    if (wasBack) {
	list-&gt;index = -1;
    } else {
	list-&gt;index = index;
    }
    list-&gt;cursor = cursor;
}	    
      
// Delete cursor element, making cursor undefined.
// Pre: length()&gt;0, index()&gt;=0
void delete(List list){
    if (list == NULL) {
	fprintf(stderr, "List Error: Calling delete() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (list-&gt;length &lt; 1) {
	fprintf(stderr, "List Error: Calling delete() on empty List.\n");
	exit(EXIT_FAILURE);
    }
    if (index &lt; 0) {
	fprintf(stderr, "List Error: Calling delete() with invalid pointer.\n");
	exit(EXIT_FAILURE);
    }
    Node prevNode = list-&gt;cursor-&gt;prev;
    Node nextNode = list-&gt;cursor-&gt;next;
    if (prevNode != NULL) {
	prevNode-&gt;next = nextNode;
    }
    if (nextNode != NULL){
	nextNode-&gt;prev = prevNode;
    }
    if (list-&gt;cursor == list-&gt;front){
	list-&gt;front = list-&gt;front-&gt;next; // its ok if i make these values null!
    }
    if (list-&gt;cursor == list-&gt;back){
	list-&gt;back = list-&gt;back-&gt;prev;
    }
    freeNode(&amp;list-&gt;cursor);
    // set cursor to -1
    list-&gt;index = -1;
    list-&gt;length -= 1;
}

// Other operations ----------------

      
// Prints to the file pointed to by out, a
// string representation of L consisting
// of a space separated sequence of integers,
// with front on left.
void printList(FILE* out, List list){
    int index = list-&gt;index;
    Node cursorPointer = list-&gt;cursor;
    if (list == NULL) {
	printf("List Error: Calling printList() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    if (out == NULL) {
	printf("List Error: Calling printList() with an invalid target file pointer.\n");
	exit(EXIT_FAILURE);
    }
    
    // start at left of list
    moveFront(list);
    printf("&lt; ");
    while (list-&gt;index != -1) {
	printf("%d (%d), ", list-&gt;cursor, get(list));
	fprintf(out, "%d ", get(list));
	moveNext(list);
    }
    printf("&gt; [cursor at %d, index %d, length %d]\n", cursorPointer, index, list-&gt;length);
    
    // EXTRA DEBUG INFORMATION
     /*
    moveFront(list);
    while (list-&gt;index != -1) {
	printf("%d, ", list-&gt;cursor-&gt;prev);
	moveNext(list);
    }
    printf("\n");
    moveFront(list);
    while (list-&gt;index != -1) {
	printf("%d, ", list-&gt;cursor-&gt;next);
	moveNext(list);
    }
    printf("\n");

    printf("f: %d b: %d c: %d ", list-&gt;front, list-&gt;back, list-&gt;cursor);
   */ 
    list-&gt;index = index;
    list-&gt;cursor = cursorPointer;
    //printf("back: %d\n", list-&gt;back-&gt;data);
} 
      
// Returns a new List representing the same integer
// sequence as L. The cursor in the new list is undefined,
// regardless of the state of the cursor in L. The state
// of L is unchanged.
List copyList(List list){
    if (list == NULL) {
	printf("List Error: Calling front() on null List reference.\n");
	exit(EXIT_FAILURE);
    }
    // create new list
    List clone = newList();
    // save the cursor
    int index = list-&gt;index;
    Node cursor = list-&gt;cursor;
    // move cursor to the beginning, then use append() until there is nothing left
    moveFront(list);
    while (list-&gt;index &gt;= 0){
	append(clone, get(list));
	moveNext(list);
    }
    list-&gt;cursor = cursor;
    list-&gt;index = index;
    return clone;
}
      
// concatenates two lists, returning a new list
// with the combined content. List A comes before List B.
// cursor MUST be undefined in new list.
List concatList(List listA, List listB){
    if (listA == NULL || listB == NULL) {
	printf("List Error: Calling concatList() on one or more null List references.\n");
	exit(EXIT_FAILURE);
    }
    List concatenated = copyList(listA);
    // then begin appending B's elements to A with a similar loop to copyList
    // save the cursor
    int index = listB-&gt;index;
    Node cursor = listB-&gt;cursor;
    // move cursor to the beginning, then use append() until there is nothing left
    moveFront(listB);
    while (listB-&gt;index &gt;= 0){
	append(concatenated, get(listB));
	moveNext(listB);
    }
    listB-&gt;cursor = cursor;
    listB-&gt;index = index;
</font>    return concatenated;
} 
</pre>
</body>
</html>
