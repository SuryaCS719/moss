<html>
<head>
<title>/fall24/jgebrese/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/jgebrese/pa1/List.c<p></p><pre>
//JOHN GEBRESELASSIE, jgebrese, pa2
#include "List.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;


<a name="5"></a><font color="#FF0000"><a href="match6-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

typedef struct NodeObj {
	int data;
	struct NodeObj* prev;
	struct NodeObj* next;
} NodeObj;

typedef struct NodeObj* Node;
typedef struct ListObj {
	Node head;
	Node tail;
	Node current;
	int size;
	int cursorIndex;
} ListObj;

List newList(void) {
	List L = (List)malloc(sizeof(ListObj));
	if (L == NULL) {
		fprintf(stderr, "memory allocation failed\n");
		exit(EXIT_FAILURE);
	}
	L-&gt;head = NULL;
	L-&gt;tail = NULL;
</font>	L-&gt;current = NULL;
	L-&gt;size = 0;
<a name="3"></a><font color="#00FFFF"><a href="match6-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

	L-&gt;cursorIndex = -1;
	return L;
}

void freeList(List* pL) {
	if (pL != NULL &amp;&amp; *pL != NULL) {
		Node temp;
		while ((*pL)-&gt;head != NULL) {
			temp = (*pL)-&gt;head;
			(*pL)-&gt;head = (*pL)-&gt;head-&gt;next;
			free(temp);
		}
		free(*pL);
		*pL = NULL;
	}
}


int length(List L){
	if (L == NULL) {
		printf("List error: calling length() on Null list\n");
		exit(EXIT_FAILURE);
	}
	return L-&gt;size;
}


int index(List L){
	if (L == NULL) {
		printf("List error: calling index() on Null list\n");
		exit(EXIT_FAILURE);
	}
	return L-&gt;cursorIndex;
}


int front(List L){
	if (L == NULL) {
		printf("List error: calling front() on Null list\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt;1) {
		printf("List error: calling front() on empty list\n");
		exit(EXIT_FAILURE);
</font>	}
	return (L-&gt;head-&gt;data);
}



int back(List L){
	if (L == NULL) {
		printf("List error: calling back() on Null list\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt;1) {
		printf("List error: calling back() on empty list\n");
		exit(EXIT_FAILURE);
	}
<a name="2"></a><font color="#0000FF"><a href="match6-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_16.gif"/></a>

	return (L-&gt;tail-&gt;data);
}


int get(List L) {
	if (L == NULL) {
		printf("List error: calling get() on Null list\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt;1) {
		printf("List error: calling get() on empty list\n");
		exit(EXIT_FAILURE);
	}
	if (index(L)&lt;0) {
		printf("List error: calling get() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	return (L-&gt;current-&gt;data);
}




int equals(List A, List B){
	int equal = 0;
	Node C = NULL;
	Node D = NULL;

	if (A == NULL || B == NULL) {
		printf("List error: calling equals() on Null list\n");
		exit(EXIT_FAILURE);
	}

	equal = (A-&gt;size == B-&gt;size);
	C = A-&gt;head;
	D = B-&gt;head;
	while (equal &amp;&amp; C != NULL &amp;&amp; D != NULL){
		equal = (C-&gt;data == D-&gt;data);
		C = C-&gt;next;
		D = D-&gt;next;
	}
	return equal;
}

void clear(List L) {
	if (L == NULL) {
		printf("List Error: calling clear() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	while (L-&gt;size &gt; 0) {
		Node outFnt = L-&gt;head;
		Node outBk = L-&gt;tail;
		if (outFnt != outBk) {
			deleteFront(L);
			deleteBack(L);
		} else {
			moveFront(L);
			delete (L);
		}
	}
	L-&gt;size = 0;
	L-&gt;cursorIndex = -1;
	L-&gt;current = NULL;
	L-&gt;head = NULL;
	L-&gt;tail = NULL;
}


void set(List L, int x) {
	if (length(L) &gt; 0 &amp;&amp; index(L) &gt;= 0) {
		L-&gt;current-&gt;data = x;
	} else {
		fprintf(stderr, "preconditions not met for set\n");
		exit(EXIT_FAILURE);
	}
}

void moveFront(List L) {
	if (L == NULL) {
		printf("List Error: calling moveFront() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &gt; 0) {
		L-&gt;current = L-&gt;head;
</font>		L-&gt;cursorIndex = 0;
	}
}


void moveBack(List L) {
	if (L == NULL) {
		printf("List Error: calling moveBack() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &gt; 0) {
	L-&gt;current = L-&gt;tail;
<a name="1"></a><font color="#00FF00"><a href="match6-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_18.gif"/></a>

	L-&gt;cursorIndex = L-&gt;size - 1;
	}
}


void movePrev(List L) {
	if (L == NULL) {
		printf("List Error: calling movePrev() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;current != NULL &amp;&amp; L-&gt;current != L-&gt;head) {
		L-&gt;current = L-&gt;current-&gt;prev;
		L-&gt;cursorIndex -= 1;
	} else {
		L-&gt;current = NULL;
		L-&gt;cursorIndex = -1;
	}
}



void moveNext(List L) {
	if (L == NULL) {
	printf("List Error: calling moveNext() on NULL List reference\n");
	exit(EXIT_FAILURE);
	}
	if (L-&gt;current != NULL &amp;&amp; L-&gt;current != L-&gt;tail) {
		L-&gt;current = L-&gt;current-&gt;next;
		L-&gt;cursorIndex += 1;
	}
	else {
		L-&gt;current = NULL;
		L-&gt;cursorIndex = -1;
	}
}


void prepend(List L, int x) {
	if (L == NULL) {
		printf("List Error: calling prepend() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	Node NN = (Node)malloc(sizeof(NodeObj));
    	if (NN == NULL) {
	        printf("node allocation error\n");
		exit(EXIT_FAILURE);
	}
	NN-&gt;data = x;
	NN-&gt;prev = NULL;
	NN-&gt;next = L-&gt;head;
	if (L-&gt;size == 0) {
		L-&gt;head = NN;
		L-&gt;tail = NN;
	} else {
		NN-&gt;next = L-&gt;head;
		L-&gt;head-&gt;prev = NN;
		L-&gt;head = NN;
	}
	L-&gt;size++;
	if (L-&gt;current != NULL &amp;&amp; L-&gt;cursorIndex &gt;= 0) {
		L-&gt;cursorIndex += 1;
	}
}



void append(List L, int x) {
	if (L == NULL) {
		printf("List Error: calling append() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	Node NN = (Node)malloc(sizeof(NodeObj));
	if (NN == NULL){
		printf("node allocation error\n");
		exit(EXIT_FAILURE);
	}
	NN-&gt;data = x;
	NN-&gt;prev = L-&gt;tail;
	NN-&gt;next = NULL;
	if (L-&gt;size == 0) {
		L-&gt;head = NN;
		L-&gt;tail = NN;
	}
	else {
		L-&gt;tail-&gt;next = NN;
</font>		NN-&gt;prev = L-&gt;tail;
<a name="4"></a><font color="#FF00FF"><a href="match6-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_6.gif"/></a>

		L-&gt;tail = NN;
	}
	L-&gt;size++;
}

	

void insertBefore(List L, int x) {
	if (L == NULL) {
		printf("List Error: calling insertBefore() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt; 1) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	Node NN = (Node)malloc(sizeof(NodeObj));
	if (NN == NULL){
		printf("Node allocation erro\n");
		exit(EXIT_FAILURE);
	}
	NN-&gt;data = x;
	NN-&gt;next = L-&gt;current;
	NN-&gt;prev = L-&gt;current-&gt;prev;
	if (L-&gt;current == L-&gt;head) {
		L-&gt;head-&gt;prev = NN;
		NN-&gt;next = L-&gt;head;
		L-&gt;head = NN;
</font>	}
	else {
		NN-&gt;prev = L-&gt;current-&gt;prev;
<a name="0"></a><font color="#FF0000"><a href="match6-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_35.gif"/></a>

		L-&gt;current-&gt;prev-&gt;next = NN;
		NN-&gt;next = L-&gt;current;
		L-&gt;current-&gt;prev = NN;
	}
		L-&gt;size += 1;
		L-&gt;cursorIndex += 1;
}


void insertAfter(List L, int x) {
	if (L == NULL) {
		printf("List Error: calling insertBefore() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt; 1) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	Node NN = (Node)malloc(sizeof(NodeObj));
	if (NN == NULL){
		printf("Node allocation erro\n");
		exit(EXIT_FAILURE);
	}
	NN-&gt;data = x;
	NN-&gt;next = L-&gt;current-&gt;next;
	NN-&gt;prev = L-&gt;current;

	if (L-&gt;current == L-&gt;tail) {
		L-&gt;tail-&gt;next = NN;
		NN-&gt;prev = L-&gt;tail;
		L-&gt;tail = NN;
	}
	else {
		L-&gt;current-&gt;next-&gt;prev = NN;
		NN-&gt;next = L-&gt;current-&gt;next;
		NN-&gt;prev = L-&gt;current;
		L-&gt;current-&gt;next = NN;
	}
		L-&gt;size += 1;
}





void deleteFront(List L) {
	if (L == NULL) {
		printf("List Error: calling insertBefore() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt; 1) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	Node outN = L-&gt;head;
	if (L-&gt;tail == L-&gt;head) {
		L-&gt;head = NULL;
		L-&gt;tail = NULL;
		L-&gt;current = NULL;
		L-&gt;size = 0;
		L-&gt;cursorIndex = -1;
	}
	else {
		if (L-&gt;current == L-&gt;head) {
			L-&gt;current = NULL;
			L-&gt;cursorIndex = -1;
		}
		if ((L-&gt;cursorIndex &gt; 0) &amp;&amp; (L-&gt;current != L-&gt;head)) {
			L-&gt;cursorIndex -= 1;
		}
	Node tempN = L-&gt;head-&gt;next;
	tempN-&gt;prev = NULL;
	L-&gt;head-&gt;next = NULL;
	L-&gt;head = tempN;
	free(outN);
	L-&gt;size -= 1;
	}
}


void deleteBack(List L) {
	if (L == NULL) {
		printf("List Error: calling insertBefore() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt; 1) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	Node outN = L-&gt;tail;
	if (L-&gt;tail == L-&gt;head) {
		L-&gt;head = NULL;
		L-&gt;tail = NULL;
		L-&gt;current = NULL;
		L-&gt;size = 0;
		L-&gt;cursorIndex = -1;
	}
	else {
		if (L-&gt;current == L-&gt;tail) {
			L-&gt;current = NULL;
			L-&gt;cursorIndex = -1;
		}
		Node tempN = L-&gt;tail-&gt;prev;
		L-&gt;tail-&gt;prev-&gt;next = NULL;
		L-&gt;tail-&gt;prev = NULL;
		L-&gt;tail = tempN;
		free(outN);
		L-&gt;size -= 1;
	}
}




void delete(List L) {
	if (L == NULL) {
		printf("List Error: calling insertBefore() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;size &lt; 1) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	if (index(L) &lt; 0) {
		printf("List Error: calling insertBefore() on an empty List\n");
		exit(EXIT_FAILURE);
	}
	if (L-&gt;current == L-&gt;head) {
		deleteFront(L);
	}
	else if (L-&gt;current == L-&gt;tail) {
		deleteBack(L);
	}
	else {
		Node outN = L-&gt;current;
		Node tempN = outN-&gt;prev;
		tempN-&gt;next = outN-&gt;next;
		outN-&gt;next-&gt;prev = tempN;
		outN-&gt;prev = NULL;
		outN-&gt;next = NULL;
		free(outN);
		L-&gt;size -= 1;
		}
	L-&gt;current = NULL;
	L-&gt;cursorIndex = -1;
}


void printList(FILE* out, List L) {
	if (L == NULL) {
</font>		printf("List Error: calling printList() on NULL List reference\n");
		exit(EXIT_FAILURE);
	}
	Node NN = L-&gt;head;
	while (NN != NULL) {
		fprintf(out, "%d ", NN-&gt;data);
		NN = NN-&gt;next;
	}
}


List copyList(List L) {
	List copy = newList();
	Node temp = L-&gt;head;
	while (temp != NULL) {
		append(copy, temp-&gt;data);
		temp = temp-&gt;next;
	}
	return copy;
}


</pre>
</body>
</html>
