<html>
<head>
<title>/fall24/indelrio/pa1/List.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/indelrio/pa1/List.c<p></p><pre>
/*
Ivan Del Rio
indelrio
2024 Fall CSE101 PA1
List.c
This file implements the functions defined in List.h. It provides the logic for list manipulation, including adding elements, moving the cursor, copying lists, and deleting elements. It also handles memory management for lists.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "List.h"

// Node structure for doubly linked list
typedef struct NodeObj {
    int data;
    struct NodeObj* prev;
    struct NodeObj* next;
} NodeObj;

typedef NodeObj* Node;

// List structure to manage the linked list
typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int length;
    int index;
} ListObj;

// Constructors-Destructors ---------------------------------------------------

// newList()
// Creates and returns a new empty List.
List newList(void) {
    List L = malloc(sizeof(ListObj));
    L-&gt;front = NULL;
    L-&gt;back = NULL;
    L-&gt;cursor = NULL;
    L-&gt;length = 0;
    L-&gt;index = -1;
    return L;
}

// freeList()
// Frees all heap memory associated with *pL, and sets *pL to NULL.
void freeList(List* pL) {
<a name="0"></a><font color="#FF0000"><a href="match117-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

    if (pL != NULL &amp;&amp; *pL != NULL) {
        while (length(*pL) &gt; 0) {
            deleteFront(*pL);
        }
        free(*pL);
        *pL = NULL;
    }
}

// newNode()
// Private helper function to create a new Node
Node newNode(int data) {
    Node N = malloc(sizeof(NodeObj));
    N-&gt;data = data;
    N-&gt;prev = NULL;
    N-&gt;next = NULL;
    return N;
}

// freeNode()
// Private helper function to free a Node
void freeNode(Node* pN) {
    if (pN != NULL &amp;&amp; *pN != NULL) {
        free(*pN);
        *pN = NULL;
    }
}

// Access functions -----------------------------------------------------------

// length()
// Returns the number of elements in L.
int length(List L) {
    return L-&gt;length;
}

// index()
// Returns index of cursor element if defined, -1 otherwise.
int index(List L) {
    return L-&gt;cursor == NULL ? -1 : L-&gt;index;
}

// front()
// Returns front element of L.
// Pre: length()&gt;0
int front(List L) {
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: calling front() on an empty List\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;front-&gt;data;
}

// back()
// Returns back element of L.
// Pre: length()&gt;0
int back(List L) {
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: calling back() on an empty List\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;back-&gt;data;
}

// get()
// Returns cursor element of L.
// Pre: length()&gt;0, index()&gt;=0
int get(List L) {
    if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
        fprintf(stderr, "List Error: calling get() with an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    return L-&gt;cursor-&gt;data;
}

// equals()
// Returns true iff Lists A and B contain the same sequence of elements.
bool equals(List A, List B) {
    if (A-&gt;length != B-&gt;length) return false;
</font>    Node nA = A-&gt;front;
    Node nB = B-&gt;front;
    while (nA != NULL &amp;&amp; nB != NULL) {
        if (nA-&gt;data != nB-&gt;data) return false;
        nA = nA-&gt;next;
        nB = nB-&gt;next;
    }
    return true;
}

// Manipulation procedures ----------------------------------------------------

// clear()
// Resets L to its original empty state.
void clear(List L) {
    while (length(L) &gt; 0) {
<a name="5"></a><font color="#FF0000"><a href="match117-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        deleteFront(L);
    }
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
}

// set()
// Overwrites the cursor elementâ€™s data with x.
// Pre: length()&gt;0, index()&gt;=0
void set(List L, int x) {
    if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
        fprintf(stderr, "List Error: calling set() with an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    L-&gt;cursor-&gt;data = x;
}

// moveFront()
// If L is non-empty, sets cursor under the front element, otherwise does nothing.
void moveFront(List L) {
    if (L-&gt;length &gt; 0) {
</font>        L-&gt;cursor = L-&gt;front;
        L-&gt;index = 0;
    }
}

// moveBack()
// If L is non-empty, sets cursor under the back element, otherwise does nothing.
void moveBack(List L) {
    if (L-&gt;length &gt; 0) {
        L-&gt;cursor = L-&gt;back;
        L-&gt;index = L-&gt;length - 1;
    }
}

// movePrev()
// If cursor is defined and not at front, move cursor one step toward front of L.
void movePrev(List L) {
    if (L-&gt;cursor != NULL) {
        if (L-&gt;cursor == L-&gt;front) {
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        } else {
            L-&gt;cursor = L-&gt;cursor-&gt;prev;
            L-&gt;index--;
        }
    }
}

// moveNext()
// If cursor is defined and not at back, move cursor one step toward back of L.
void moveNext(List L) {
    if (L-&gt;cursor != NULL) {
        if (L-&gt;cursor == L-&gt;back) {
            L-&gt;cursor = NULL;
            L-&gt;index = -1;
        } else {
            L-&gt;cursor = L-&gt;cursor-&gt;next;
            L-&gt;index++;
        }
    }
}

// prepend()
// Insert new element into L. If L is non-empty, insertion takes place before front element.
void prepend(List L, int x) {
    Node N = newNode(x);
    if (L-&gt;length == 0) {
        L-&gt;front = L-&gt;back = N;
    } else {
        N-&gt;next = L-&gt;front;
        L-&gt;front-&gt;prev = N;
        L-&gt;front = N;
    }
<a name="8"></a><font color="#00FFFF"><a href="match117-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

    L-&gt;length++;
    if (L-&gt;cursor != NULL) L-&gt;index++;
}

// append()
// Insert new element into L. If L is non-empty, insertion takes place after back element.
void append(List L, int x) {
    Node N = newNode(x);
    if (L-&gt;length == 0) {
        L-&gt;front = L-&gt;back = N;
</font>    } else {
        N-&gt;prev = L-&gt;back;
<a name="3"></a><font color="#00FFFF"><a href="match117-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

        L-&gt;back-&gt;next = N;
        L-&gt;back = N;
    }
    L-&gt;length++;
}

// insertBefore()
// Insert new element before cursor
// Pre: length()&gt;0, index()&gt;=0
void insertBefore(List L, int x) {
    if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
        fprintf(stderr, "List Error: calling insertBefore() with an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    Node N = newNode(x);
    N-&gt;next = L-&gt;cursor;
    N-&gt;prev = L-&gt;cursor-&gt;prev;
</font>    if (L-&gt;cursor-&gt;prev != NULL) {
        L-&gt;cursor-&gt;prev-&gt;next = N;
    } else {
        L-&gt;front = N;
    }
<a name="4"></a><font color="#FF00FF"><a href="match117-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    L-&gt;cursor-&gt;prev = N;
    L-&gt;length++;
    L-&gt;index++;
}

// insertAfter()
// Insert new element after cursor
// Pre: length()&gt;0, index()&gt;=0
void insertAfter(List L, int x) {
    if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
        fprintf(stderr, "List Error: calling insertAfter() with an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    Node N = newNode(x);
    N-&gt;prev = L-&gt;cursor;
    N-&gt;next = L-&gt;cursor-&gt;next;
</font>    if (L-&gt;cursor-&gt;next != NULL) {
        L-&gt;cursor-&gt;next-&gt;prev = N;
<a name="6"></a><font color="#00FF00"><a href="match117-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

    } else {
        L-&gt;back = N;
    }
    L-&gt;cursor-&gt;next = N;
    L-&gt;length++;
}

// deleteFront()
// Delete the front element
// Pre: length()&gt;0
void deleteFront(List L) {
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: calling deleteFront() on an empty List\n");
        exit(EXIT_FAILURE);
    }
    Node N = L-&gt;front;
    if (L-&gt;length &gt; 1) {
        L-&gt;front = L-&gt;front-&gt;next;
</font>        L-&gt;front-&gt;prev = NULL;
    } else {
        L-&gt;front = L-&gt;back = NULL;
    }
<a name="1"></a><font color="#00FF00"><a href="match117-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    if (L-&gt;cursor == N) {
        L-&gt;cursor = NULL;
        L-&gt;index = -1;
    }
    freeNode(&amp;N);
    L-&gt;length--;
    if (L-&gt;cursor != NULL) L-&gt;index--;
}

// deleteBack()
// Delete the back element
// Pre: length()&gt;0
void deleteBack(List L) {
    if (L-&gt;length == 0) {
        fprintf(stderr, "List Error: calling deleteBack() on an empty List\n");
        exit(EXIT_FAILURE);
    }
    Node N = L-&gt;back;
    if (L-&gt;length &gt; 1) {
        L-&gt;back = L-&gt;back-&gt;prev;
</font>        L-&gt;back-&gt;next = NULL;
    } else {
        L-&gt;front = L-&gt;back = NULL;
    }
    if (L-&gt;cursor == N) {
<a name="2"></a><font color="#0000FF"><a href="match117-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

        L-&gt;cursor = NULL;
        L-&gt;index = -1;
    }
    freeNode(&amp;N);
    L-&gt;length--;
}

// delete()
// Delete cursor element, making cursor undefined
// Pre: length()&gt;0, index()&gt;=0
void delete(List L) {
    if (L-&gt;length == 0 || L-&gt;cursor == NULL) {
        fprintf(stderr, "List Error: calling delete() with an undefined cursor\n");
        exit(EXIT_FAILURE);
    }
    Node N = L-&gt;cursor;
    if (L-&gt;cursor-&gt;prev != NULL) {
        L-&gt;cursor-&gt;prev-&gt;next = L-&gt;cursor-&gt;next;
</font>    } else {
        L-&gt;front = L-&gt;cursor-&gt;next;
    }
<a name="7"></a><font color="#0000FF"><a href="match117-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    if (L-&gt;cursor-&gt;next != NULL) {
        L-&gt;cursor-&gt;next-&gt;prev = L-&gt;cursor-&gt;prev;
    } else {
        L-&gt;back = L-&gt;cursor-&gt;prev;
    }
    freeNode(&amp;N);
    L-&gt;cursor = NULL;
    L-&gt;index = -1;
    L-&gt;length--;
}

// Other operations -----------------------------------------------------------

// printList()
// Prints to the file pointed to by out, a string representation of L.
void printList(FILE* out, List L) {
</font>    Node N = L-&gt;front;
    while (N != NULL) {
        fprintf(out, "%d ", N-&gt;data);
        N = N-&gt;next;
    }
}

// copyList()
// Returns a new List representing the same integer sequence as L. The cursor in the new list is undefined.
List copyList(List L) {
    List newL = newList();
    Node N = L-&gt;front;
    while (N != NULL) {
        append(newL, N-&gt;data);
        N = N-&gt;next;
    }
    return newL;
}

</pre>
</body>
</html>
