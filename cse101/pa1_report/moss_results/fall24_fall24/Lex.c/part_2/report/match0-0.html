<html>
<head>
<title>/fall24/edwhuang/pa1/Lex.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/edwhuang/pa1/Lex.c<p></p><pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include "List.h"

// private NodeObj type
<a name="0"></a><font color="#FF0000"><a href="match0-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_99.gif"/></a>

typedef struct NodeObj {
    ListElement data;
    struct NodeObj* next;
    struct NodeObj* prev;
} NodeObj;

// private Node type
typedef NodeObj* Node;

// private ListObj type
typedef struct ListObj {
    Node front;
    Node back;
    Node cursor;
    int index;
    int length;
} ListObj;


char* trim(char *str) {
    char *end;

    // Trim leading space
    while (isspace((unsigned char)*str)) str++;

    if (*str == 0)  // All spaces?
        return str;

    // Trim trailing space
    end = str + strlen(str) - 1;
    while (end &gt; str &amp;&amp; isspace((unsigned char)*end)) end--;

    // Null terminate
    end[1] = '\0';

    return str;
}

int main(int argc, char* argv[]) {
    // ex) Lex in.txt out.txt
    if (argc &lt; 3) {
        printf("Lex Error: more or less than 2 command line arguments are given\n");
        exit(EXIT_FAILURE);
    }

    FILE *in = fopen(argv[1], "r");
    FILE *out = fopen(argv[2], "w");

    // if the file cannot be opened for whatever reason
    if (in == NULL) {
        printf("Error opening the file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }


    // array of strings that will hold the file's lines
    char** strArr = NULL;
    int count = 0;
    char buff[1024];

    // List whose elements are the indices of strArr
    List L = newList();

    // reading lines from file
    while (fgets(buff, sizeof(buff), in) != NULL) {

        // dynamically allocating memory
        char** tempArr = realloc(strArr, (count + 1) * sizeof(char*));

        // if memory can't be allocated
        if (tempArr == NULL) {
            printf("Error allocating memory for tempArr\n");
            exit(EXIT_FAILURE);
        }

        strArr = tempArr;


        // allocating memory for the new line and copying it from buff
        strArr[count] = malloc((strlen(buff) + 1) * sizeof(char));

        if (strArr[count] == NULL) {
            printf("Error allocating memory for strArr's lines");
            exit(EXIT_FAILURE);
        }

        // copy the line and increment the line count
        strcpy(strArr[count], buff);
        count++;
    }

    // general logic:
    // ex) strcmp(s1, s2)
    // 1) if strcmp() &lt; 0, then s1 is less than s2
    // 2) if strcmp() &gt; 0, then s1 is greater than s2
    // 3) if strcmp() == 0, then s1 is the same (not handled)
    for (int i = 0; i &lt; count; i++) {
        // set a new node with current index
        Node N = malloc(sizeof(NodeObj));
        N-&gt;data = i;
        N-&gt;next = N-&gt;prev = NULL;

        // check if L is empty or if s1 is less than s2
        if (L-&gt;front == NULL || strcmp(strArr[N-&gt;data], strArr[L-&gt;front-&gt;data]) &lt; 0) {
            // point N's next pointer to the front of L
            N-&gt;next = L-&gt;front;
            // if isn't empty, then connect the new node's prev pointer
            if (L-&gt;front != NULL) {
                L-&gt;front-&gt;prev = N;
            }
            // the new node is now the head
            L-&gt;front = N;
        }

        // otherwise if L isn't empty and s1 is greater than s2
        else {
            // get L's front
            Node currNode = L-&gt;front;

            // start looking for the appropriate place to put it and stop it when s1 is greater than s2 
            while (currNode-&gt;next &amp;&amp; strcmp(strArr[currNode-&gt;next-&gt;data], strArr[N-&gt;data]) &lt; 0) {
                currNode = currNode-&gt;next;
            }

            N-&gt;next = currNode-&gt;next;

            // if it isn't the end yet, then connect it in the middle
            if (currNode-&gt;next != NULL) {
                currNode-&gt;next-&gt;prev = N;
            }

            currNode-&gt;next = N;
            N-&gt;prev = currNode;
        }

        L-&gt;length++;
    }
    
    // printing to out.txt
    Node curr = L-&gt;front;
    while (curr != NULL) {
        fprintf(out, "%s\n", trim(strArr[curr-&gt;data]));
        curr = curr-&gt;next;
    }


    // freeing everything afterwards
    for (int i = 0; i &lt; count; i++) {
        free(strArr[i]);
    }
    free(strArr);

    for (int i = 0; i &lt; count; i++) {
        deleteBack(L);
    }

    freeList(&amp;L);

    fclose(in);
    fclose(out);
</font>
    return 0;
}</pre>
</body>
</html>
