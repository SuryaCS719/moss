<html>
<head>
<title>/fall24/mthallet/pa1/Lex.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/mthallet/pa1/Lex.c<p></p><pre>
#include "List.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


<a name="0"></a><font color="#FF0000"><a href="match3-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_98.gif"/></a>

typedef struct string_node {
    char *str;
    struct string_node *next;
} string_node;


// Pushes a new string onto existing linked list
// Use NULL for existing to start a new list
string_node *push_node(string_node *existing, char *new_s) {
    string_node *new_node = (string_node*)  malloc(sizeof(string_node));
    new_node-&gt;next = existing;
    new_node-&gt;str = new_s;
    return new_node;
}



// Does not return the top element, only gets rid of it
string_node *pop_node(string_node *list) {
    string_node *next_ptr = list-&gt;next;
    free(list);
    return next_ptr;
}


// Frees list linked of strings pointed to by ptr
// Does not set ptr to NULL
void free_strings(string_node *ptr) {
    string_node *next_ptr;
    while(ptr) {
        next_ptr = ptr-&gt;next;
        free(ptr-&gt;str);
        free(ptr);
        ptr = next_ptr;
    }
    return;
}

// Only frees linked list data structure, does not free the strings they point to!
// WARNING: if you don't save those pointers you cant free them and you have a mem leak!
void free_just_nodes(string_node *ptr) {
    string_node *next_ptr;
    while(ptr) {
        next_ptr = ptr-&gt;next;
        free(ptr);
        ptr = next_ptr;
    }
    return;
}



// Unsafe strdup alternative
char *sdup(char *src) {
    int unsigned length = strlen(src);
    char *new_s = (char*) malloc(sizeof(char) * (length + 1));
    strcpy(new_s, src);
    return new_s;
}


int main(int argc, char *argv[]) {
    if(argc != 3) {
        fprintf(stderr, "Inocrrect argument count, terminating program\n");
        return 1;
    }

    char buffer[4096];

    // Opening input file for reading from
    FILE *infile = fopen(argv[1], "r");
    if(infile == NULL) {
        fprintf(stderr, "Error opening input file, did you type something incorrectly?\n");
        return -1;  // exiting program
    }

    // Opening output file from OS to write to
    FILE *outfile = fopen(argv[2], "w");
    if(outfile == NULL) {
        fprintf(stderr, "Error opening the outfile to write, are you out of disk space?\n");
        return -1;  // exiting program
    }





    // Reading strings into linked list
    string_node *list = NULL;
    unsigned int count = 0;
    while(fgets(buffer, 4096, infile)) {
        list = push_node(list, sdup(buffer));
        count++;
    }
    fclose(infile);
    if(count == 0) {
        fprintf(stderr, "The file you inputted appears to be empty, maybe try a different file?\n");
        return -1;
    }




    // Putting strings into array
    string_node *ptr = list;
    char **strings = (char**) malloc(sizeof(char*) * count);
    for(int i = 0; i &lt; count; i++) {
        strings[i] = ptr-&gt;str;
        ptr = ptr-&gt;next;
    }

    // Freeing just the nodes, keeping the strings still allocated to work on them
    free_just_nodes(list);
    list = NULL;


    // Making new list and setting it up to be sorted
    List L = newList();
    int greater;
    append(L, 0);



    // Sorting the list (kind of weird code but it works !)
    for(unsigned int i = 1; i &lt; count; i++) {
        moveFront(L);
        while(index(L) != -1) {
            greater = strcmp(strings[get(L)], strings[i]);
            if(greater &lt; 0) { // if the string should go after, move to the next position to check that string
                moveNext(L);
            }
            else { // if not, break out of this loop to insert something before it
                break;
            }
        }
        if(index(L) == -1) {
            append(L, i);
        }
        else {
            insertBefore(L, i);
        }
    }


    // Printing out to outfile
    moveFront(L);
    while(index(L) != -1) {
        fprintf(outfile, "%s", strings[get(L)]);
        moveNext(L);
    }


    // Freeing memory and cleaning up
    for(unsigned int i = 0; i &lt; count; i++) {
        free(strings[i]);
    }
    free(strings);
    freeList(&amp;L);
</font>    fclose(outfile);
    return 0;
}</pre>
</body>
</html>
