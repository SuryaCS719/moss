<html>
<head>
<title>/fall24/flee14/pa1/Lex.c</title>
</head>
<body bgcolor="white">
<hr/>
/fall24/flee14/pa1/Lex.c<p></p><pre>
/***
* Paul Lee
* flee14
* 2024 Fall CSE101 PA{1}
* Lex.c
* This file is where I implement the sort
***/ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include "List.h"

#define MAX_LENGTH 100

// Custom function to duplicate a string (alternative to strduplicate)
<a name="1"></a><font color="#00FF00"><a href="match87-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_23.gif"/></a>

char *strduplicate(const char *str) {
    // Calculate the length of the string + 1 for '\0'
    int n = strlen(str) + 1; 
    // Allocate memory on the heap for the duplicated string        
    char *duplicate_string = malloc(n);
    // Check if allocation was successful           
    if (duplicate_string) {
        // Copy the string into the newly allocated memory                       
        strcpy(duplicate_string, str);             
    }
    // Return the pointer to the duplicated string
    return duplicate_string;                      
}

int main(int argc, char *argv[]) {
    // Variable to store the number of lines in the input file
    int lineCount;
    // Pointers for input and output files                  
    FILE *inputFile, *outputFile;
    // Buffer to hold each line from the file                  
    char line[MAX_LENGTH];

    // 1. Check command line arguments
    // Check that there are two command line arguments (other than the program name Lex).
    // Quit with a usage message to stderr if more than or less than two command line arguments are given
    // Ensure that exactly 2 additional arguments are passed: input and output file names
    if (argc != 3) {
        fprintf(stderr, "Usage: %s &lt;input file&gt; &lt;output file&gt;\n", argv[0]);
        // Exit with an error code if incorrect arguments are provided
        exit(1);                      
</font>    }

    // 2. Open files for reading and writing (here you need access to the input files from the grading script)
    // Open the input file in read mode, check if the file opened successfully
    inputFile = fopen(argv[1], "r");
    if (inputFile == NULL) {
        fprintf(stderr, "Unable to open file %s for reading\n", argv[1]);
        // Exit if unable to open input file
        exit(1);  
    }

    // Open the output file in write mode, check if the file opened successfully
<a name="0"></a><font color="#FF0000"><a href="match87-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_60.gif"/></a>

    outputFile = fopen(argv[2], "w");
    if (outputFile == NULL) {
        fprintf(stderr, "Unable to open file %s for writing\n", argv[2]);
        // Exit if unable to open output file
        exit(1);                      
    }

    // 3. Count the number of lines in the input file
    lineCount = 0;
    // Read the file line by line using fgets and count the total number of lines
    while (fgets(line, MAX_LENGTH, inputFile) != NULL) {
        // Increment line_count for each line
        lineCount++;                 
    }
    
    // 4. Create a string array of length n and read in the lines of the file as strings placing them into the array. 
    // Then, allocate memory for storing each line in an array of strings (heap allocation)
    // Rewind the file to the beginning so we can read the lines again
    rewind(inputFile);
    // Allocate memory for an array of string pointers, one for each line
    // use malloc() or calloc() here, as specified in the pa1.pdf
    char **string_array = (char **)calloc(lineCount, sizeof(char *));
    // Read each line from the file and store it in string_array
    int string_array_index = 0;
    while (fgets(line, MAX_LENGTH, inputFile) != NULL) {
        // Duplicate each line and store the pointer in string_array
        string_array[string_array_index] = strduplicate(line);  
        string_array_index++;
    }
    
    // 5. Create a List of indices that indirectly sorts the array using insertion sort

    // Pseudocode of Insertion Sort from previous class
    // ListItem *InsertionSort(ListItem* list) {
//     ListItem *current = list-&gt;nextItem;
    
//     while (current != NULL) {
//         ListItem *key_var = current;
//         ListItem *prev = current-&gt;previousItem;

//         while (prev != NULL &amp;&amp; strcmp(prev-&gt;data, key_var-&gt;data) &gt; 0) {
//             // Shift elements of the linked list that are greater than key to one position ahead
//             LinkedListSwapData(prev, key_var);
//             key_var = prev;
//             prev = prev-&gt;previousItem;
//         }
//         current = current-&gt;nextItem;
//     }

    // Create a List whose elements are the indices of the above string array.
    // Use for loop and while loop to arrange the indices in an order that indirectly sorts the array.
    // Create a new empty List
    List L = newList();
    // Start by appending the first index (0) to the list               
    append(L, 0);                     
    // Insert indices into the List in sorted order using Insertion Sort logic
    for (int i = 1; i &lt; lineCount; i++) {
        // Start at the front of the List
        moveFront(L);
        // Traverse the list                  
        while (index(L) &gt;= 0) {        
        // Compare strings at current list index and current string i
        if (strcmp(string_array[get(L)], string_array[i]) &gt; 0) {
            // Stop if we find the right position to insert
            break;                   
        }
        // Move to the next position in the list
        moveNext(L);                
    }
    // Insert the index either before or after the current position
    if (index(L) &lt; 0) {
        // If we reached the end, append the index
        append(L, i);               
    } else {
        // Otherwise, insert the index before the current cursor
        insertBefore(L, i);         
    }
    }
   
    // 6. Output the lines in sorted order by using the List of indices
    // Move cursor to the front of the List
    moveFront(L);                     
    while (index(L) &gt;= 0) {
        // Get the current index from the List
        int x = get(L);
        // Print the corresponding string to the output file                
        fprintf(outputFile, "%s", string_array[x]);
        // Move to the next index in the List 
        moveNext(L);                   
    }
    
    // 7. Free allocated memory
    // Free the List and its internal resources
    freeList(&amp;L);                     
    // Free each duplicated string from string_array
    for (int i = 0; i &lt; lineCount; i++) {
        free(string_array[i]);
</font>    }
    // Free the memory for the string_array array itself
    free(string_array);
    
    // 8. Close input and output files
    // Close the input file
    fclose(inputFile);   
    // Close the output file                    
    fclose(outputFile);
    // return                     
    return 0;
}</pre>
</body>
</html>
